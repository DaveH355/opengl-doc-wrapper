#ifndef GL_DOC_HPP
#define GL_DOC_HPP

#if __has_include(<glad/gl.h>)
#include <glad/gl.h>
#endif

#if __has_include(<glad/glad.h>)
#include <glad/glad.h>
#endif

#undef GL_ACTIVE_ATOMIC_COUNTER_BUFFERS
#undef GL_ACTIVE_ATTRIBUTES
#undef GL_ACTIVE_ATTRIBUTE_MAX_LENGTH
#undef GL_ACTIVE_PROGRAM
#undef GL_ACTIVE_RESOURCES
#undef GL_ACTIVE_SUBROUTINES
#undef GL_ACTIVE_SUBROUTINE_MAX_LENGTH
#undef GL_ACTIVE_SUBROUTINE_UNIFORMS
#undef GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS
#undef GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH
#undef GL_ACTIVE_TEXTURE
#undef GL_ACTIVE_UNIFORMS
#undef GL_ACTIVE_UNIFORM_BLOCKS
#undef GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH
#undef GL_ACTIVE_UNIFORM_MAX_LENGTH
#undef GL_ACTIVE_VARIABLES
#undef GL_ALIASED_LINE_WIDTH_RANGE
#undef GL_ALL_BARRIER_BITS
#undef GL_ALL_SHADER_BITS
#undef GL_ALPHA
#undef GL_ALREADY_SIGNALED
#undef GL_ALWAYS
#undef GL_AND
#undef GL_AND_INVERTED
#undef GL_AND_REVERSE
#undef GL_ANY_SAMPLES_PASSED
#undef GL_ANY_SAMPLES_PASSED_CONSERVATIVE
#undef GL_ARRAY_BUFFER
#undef GL_ARRAY_BUFFER_BINDING
#undef GL_ARRAY_SIZE
#undef GL_ARRAY_STRIDE
#undef GL_ATOMIC_COUNTER_BARRIER_BIT
#undef GL_ATOMIC_COUNTER_BUFFER
#undef GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS
#undef GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES
#undef GL_ATOMIC_COUNTER_BUFFER_BINDING
#undef GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE
#undef GL_ATOMIC_COUNTER_BUFFER_INDEX
#undef GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER
#undef GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER
#undef GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER
#undef GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER
#undef GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER
#undef GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER
#undef GL_ATOMIC_COUNTER_BUFFER_SIZE
#undef GL_ATOMIC_COUNTER_BUFFER_START
#undef GL_ATTACHED_SHADERS
#undef GL_AUTO_GENERATE_MIPMAP
#undef GL_BACK
#undef GL_BACK_LEFT
#undef GL_BACK_RIGHT
#undef GL_BGR
#undef GL_BGRA
#undef GL_BGRA_INTEGER
#undef GL_BGR_INTEGER
#undef GL_BLEND
#undef GL_BLEND_COLOR
#undef GL_BLEND_DST
#undef GL_BLEND_DST_ALPHA
#undef GL_BLEND_DST_RGB
#undef GL_BLEND_EQUATION
#undef GL_BLEND_EQUATION_ALPHA
#undef GL_BLEND_EQUATION_RGB
#undef GL_BLEND_SRC
#undef GL_BLEND_SRC_ALPHA
#undef GL_BLEND_SRC_RGB
#undef GL_BLOCK_INDEX
#undef GL_BLUE
#undef GL_BLUE_INTEGER
#undef GL_BOOL
#undef GL_BOOL_VEC2
#undef GL_BOOL_VEC3
#undef GL_BOOL_VEC4
#undef GL_BUFFER
#undef GL_BUFFER_ACCESS
#undef GL_BUFFER_ACCESS_FLAGS
#undef GL_BUFFER_BINDING
#undef GL_BUFFER_DATA_SIZE
#undef GL_BUFFER_IMMUTABLE_STORAGE
#undef GL_BUFFER_MAPPED
#undef GL_BUFFER_MAP_LENGTH
#undef GL_BUFFER_MAP_OFFSET
#undef GL_BUFFER_MAP_POINTER
#undef GL_BUFFER_SIZE
#undef GL_BUFFER_STORAGE_FLAGS
#undef GL_BUFFER_UPDATE_BARRIER_BIT
#undef GL_BUFFER_USAGE
#undef GL_BUFFER_VARIABLE
#undef GL_BYTE
#undef GL_CAVEAT_SUPPORT
#undef GL_CCW
#undef GL_CLAMP_READ_COLOR
#undef GL_CLAMP_TO_BORDER
#undef GL_CLAMP_TO_EDGE
#undef GL_CLEAR
#undef GL_CLEAR_BUFFER
#undef GL_CLEAR_TEXTURE
#undef GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT
#undef GL_CLIENT_STORAGE_BIT
#undef GL_CLIPPING_INPUT_PRIMITIVES
#undef GL_CLIPPING_OUTPUT_PRIMITIVES
#undef GL_CLIP_DEPTH_MODE
#undef GL_CLIP_DISTANCE0
#undef GL_CLIP_DISTANCE1
#undef GL_CLIP_DISTANCE2
#undef GL_CLIP_DISTANCE3
#undef GL_CLIP_DISTANCE4
#undef GL_CLIP_DISTANCE5
#undef GL_CLIP_DISTANCE6
#undef GL_CLIP_DISTANCE7
#undef GL_CLIP_ORIGIN
#undef GL_COLOR
#undef GL_COLOR_ATTACHMENT0
#undef GL_COLOR_ATTACHMENT1
#undef GL_COLOR_ATTACHMENT10
#undef GL_COLOR_ATTACHMENT11
#undef GL_COLOR_ATTACHMENT12
#undef GL_COLOR_ATTACHMENT13
#undef GL_COLOR_ATTACHMENT14
#undef GL_COLOR_ATTACHMENT15
#undef GL_COLOR_ATTACHMENT16
#undef GL_COLOR_ATTACHMENT17
#undef GL_COLOR_ATTACHMENT18
#undef GL_COLOR_ATTACHMENT19
#undef GL_COLOR_ATTACHMENT2
#undef GL_COLOR_ATTACHMENT20
#undef GL_COLOR_ATTACHMENT21
#undef GL_COLOR_ATTACHMENT22
#undef GL_COLOR_ATTACHMENT23
#undef GL_COLOR_ATTACHMENT24
#undef GL_COLOR_ATTACHMENT25
#undef GL_COLOR_ATTACHMENT26
#undef GL_COLOR_ATTACHMENT27
#undef GL_COLOR_ATTACHMENT28
#undef GL_COLOR_ATTACHMENT29
#undef GL_COLOR_ATTACHMENT3
#undef GL_COLOR_ATTACHMENT30
#undef GL_COLOR_ATTACHMENT31
#undef GL_COLOR_ATTACHMENT4
#undef GL_COLOR_ATTACHMENT5
#undef GL_COLOR_ATTACHMENT6
#undef GL_COLOR_ATTACHMENT7
#undef GL_COLOR_ATTACHMENT8
#undef GL_COLOR_ATTACHMENT9
#undef GL_COLOR_BUFFER_BIT
#undef GL_COLOR_CLEAR_VALUE
#undef GL_COLOR_COMPONENTS
#undef GL_COLOR_ENCODING
#undef GL_COLOR_LOGIC_OP
#undef GL_COLOR_RENDERABLE
#undef GL_COLOR_WRITEMASK
#undef GL_COMMAND_BARRIER_BIT
#undef GL_COMPARE_REF_TO_TEXTURE
#undef GL_COMPATIBLE_SUBROUTINES
#undef GL_COMPILE_STATUS
#undef GL_COMPRESSED_R11_EAC
#undef GL_COMPRESSED_RED
#undef GL_COMPRESSED_RED_RGTC1
#undef GL_COMPRESSED_RG
#undef GL_COMPRESSED_RG11_EAC
#undef GL_COMPRESSED_RGB
#undef GL_COMPRESSED_RGB8_ETC2
#undef GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2
#undef GL_COMPRESSED_RGBA
#undef GL_COMPRESSED_RGBA8_ETC2_EAC
#undef GL_COMPRESSED_RGBA_BPTC_UNORM
#undef GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT
#undef GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT
#undef GL_COMPRESSED_RG_RGTC2
#undef GL_COMPRESSED_SIGNED_R11_EAC
#undef GL_COMPRESSED_SIGNED_RED_RGTC1
#undef GL_COMPRESSED_SIGNED_RG11_EAC
#undef GL_COMPRESSED_SIGNED_RG_RGTC2
#undef GL_COMPRESSED_SRGB
#undef GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
#undef GL_COMPRESSED_SRGB8_ETC2
#undef GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2
#undef GL_COMPRESSED_SRGB_ALPHA
#undef GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM
#undef GL_COMPRESSED_TEXTURE_FORMATS
#undef GL_COMPUTE_SHADER
#undef GL_COMPUTE_SHADER_BIT
#undef GL_COMPUTE_SHADER_INVOCATIONS
#undef GL_COMPUTE_SUBROUTINE
#undef GL_COMPUTE_SUBROUTINE_UNIFORM
#undef GL_COMPUTE_TEXTURE
#undef GL_COMPUTE_WORK_GROUP_SIZE
#undef GL_CONDITION_SATISFIED
#undef GL_CONSTANT_ALPHA
#undef GL_CONSTANT_COLOR
#undef GL_CONTEXT_COMPATIBILITY_PROFILE_BIT
#undef GL_CONTEXT_CORE_PROFILE_BIT
#undef GL_CONTEXT_FLAGS
#undef GL_CONTEXT_FLAG_DEBUG_BIT
#undef GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT
#undef GL_CONTEXT_FLAG_NO_ERROR_BIT
#undef GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT
#undef GL_CONTEXT_LOST
#undef GL_CONTEXT_PROFILE_MASK
#undef GL_CONTEXT_RELEASE_BEHAVIOR
#undef GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH
#undef GL_COPY
#undef GL_COPY_INVERTED
#undef GL_COPY_READ_BUFFER
#undef GL_COPY_READ_BUFFER_BINDING
#undef GL_COPY_WRITE_BUFFER
#undef GL_COPY_WRITE_BUFFER_BINDING
#undef GL_CULL_FACE
#undef GL_CULL_FACE_MODE
#undef GL_CURRENT_PROGRAM
#undef GL_CURRENT_QUERY
#undef GL_CURRENT_VERTEX_ATTRIB
#undef GL_CW
#undef GL_DEBUG_CALLBACK_FUNCTION
#undef GL_DEBUG_CALLBACK_USER_PARAM
#undef GL_DEBUG_GROUP_STACK_DEPTH
#undef GL_DEBUG_LOGGED_MESSAGES
#undef GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH
#undef GL_DEBUG_OUTPUT
#undef GL_DEBUG_OUTPUT_SYNCHRONOUS
#undef GL_DEBUG_SEVERITY_HIGH
#undef GL_DEBUG_SEVERITY_LOW
#undef GL_DEBUG_SEVERITY_MEDIUM
#undef GL_DEBUG_SEVERITY_NOTIFICATION
#undef GL_DEBUG_SOURCE_API
#undef GL_DEBUG_SOURCE_APPLICATION
#undef GL_DEBUG_SOURCE_OTHER
#undef GL_DEBUG_SOURCE_SHADER_COMPILER
#undef GL_DEBUG_SOURCE_THIRD_PARTY
#undef GL_DEBUG_SOURCE_WINDOW_SYSTEM
#undef GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR
#undef GL_DEBUG_TYPE_ERROR
#undef GL_DEBUG_TYPE_MARKER
#undef GL_DEBUG_TYPE_OTHER
#undef GL_DEBUG_TYPE_PERFORMANCE
#undef GL_DEBUG_TYPE_POP_GROUP
#undef GL_DEBUG_TYPE_PORTABILITY
#undef GL_DEBUG_TYPE_PUSH_GROUP
#undef GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR
#undef GL_DECR
#undef GL_DECR_WRAP
#undef GL_DELETE_STATUS
#undef GL_DEPTH
#undef GL_DEPTH24_STENCIL8
#undef GL_DEPTH32F_STENCIL8
#undef GL_DEPTH_ATTACHMENT
#undef GL_DEPTH_BUFFER_BIT
#undef GL_DEPTH_CLAMP
#undef GL_DEPTH_CLEAR_VALUE
#undef GL_DEPTH_COMPONENT
#undef GL_DEPTH_COMPONENT16
#undef GL_DEPTH_COMPONENT24
#undef GL_DEPTH_COMPONENT32
#undef GL_DEPTH_COMPONENT32F
#undef GL_DEPTH_COMPONENTS
#undef GL_DEPTH_FUNC
#undef GL_DEPTH_RANGE
#undef GL_DEPTH_RENDERABLE
#undef GL_DEPTH_STENCIL
#undef GL_DEPTH_STENCIL_ATTACHMENT
#undef GL_DEPTH_STENCIL_TEXTURE_MODE
#undef GL_DEPTH_TEST
#undef GL_DEPTH_WRITEMASK
#undef GL_DISPATCH_INDIRECT_BUFFER
#undef GL_DISPATCH_INDIRECT_BUFFER_BINDING
#undef GL_DITHER
#undef GL_DONT_CARE
#undef GL_DOUBLE
#undef GL_DOUBLEBUFFER
#undef GL_DOUBLE_MAT2
#undef GL_DOUBLE_MAT2x3
#undef GL_DOUBLE_MAT2x4
#undef GL_DOUBLE_MAT3
#undef GL_DOUBLE_MAT3x2
#undef GL_DOUBLE_MAT3x4
#undef GL_DOUBLE_MAT4
#undef GL_DOUBLE_MAT4x2
#undef GL_DOUBLE_MAT4x3
#undef GL_DOUBLE_VEC2
#undef GL_DOUBLE_VEC3
#undef GL_DOUBLE_VEC4
#undef GL_DRAW_BUFFER
#undef GL_DRAW_BUFFER0
#undef GL_DRAW_BUFFER1
#undef GL_DRAW_BUFFER10
#undef GL_DRAW_BUFFER11
#undef GL_DRAW_BUFFER12
#undef GL_DRAW_BUFFER13
#undef GL_DRAW_BUFFER14
#undef GL_DRAW_BUFFER15
#undef GL_DRAW_BUFFER2
#undef GL_DRAW_BUFFER3
#undef GL_DRAW_BUFFER4
#undef GL_DRAW_BUFFER5
#undef GL_DRAW_BUFFER6
#undef GL_DRAW_BUFFER7
#undef GL_DRAW_BUFFER8
#undef GL_DRAW_BUFFER9
#undef GL_DRAW_FRAMEBUFFER
#undef GL_DRAW_FRAMEBUFFER_BINDING
#undef GL_DRAW_INDIRECT_BUFFER
#undef GL_DRAW_INDIRECT_BUFFER_BINDING
#undef GL_DST_ALPHA
#undef GL_DST_COLOR
#undef GL_DYNAMIC_COPY
#undef GL_DYNAMIC_DRAW
#undef GL_DYNAMIC_READ
#undef GL_DYNAMIC_STORAGE_BIT
#undef GL_ELEMENT_ARRAY_BARRIER_BIT
#undef GL_ELEMENT_ARRAY_BUFFER
#undef GL_ELEMENT_ARRAY_BUFFER_BINDING
#undef GL_EQUAL
#undef GL_EQUIV
#undef GL_EXTENSIONS
#undef GL_FALSE
#undef GL_FASTEST
#undef GL_FILL
#undef GL_FILTER
#undef GL_FIRST_VERTEX_CONVENTION
#undef GL_FIXED
#undef GL_FIXED_ONLY
#undef GL_FLOAT
#undef GL_FLOAT_32_UNSIGNED_INT_24_8_REV
#undef GL_FLOAT_MAT2
#undef GL_FLOAT_MAT2x3
#undef GL_FLOAT_MAT2x4
#undef GL_FLOAT_MAT3
#undef GL_FLOAT_MAT3x2
#undef GL_FLOAT_MAT3x4
#undef GL_FLOAT_MAT4
#undef GL_FLOAT_MAT4x2
#undef GL_FLOAT_MAT4x3
#undef GL_FLOAT_VEC2
#undef GL_FLOAT_VEC3
#undef GL_FLOAT_VEC4
#undef GL_FRACTIONAL_EVEN
#undef GL_FRACTIONAL_ODD
#undef GL_FRAGMENT_INTERPOLATION_OFFSET_BITS
#undef GL_FRAGMENT_SHADER
#undef GL_FRAGMENT_SHADER_BIT
#undef GL_FRAGMENT_SHADER_DERIVATIVE_HINT
#undef GL_FRAGMENT_SHADER_INVOCATIONS
#undef GL_FRAGMENT_SUBROUTINE
#undef GL_FRAGMENT_SUBROUTINE_UNIFORM
#undef GL_FRAGMENT_TEXTURE
#undef GL_FRAMEBUFFER
#undef GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE
#undef GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE
#undef GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING
#undef GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE
#undef GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE
#undef GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE
#undef GL_FRAMEBUFFER_ATTACHMENT_LAYERED
#undef GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME
#undef GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
#undef GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE
#undef GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE
#undef GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE
#undef GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER
#undef GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL
#undef GL_FRAMEBUFFER_BARRIER_BIT
#undef GL_FRAMEBUFFER_BINDING
#undef GL_FRAMEBUFFER_BLEND
#undef GL_FRAMEBUFFER_COMPLETE
#undef GL_FRAMEBUFFER_DEFAULT
#undef GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS
#undef GL_FRAMEBUFFER_DEFAULT_HEIGHT
#undef GL_FRAMEBUFFER_DEFAULT_LAYERS
#undef GL_FRAMEBUFFER_DEFAULT_SAMPLES
#undef GL_FRAMEBUFFER_DEFAULT_WIDTH
#undef GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
#undef GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER
#undef GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS
#undef GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
#undef GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE
#undef GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER
#undef GL_FRAMEBUFFER_RENDERABLE
#undef GL_FRAMEBUFFER_RENDERABLE_LAYERED
#undef GL_FRAMEBUFFER_SRGB
#undef GL_FRAMEBUFFER_UNDEFINED
#undef GL_FRAMEBUFFER_UNSUPPORTED
#undef GL_FRONT
#undef GL_FRONT_AND_BACK
#undef GL_FRONT_FACE
#undef GL_FRONT_LEFT
#undef GL_FRONT_RIGHT
#undef GL_FULL_SUPPORT
#undef GL_FUNC_ADD
#undef GL_FUNC_REVERSE_SUBTRACT
#undef GL_FUNC_SUBTRACT
#undef GL_GEOMETRY_INPUT_TYPE
#undef GL_GEOMETRY_OUTPUT_TYPE
#undef GL_GEOMETRY_SHADER
#undef GL_GEOMETRY_SHADER_BIT
#undef GL_GEOMETRY_SHADER_INVOCATIONS
#undef GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED
#undef GL_GEOMETRY_SUBROUTINE
#undef GL_GEOMETRY_SUBROUTINE_UNIFORM
#undef GL_GEOMETRY_TEXTURE
#undef GL_GEOMETRY_VERTICES_OUT
#undef GL_GEQUAL
#undef GL_GET_TEXTURE_IMAGE_FORMAT
#undef GL_GET_TEXTURE_IMAGE_TYPE
#undef GL_GREATER
#undef GL_GREEN
#undef GL_GREEN_INTEGER
#undef GL_GUILTY_CONTEXT_RESET
#undef GL_HALF_FLOAT
#undef GL_HIGH_FLOAT
#undef GL_HIGH_INT
#undef GL_IMAGE_1D
#undef GL_IMAGE_1D_ARRAY
#undef GL_IMAGE_2D
#undef GL_IMAGE_2D_ARRAY
#undef GL_IMAGE_2D_MULTISAMPLE
#undef GL_IMAGE_2D_MULTISAMPLE_ARRAY
#undef GL_IMAGE_2D_RECT
#undef GL_IMAGE_3D
#undef GL_IMAGE_BINDING_ACCESS
#undef GL_IMAGE_BINDING_FORMAT
#undef GL_IMAGE_BINDING_LAYER
#undef GL_IMAGE_BINDING_LAYERED
#undef GL_IMAGE_BINDING_LEVEL
#undef GL_IMAGE_BINDING_NAME
#undef GL_IMAGE_BUFFER
#undef GL_IMAGE_CLASS_10_10_10_2
#undef GL_IMAGE_CLASS_11_11_10
#undef GL_IMAGE_CLASS_1_X_16
#undef GL_IMAGE_CLASS_1_X_32
#undef GL_IMAGE_CLASS_1_X_8
#undef GL_IMAGE_CLASS_2_X_16
#undef GL_IMAGE_CLASS_2_X_32
#undef GL_IMAGE_CLASS_2_X_8
#undef GL_IMAGE_CLASS_4_X_16
#undef GL_IMAGE_CLASS_4_X_32
#undef GL_IMAGE_CLASS_4_X_8
#undef GL_IMAGE_COMPATIBILITY_CLASS
#undef GL_IMAGE_CUBE
#undef GL_IMAGE_CUBE_MAP_ARRAY
#undef GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS
#undef GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE
#undef GL_IMAGE_FORMAT_COMPATIBILITY_TYPE
#undef GL_IMAGE_PIXEL_FORMAT
#undef GL_IMAGE_PIXEL_TYPE
#undef GL_IMAGE_TEXEL_SIZE
#undef GL_IMPLEMENTATION_COLOR_READ_FORMAT
#undef GL_IMPLEMENTATION_COLOR_READ_TYPE
#undef GL_INCR
#undef GL_INCR_WRAP
#undef GL_INFO_LOG_LENGTH
#undef GL_INNOCENT_CONTEXT_RESET
#undef GL_INT
#undef GL_INTERLEAVED_ATTRIBS
#undef GL_INTERNALFORMAT_ALPHA_SIZE
#undef GL_INTERNALFORMAT_ALPHA_TYPE
#undef GL_INTERNALFORMAT_BLUE_SIZE
#undef GL_INTERNALFORMAT_BLUE_TYPE
#undef GL_INTERNALFORMAT_DEPTH_SIZE
#undef GL_INTERNALFORMAT_DEPTH_TYPE
#undef GL_INTERNALFORMAT_GREEN_SIZE
#undef GL_INTERNALFORMAT_GREEN_TYPE
#undef GL_INTERNALFORMAT_PREFERRED
#undef GL_INTERNALFORMAT_RED_SIZE
#undef GL_INTERNALFORMAT_RED_TYPE
#undef GL_INTERNALFORMAT_SHARED_SIZE
#undef GL_INTERNALFORMAT_STENCIL_SIZE
#undef GL_INTERNALFORMAT_STENCIL_TYPE
#undef GL_INTERNALFORMAT_SUPPORTED
#undef GL_INT_2_10_10_10_REV
#undef GL_INT_IMAGE_1D
#undef GL_INT_IMAGE_1D_ARRAY
#undef GL_INT_IMAGE_2D
#undef GL_INT_IMAGE_2D_ARRAY
#undef GL_INT_IMAGE_2D_MULTISAMPLE
#undef GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY
#undef GL_INT_IMAGE_2D_RECT
#undef GL_INT_IMAGE_3D
#undef GL_INT_IMAGE_BUFFER
#undef GL_INT_IMAGE_CUBE
#undef GL_INT_IMAGE_CUBE_MAP_ARRAY
#undef GL_INT_SAMPLER_1D
#undef GL_INT_SAMPLER_1D_ARRAY
#undef GL_INT_SAMPLER_2D
#undef GL_INT_SAMPLER_2D_ARRAY
#undef GL_INT_SAMPLER_2D_MULTISAMPLE
#undef GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY
#undef GL_INT_SAMPLER_2D_RECT
#undef GL_INT_SAMPLER_3D
#undef GL_INT_SAMPLER_BUFFER
#undef GL_INT_SAMPLER_CUBE
#undef GL_INT_SAMPLER_CUBE_MAP_ARRAY
#undef GL_INT_VEC2
#undef GL_INT_VEC3
#undef GL_INT_VEC4
#undef GL_INVALID_ENUM
#undef GL_INVALID_FRAMEBUFFER_OPERATION
#undef GL_INVALID_INDEX
#undef GL_INVALID_OPERATION
#undef GL_INVALID_VALUE
#undef GL_INVERT
#undef GL_ISOLINES
#undef GL_IS_PER_PATCH
#undef GL_IS_ROW_MAJOR
#undef GL_KEEP
#undef GL_LAST_VERTEX_CONVENTION
#undef GL_LAYER_PROVOKING_VERTEX
#undef GL_LEFT
#undef GL_LEQUAL
#undef GL_LESS
#undef GL_LINE
#undef GL_LINEAR
#undef GL_LINEAR_MIPMAP_LINEAR
#undef GL_LINEAR_MIPMAP_NEAREST
#undef GL_LINES
#undef GL_LINES_ADJACENCY
#undef GL_LINE_LOOP
#undef GL_LINE_SMOOTH
#undef GL_LINE_SMOOTH_HINT
#undef GL_LINE_STRIP
#undef GL_LINE_STRIP_ADJACENCY
#undef GL_LINE_WIDTH
#undef GL_LINE_WIDTH_GRANULARITY
#undef GL_LINE_WIDTH_RANGE
#undef GL_LINK_STATUS
#undef GL_LOCATION
#undef GL_LOCATION_COMPONENT
#undef GL_LOCATION_INDEX
#undef GL_LOGIC_OP_MODE
#undef GL_LOSE_CONTEXT_ON_RESET
#undef GL_LOWER_LEFT
#undef GL_LOW_FLOAT
#undef GL_LOW_INT
#undef GL_MAJOR_VERSION
#undef GL_MANUAL_GENERATE_MIPMAP
#undef GL_MAP_COHERENT_BIT
#undef GL_MAP_FLUSH_EXPLICIT_BIT
#undef GL_MAP_INVALIDATE_BUFFER_BIT
#undef GL_MAP_INVALIDATE_RANGE_BIT
#undef GL_MAP_PERSISTENT_BIT
#undef GL_MAP_READ_BIT
#undef GL_MAP_UNSYNCHRONIZED_BIT
#undef GL_MAP_WRITE_BIT
#undef GL_MATRIX_STRIDE
#undef GL_MAX
#undef GL_MAX_3D_TEXTURE_SIZE
#undef GL_MAX_ARRAY_TEXTURE_LAYERS
#undef GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS
#undef GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE
#undef GL_MAX_CLIP_DISTANCES
#undef GL_MAX_COLOR_ATTACHMENTS
#undef GL_MAX_COLOR_TEXTURE_SAMPLES
#undef GL_MAX_COMBINED_ATOMIC_COUNTERS
#undef GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS
#undef GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES
#undef GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS
#undef GL_MAX_COMBINED_DIMENSIONS
#undef GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS
#undef GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS
#undef GL_MAX_COMBINED_IMAGE_UNIFORMS
#undef GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS
#undef GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES
#undef GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS
#undef GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS
#undef GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS
#undef GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
#undef GL_MAX_COMBINED_UNIFORM_BLOCKS
#undef GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS
#undef GL_MAX_COMPUTE_ATOMIC_COUNTERS
#undef GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS
#undef GL_MAX_COMPUTE_IMAGE_UNIFORMS
#undef GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS
#undef GL_MAX_COMPUTE_SHARED_MEMORY_SIZE
#undef GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS
#undef GL_MAX_COMPUTE_UNIFORM_BLOCKS
#undef GL_MAX_COMPUTE_UNIFORM_COMPONENTS
#undef GL_MAX_COMPUTE_WORK_GROUP_COUNT
#undef GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS
#undef GL_MAX_COMPUTE_WORK_GROUP_SIZE
#undef GL_MAX_CUBE_MAP_TEXTURE_SIZE
#undef GL_MAX_CULL_DISTANCES
#undef GL_MAX_DEBUG_GROUP_STACK_DEPTH
#undef GL_MAX_DEBUG_LOGGED_MESSAGES
#undef GL_MAX_DEBUG_MESSAGE_LENGTH
#undef GL_MAX_DEPTH
#undef GL_MAX_DEPTH_TEXTURE_SAMPLES
#undef GL_MAX_DRAW_BUFFERS
#undef GL_MAX_DUAL_SOURCE_DRAW_BUFFERS
#undef GL_MAX_ELEMENTS_INDICES
#undef GL_MAX_ELEMENTS_VERTICES
#undef GL_MAX_ELEMENT_INDEX
#undef GL_MAX_FRAGMENT_ATOMIC_COUNTERS
#undef GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS
#undef GL_MAX_FRAGMENT_IMAGE_UNIFORMS
#undef GL_MAX_FRAGMENT_INPUT_COMPONENTS
#undef GL_MAX_FRAGMENT_INTERPOLATION_OFFSET
#undef GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS
#undef GL_MAX_FRAGMENT_UNIFORM_BLOCKS
#undef GL_MAX_FRAGMENT_UNIFORM_COMPONENTS
#undef GL_MAX_FRAGMENT_UNIFORM_VECTORS
#undef GL_MAX_FRAMEBUFFER_HEIGHT
#undef GL_MAX_FRAMEBUFFER_LAYERS
#undef GL_MAX_FRAMEBUFFER_SAMPLES
#undef GL_MAX_FRAMEBUFFER_WIDTH
#undef GL_MAX_GEOMETRY_ATOMIC_COUNTERS
#undef GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS
#undef GL_MAX_GEOMETRY_IMAGE_UNIFORMS
#undef GL_MAX_GEOMETRY_INPUT_COMPONENTS
#undef GL_MAX_GEOMETRY_OUTPUT_COMPONENTS
#undef GL_MAX_GEOMETRY_OUTPUT_VERTICES
#undef GL_MAX_GEOMETRY_SHADER_INVOCATIONS
#undef GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS
#undef GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS
#undef GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS
#undef GL_MAX_GEOMETRY_UNIFORM_BLOCKS
#undef GL_MAX_GEOMETRY_UNIFORM_COMPONENTS
#undef GL_MAX_HEIGHT
#undef GL_MAX_IMAGE_SAMPLES
#undef GL_MAX_IMAGE_UNITS
#undef GL_MAX_INTEGER_SAMPLES
#undef GL_MAX_LABEL_LENGTH
#undef GL_MAX_LAYERS
#undef GL_MAX_NAME_LENGTH
#undef GL_MAX_NUM_ACTIVE_VARIABLES
#undef GL_MAX_NUM_COMPATIBLE_SUBROUTINES
#undef GL_MAX_PATCH_VERTICES
#undef GL_MAX_PROGRAM_TEXEL_OFFSET
#undef GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET
#undef GL_MAX_RECTANGLE_TEXTURE_SIZE
#undef GL_MAX_RENDERBUFFER_SIZE
#undef GL_MAX_SAMPLES
#undef GL_MAX_SAMPLE_MASK_WORDS
#undef GL_MAX_SERVER_WAIT_TIMEOUT
#undef GL_MAX_SHADER_STORAGE_BLOCK_SIZE
#undef GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS
#undef GL_MAX_SUBROUTINES
#undef GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS
#undef GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS
#undef GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS
#undef GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS
#undef GL_MAX_TESS_CONTROL_INPUT_COMPONENTS
#undef GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS
#undef GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS
#undef GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS
#undef GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS
#undef GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS
#undef GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS
#undef GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS
#undef GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS
#undef GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS
#undef GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS
#undef GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS
#undef GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS
#undef GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS
#undef GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS
#undef GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS
#undef GL_MAX_TESS_GEN_LEVEL
#undef GL_MAX_TESS_PATCH_COMPONENTS
#undef GL_MAX_TEXTURE_BUFFER_SIZE
#undef GL_MAX_TEXTURE_IMAGE_UNITS
#undef GL_MAX_TEXTURE_LOD_BIAS
#undef GL_MAX_TEXTURE_MAX_ANISOTROPY
#undef GL_MAX_TEXTURE_SIZE
#undef GL_MAX_TRANSFORM_FEEDBACK_BUFFERS
#undef GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS
#undef GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS
#undef GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
#undef GL_MAX_UNIFORM_BLOCK_SIZE
#undef GL_MAX_UNIFORM_BUFFER_BINDINGS
#undef GL_MAX_UNIFORM_LOCATIONS
#undef GL_MAX_VARYING_COMPONENTS
#undef GL_MAX_VARYING_FLOATS
#undef GL_MAX_VARYING_VECTORS
#undef GL_MAX_VERTEX_ATOMIC_COUNTERS
#undef GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS
#undef GL_MAX_VERTEX_ATTRIBS
#undef GL_MAX_VERTEX_ATTRIB_BINDINGS
#undef GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET
#undef GL_MAX_VERTEX_ATTRIB_STRIDE
#undef GL_MAX_VERTEX_IMAGE_UNIFORMS
#undef GL_MAX_VERTEX_OUTPUT_COMPONENTS
#undef GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS
#undef GL_MAX_VERTEX_STREAMS
#undef GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
#undef GL_MAX_VERTEX_UNIFORM_BLOCKS
#undef GL_MAX_VERTEX_UNIFORM_COMPONENTS
#undef GL_MAX_VERTEX_UNIFORM_VECTORS
#undef GL_MAX_VIEWPORTS
#undef GL_MAX_VIEWPORT_DIMS
#undef GL_MAX_WIDTH
#undef GL_MEDIUM_FLOAT
#undef GL_MEDIUM_INT
#undef GL_MIN
#undef GL_MINOR_VERSION
#undef GL_MIN_FRAGMENT_INTERPOLATION_OFFSET
#undef GL_MIN_MAP_BUFFER_ALIGNMENT
#undef GL_MIN_PROGRAM_TEXEL_OFFSET
#undef GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET
#undef GL_MIN_SAMPLE_SHADING_VALUE
#undef GL_MIPMAP
#undef GL_MIRRORED_REPEAT
#undef GL_MIRROR_CLAMP_TO_EDGE
#undef GL_MULTISAMPLE
#undef GL_NAME_LENGTH
#undef GL_NAND
#undef GL_NEAREST
#undef GL_NEAREST_MIPMAP_LINEAR
#undef GL_NEAREST_MIPMAP_NEAREST
#undef GL_NEGATIVE_ONE_TO_ONE
#undef GL_NEVER
#undef GL_NICEST
#undef GL_NONE
#undef GL_NOOP
#undef GL_NOR
#undef GL_NOTEQUAL
#undef GL_NO_ERROR
#undef GL_NO_RESET_NOTIFICATION
#undef GL_NUM_ACTIVE_VARIABLES
#undef GL_NUM_COMPATIBLE_SUBROUTINES
#undef GL_NUM_COMPRESSED_TEXTURE_FORMATS
#undef GL_NUM_EXTENSIONS
#undef GL_NUM_PROGRAM_BINARY_FORMATS
#undef GL_NUM_SAMPLE_COUNTS
#undef GL_NUM_SHADER_BINARY_FORMATS
#undef GL_NUM_SHADING_LANGUAGE_VERSIONS
#undef GL_NUM_SPIR_V_EXTENSIONS
#undef GL_OBJECT_TYPE
#undef GL_OFFSET
#undef GL_ONE
#undef GL_ONE_MINUS_CONSTANT_ALPHA
#undef GL_ONE_MINUS_CONSTANT_COLOR
#undef GL_ONE_MINUS_DST_ALPHA
#undef GL_ONE_MINUS_DST_COLOR
#undef GL_ONE_MINUS_SRC1_ALPHA
#undef GL_ONE_MINUS_SRC1_COLOR
#undef GL_ONE_MINUS_SRC_ALPHA
#undef GL_ONE_MINUS_SRC_COLOR
#undef GL_OR
#undef GL_OR_INVERTED
#undef GL_OR_REVERSE
#undef GL_OUT_OF_MEMORY
#undef GL_PACK_ALIGNMENT
#undef GL_PACK_COMPRESSED_BLOCK_DEPTH
#undef GL_PACK_COMPRESSED_BLOCK_HEIGHT
#undef GL_PACK_COMPRESSED_BLOCK_SIZE
#undef GL_PACK_COMPRESSED_BLOCK_WIDTH
#undef GL_PACK_IMAGE_HEIGHT
#undef GL_PACK_LSB_FIRST
#undef GL_PACK_ROW_LENGTH
#undef GL_PACK_SKIP_IMAGES
#undef GL_PACK_SKIP_PIXELS
#undef GL_PACK_SKIP_ROWS
#undef GL_PACK_SWAP_BYTES
#undef GL_PARAMETER_BUFFER
#undef GL_PARAMETER_BUFFER_BINDING
#undef GL_PATCHES
#undef GL_PATCH_DEFAULT_INNER_LEVEL
#undef GL_PATCH_DEFAULT_OUTER_LEVEL
#undef GL_PATCH_VERTICES
#undef GL_PIXEL_BUFFER_BARRIER_BIT
#undef GL_PIXEL_PACK_BUFFER
#undef GL_PIXEL_PACK_BUFFER_BINDING
#undef GL_PIXEL_UNPACK_BUFFER
#undef GL_PIXEL_UNPACK_BUFFER_BINDING
#undef GL_POINT
#undef GL_POINTS
#undef GL_POINT_FADE_THRESHOLD_SIZE
#undef GL_POINT_SIZE
#undef GL_POINT_SIZE_GRANULARITY
#undef GL_POINT_SIZE_RANGE
#undef GL_POINT_SPRITE_COORD_ORIGIN
#undef GL_POLYGON_MODE
#undef GL_POLYGON_OFFSET_CLAMP
#undef GL_POLYGON_OFFSET_FACTOR
#undef GL_POLYGON_OFFSET_FILL
#undef GL_POLYGON_OFFSET_LINE
#undef GL_POLYGON_OFFSET_POINT
#undef GL_POLYGON_OFFSET_UNITS
#undef GL_POLYGON_SMOOTH
#undef GL_POLYGON_SMOOTH_HINT
#undef GL_PRIMITIVES_GENERATED
#undef GL_PRIMITIVES_SUBMITTED
#undef GL_PRIMITIVE_RESTART
#undef GL_PRIMITIVE_RESTART_FIXED_INDEX
#undef GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED
#undef GL_PRIMITIVE_RESTART_INDEX
#undef GL_PROGRAM
#undef GL_PROGRAM_BINARY_FORMATS
#undef GL_PROGRAM_BINARY_LENGTH
#undef GL_PROGRAM_BINARY_RETRIEVABLE_HINT
#undef GL_PROGRAM_INPUT
#undef GL_PROGRAM_OUTPUT
#undef GL_PROGRAM_PIPELINE
#undef GL_PROGRAM_PIPELINE_BINDING
#undef GL_PROGRAM_POINT_SIZE
#undef GL_PROGRAM_SEPARABLE
#undef GL_PROVOKING_VERTEX
#undef GL_PROXY_TEXTURE_1D
#undef GL_PROXY_TEXTURE_1D_ARRAY
#undef GL_PROXY_TEXTURE_2D
#undef GL_PROXY_TEXTURE_2D_ARRAY
#undef GL_PROXY_TEXTURE_2D_MULTISAMPLE
#undef GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY
#undef GL_PROXY_TEXTURE_3D
#undef GL_PROXY_TEXTURE_CUBE_MAP
#undef GL_PROXY_TEXTURE_CUBE_MAP_ARRAY
#undef GL_PROXY_TEXTURE_RECTANGLE
#undef GL_QUADS
#undef GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION
#undef GL_QUERY
#undef GL_QUERY_BUFFER
#undef GL_QUERY_BUFFER_BARRIER_BIT
#undef GL_QUERY_BUFFER_BINDING
#undef GL_QUERY_BY_REGION_NO_WAIT
#undef GL_QUERY_BY_REGION_NO_WAIT_INVERTED
#undef GL_QUERY_BY_REGION_WAIT
#undef GL_QUERY_BY_REGION_WAIT_INVERTED
#undef GL_QUERY_COUNTER_BITS
#undef GL_QUERY_NO_WAIT
#undef GL_QUERY_NO_WAIT_INVERTED
#undef GL_QUERY_RESULT
#undef GL_QUERY_RESULT_AVAILABLE
#undef GL_QUERY_RESULT_NO_WAIT
#undef GL_QUERY_TARGET
#undef GL_QUERY_WAIT
#undef GL_QUERY_WAIT_INVERTED
#undef GL_R11F_G11F_B10F
#undef GL_R16
#undef GL_R16F
#undef GL_R16I
#undef GL_R16UI
#undef GL_R16_SNORM
#undef GL_R32F
#undef GL_R32I
#undef GL_R32UI
#undef GL_R3_G3_B2
#undef GL_R8
#undef GL_R8I
#undef GL_R8UI
#undef GL_R8_SNORM
#undef GL_RASTERIZER_DISCARD
#undef GL_READ_BUFFER
#undef GL_READ_FRAMEBUFFER
#undef GL_READ_FRAMEBUFFER_BINDING
#undef GL_READ_ONLY
#undef GL_READ_PIXELS
#undef GL_READ_PIXELS_FORMAT
#undef GL_READ_PIXELS_TYPE
#undef GL_READ_WRITE
#undef GL_RED
#undef GL_RED_INTEGER
#undef GL_REFERENCED_BY_COMPUTE_SHADER
#undef GL_REFERENCED_BY_FRAGMENT_SHADER
#undef GL_REFERENCED_BY_GEOMETRY_SHADER
#undef GL_REFERENCED_BY_TESS_CONTROL_SHADER
#undef GL_REFERENCED_BY_TESS_EVALUATION_SHADER
#undef GL_REFERENCED_BY_VERTEX_SHADER
#undef GL_RENDERBUFFER
#undef GL_RENDERBUFFER_ALPHA_SIZE
#undef GL_RENDERBUFFER_BINDING
#undef GL_RENDERBUFFER_BLUE_SIZE
#undef GL_RENDERBUFFER_DEPTH_SIZE
#undef GL_RENDERBUFFER_GREEN_SIZE
#undef GL_RENDERBUFFER_HEIGHT
#undef GL_RENDERBUFFER_INTERNAL_FORMAT
#undef GL_RENDERBUFFER_RED_SIZE
#undef GL_RENDERBUFFER_SAMPLES
#undef GL_RENDERBUFFER_STENCIL_SIZE
#undef GL_RENDERBUFFER_WIDTH
#undef GL_RENDERER
#undef GL_REPEAT
#undef GL_REPLACE
#undef GL_RESET_NOTIFICATION_STRATEGY
#undef GL_RG
#undef GL_RG16
#undef GL_RG16F
#undef GL_RG16I
#undef GL_RG16UI
#undef GL_RG16_SNORM
#undef GL_RG32F
#undef GL_RG32I
#undef GL_RG32UI
#undef GL_RG8
#undef GL_RG8I
#undef GL_RG8UI
#undef GL_RG8_SNORM
#undef GL_RGB
#undef GL_RGB10
#undef GL_RGB10_A2
#undef GL_RGB10_A2UI
#undef GL_RGB12
#undef GL_RGB16
#undef GL_RGB16F
#undef GL_RGB16I
#undef GL_RGB16UI
#undef GL_RGB16_SNORM
#undef GL_RGB32F
#undef GL_RGB32I
#undef GL_RGB32UI
#undef GL_RGB4
#undef GL_RGB5
#undef GL_RGB565
#undef GL_RGB5_A1
#undef GL_RGB8
#undef GL_RGB8I
#undef GL_RGB8UI
#undef GL_RGB8_SNORM
#undef GL_RGB9_E5
#undef GL_RGBA
#undef GL_RGBA12
#undef GL_RGBA16
#undef GL_RGBA16F
#undef GL_RGBA16I
#undef GL_RGBA16UI
#undef GL_RGBA16_SNORM
#undef GL_RGBA2
#undef GL_RGBA32F
#undef GL_RGBA32I
#undef GL_RGBA32UI
#undef GL_RGBA4
#undef GL_RGBA8
#undef GL_RGBA8I
#undef GL_RGBA8UI
#undef GL_RGBA8_SNORM
#undef GL_RGBA_INTEGER
#undef GL_RGB_INTEGER
#undef GL_RG_INTEGER
#undef GL_RIGHT
#undef GL_SAMPLER
#undef GL_SAMPLER_1D
#undef GL_SAMPLER_1D_ARRAY
#undef GL_SAMPLER_1D_ARRAY_SHADOW
#undef GL_SAMPLER_1D_SHADOW
#undef GL_SAMPLER_2D
#undef GL_SAMPLER_2D_ARRAY
#undef GL_SAMPLER_2D_ARRAY_SHADOW
#undef GL_SAMPLER_2D_MULTISAMPLE
#undef GL_SAMPLER_2D_MULTISAMPLE_ARRAY
#undef GL_SAMPLER_2D_RECT
#undef GL_SAMPLER_2D_RECT_SHADOW
#undef GL_SAMPLER_2D_SHADOW
#undef GL_SAMPLER_3D
#undef GL_SAMPLER_BINDING
#undef GL_SAMPLER_BUFFER
#undef GL_SAMPLER_CUBE
#undef GL_SAMPLER_CUBE_MAP_ARRAY
#undef GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW
#undef GL_SAMPLER_CUBE_SHADOW
#undef GL_SAMPLES
#undef GL_SAMPLES_PASSED
#undef GL_SAMPLE_ALPHA_TO_COVERAGE
#undef GL_SAMPLE_ALPHA_TO_ONE
#undef GL_SAMPLE_BUFFERS
#undef GL_SAMPLE_COVERAGE
#undef GL_SAMPLE_COVERAGE_INVERT
#undef GL_SAMPLE_COVERAGE_VALUE
#undef GL_SAMPLE_MASK
#undef GL_SAMPLE_MASK_VALUE
#undef GL_SAMPLE_POSITION
#undef GL_SAMPLE_SHADING
#undef GL_SCISSOR_BOX
#undef GL_SCISSOR_TEST
#undef GL_SEPARATE_ATTRIBS
#undef GL_SET
#undef GL_SHADER
#undef GL_SHADER_BINARY_FORMATS
#undef GL_SHADER_BINARY_FORMAT_SPIR_V
#undef GL_SHADER_COMPILER
#undef GL_SHADER_IMAGE_ACCESS_BARRIER_BIT
#undef GL_SHADER_IMAGE_ATOMIC
#undef GL_SHADER_IMAGE_LOAD
#undef GL_SHADER_IMAGE_STORE
#undef GL_SHADER_SOURCE_LENGTH
#undef GL_SHADER_STORAGE_BARRIER_BIT
#undef GL_SHADER_STORAGE_BLOCK
#undef GL_SHADER_STORAGE_BUFFER
#undef GL_SHADER_STORAGE_BUFFER_BINDING
#undef GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT
#undef GL_SHADER_STORAGE_BUFFER_SIZE
#undef GL_SHADER_STORAGE_BUFFER_START
#undef GL_SHADER_TYPE
#undef GL_SHADING_LANGUAGE_VERSION
#undef GL_SHORT
#undef GL_SIGNALED
#undef GL_SIGNED_NORMALIZED
#undef GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST
#undef GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE
#undef GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST
#undef GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE
#undef GL_SMOOTH_LINE_WIDTH_GRANULARITY
#undef GL_SMOOTH_LINE_WIDTH_RANGE
#undef GL_SMOOTH_POINT_SIZE_GRANULARITY
#undef GL_SMOOTH_POINT_SIZE_RANGE
#undef GL_SPIR_V_BINARY
#undef GL_SPIR_V_EXTENSIONS
#undef GL_SRC1_ALPHA
#undef GL_SRC1_COLOR
#undef GL_SRC_ALPHA
#undef GL_SRC_ALPHA_SATURATE
#undef GL_SRC_COLOR
#undef GL_SRGB
#undef GL_SRGB8
#undef GL_SRGB8_ALPHA8
#undef GL_SRGB_ALPHA
#undef GL_SRGB_READ
#undef GL_SRGB_WRITE
#undef GL_STACK_OVERFLOW
#undef GL_STACK_UNDERFLOW
#undef GL_STATIC_COPY
#undef GL_STATIC_DRAW
#undef GL_STATIC_READ
#undef GL_STENCIL
#undef GL_STENCIL_ATTACHMENT
#undef GL_STENCIL_BACK_FAIL
#undef GL_STENCIL_BACK_FUNC
#undef GL_STENCIL_BACK_PASS_DEPTH_FAIL
#undef GL_STENCIL_BACK_PASS_DEPTH_PASS
#undef GL_STENCIL_BACK_REF
#undef GL_STENCIL_BACK_VALUE_MASK
#undef GL_STENCIL_BACK_WRITEMASK
#undef GL_STENCIL_BUFFER_BIT
#undef GL_STENCIL_CLEAR_VALUE
#undef GL_STENCIL_COMPONENTS
#undef GL_STENCIL_FAIL
#undef GL_STENCIL_FUNC
#undef GL_STENCIL_INDEX
#undef GL_STENCIL_INDEX1
#undef GL_STENCIL_INDEX16
#undef GL_STENCIL_INDEX4
#undef GL_STENCIL_INDEX8
#undef GL_STENCIL_PASS_DEPTH_FAIL
#undef GL_STENCIL_PASS_DEPTH_PASS
#undef GL_STENCIL_REF
#undef GL_STENCIL_RENDERABLE
#undef GL_STENCIL_TEST
#undef GL_STENCIL_VALUE_MASK
#undef GL_STENCIL_WRITEMASK
#undef GL_STEREO
#undef GL_STREAM_COPY
#undef GL_STREAM_DRAW
#undef GL_STREAM_READ
#undef GL_SUBPIXEL_BITS
#undef GL_SYNC_CONDITION
#undef GL_SYNC_FENCE
#undef GL_SYNC_FLAGS
#undef GL_SYNC_FLUSH_COMMANDS_BIT
#undef GL_SYNC_GPU_COMMANDS_COMPLETE
#undef GL_SYNC_STATUS
#undef GL_TESS_CONTROL_OUTPUT_VERTICES
#undef GL_TESS_CONTROL_SHADER
#undef GL_TESS_CONTROL_SHADER_BIT
#undef GL_TESS_CONTROL_SHADER_PATCHES
#undef GL_TESS_CONTROL_SUBROUTINE
#undef GL_TESS_CONTROL_SUBROUTINE_UNIFORM
#undef GL_TESS_CONTROL_TEXTURE
#undef GL_TESS_EVALUATION_SHADER
#undef GL_TESS_EVALUATION_SHADER_BIT
#undef GL_TESS_EVALUATION_SHADER_INVOCATIONS
#undef GL_TESS_EVALUATION_SUBROUTINE
#undef GL_TESS_EVALUATION_SUBROUTINE_UNIFORM
#undef GL_TESS_EVALUATION_TEXTURE
#undef GL_TESS_GEN_MODE
#undef GL_TESS_GEN_POINT_MODE
#undef GL_TESS_GEN_SPACING
#undef GL_TESS_GEN_VERTEX_ORDER
#undef GL_TEXTURE
#undef GL_TEXTURE0
#undef GL_TEXTURE1
#undef GL_TEXTURE10
#undef GL_TEXTURE11
#undef GL_TEXTURE12
#undef GL_TEXTURE13
#undef GL_TEXTURE14
#undef GL_TEXTURE15
#undef GL_TEXTURE16
#undef GL_TEXTURE17
#undef GL_TEXTURE18
#undef GL_TEXTURE19
#undef GL_TEXTURE2
#undef GL_TEXTURE20
#undef GL_TEXTURE21
#undef GL_TEXTURE22
#undef GL_TEXTURE23
#undef GL_TEXTURE24
#undef GL_TEXTURE25
#undef GL_TEXTURE26
#undef GL_TEXTURE27
#undef GL_TEXTURE28
#undef GL_TEXTURE29
#undef GL_TEXTURE3
#undef GL_TEXTURE30
#undef GL_TEXTURE31
#undef GL_TEXTURE4
#undef GL_TEXTURE5
#undef GL_TEXTURE6
#undef GL_TEXTURE7
#undef GL_TEXTURE8
#undef GL_TEXTURE9
#undef GL_TEXTURE_1D
#undef GL_TEXTURE_1D_ARRAY
#undef GL_TEXTURE_2D
#undef GL_TEXTURE_2D_ARRAY
#undef GL_TEXTURE_2D_MULTISAMPLE
#undef GL_TEXTURE_2D_MULTISAMPLE_ARRAY
#undef GL_TEXTURE_3D
#undef GL_TEXTURE_ALPHA_SIZE
#undef GL_TEXTURE_ALPHA_TYPE
#undef GL_TEXTURE_BASE_LEVEL
#undef GL_TEXTURE_BINDING_1D
#undef GL_TEXTURE_BINDING_1D_ARRAY
#undef GL_TEXTURE_BINDING_2D
#undef GL_TEXTURE_BINDING_2D_ARRAY
#undef GL_TEXTURE_BINDING_2D_MULTISAMPLE
#undef GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY
#undef GL_TEXTURE_BINDING_3D
#undef GL_TEXTURE_BINDING_BUFFER
#undef GL_TEXTURE_BINDING_CUBE_MAP
#undef GL_TEXTURE_BINDING_CUBE_MAP_ARRAY
#undef GL_TEXTURE_BINDING_RECTANGLE
#undef GL_TEXTURE_BLUE_SIZE
#undef GL_TEXTURE_BLUE_TYPE
#undef GL_TEXTURE_BORDER_COLOR
#undef GL_TEXTURE_BUFFER
#undef GL_TEXTURE_BUFFER_BINDING
#undef GL_TEXTURE_BUFFER_DATA_STORE_BINDING
#undef GL_TEXTURE_BUFFER_OFFSET
#undef GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT
#undef GL_TEXTURE_BUFFER_SIZE
#undef GL_TEXTURE_COMPARE_FUNC
#undef GL_TEXTURE_COMPARE_MODE
#undef GL_TEXTURE_COMPRESSED
#undef GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT
#undef GL_TEXTURE_COMPRESSED_BLOCK_SIZE
#undef GL_TEXTURE_COMPRESSED_BLOCK_WIDTH
#undef GL_TEXTURE_COMPRESSED_IMAGE_SIZE
#undef GL_TEXTURE_COMPRESSION_HINT
#undef GL_TEXTURE_CUBE_MAP
#undef GL_TEXTURE_CUBE_MAP_ARRAY
#undef GL_TEXTURE_CUBE_MAP_NEGATIVE_X
#undef GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
#undef GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
#undef GL_TEXTURE_CUBE_MAP_POSITIVE_X
#undef GL_TEXTURE_CUBE_MAP_POSITIVE_Y
#undef GL_TEXTURE_CUBE_MAP_POSITIVE_Z
#undef GL_TEXTURE_CUBE_MAP_SEAMLESS
#undef GL_TEXTURE_DEPTH
#undef GL_TEXTURE_DEPTH_SIZE
#undef GL_TEXTURE_DEPTH_TYPE
#undef GL_TEXTURE_FETCH_BARRIER_BIT
#undef GL_TEXTURE_FIXED_SAMPLE_LOCATIONS
#undef GL_TEXTURE_GATHER
#undef GL_TEXTURE_GATHER_SHADOW
#undef GL_TEXTURE_GREEN_SIZE
#undef GL_TEXTURE_GREEN_TYPE
#undef GL_TEXTURE_HEIGHT
#undef GL_TEXTURE_IMAGE_FORMAT
#undef GL_TEXTURE_IMAGE_TYPE
#undef GL_TEXTURE_IMMUTABLE_FORMAT
#undef GL_TEXTURE_IMMUTABLE_LEVELS
#undef GL_TEXTURE_INTERNAL_FORMAT
#undef GL_TEXTURE_LOD_BIAS
#undef GL_TEXTURE_MAG_FILTER
#undef GL_TEXTURE_MAX_ANISOTROPY
#undef GL_TEXTURE_MAX_LEVEL
#undef GL_TEXTURE_MAX_LOD
#undef GL_TEXTURE_MIN_FILTER
#undef GL_TEXTURE_MIN_LOD
#undef GL_TEXTURE_RECTANGLE
#undef GL_TEXTURE_RED_SIZE
#undef GL_TEXTURE_RED_TYPE
#undef GL_TEXTURE_SAMPLES
#undef GL_TEXTURE_SHADOW
#undef GL_TEXTURE_SHARED_SIZE
#undef GL_TEXTURE_STENCIL_SIZE
#undef GL_TEXTURE_SWIZZLE_A
#undef GL_TEXTURE_SWIZZLE_B
#undef GL_TEXTURE_SWIZZLE_G
#undef GL_TEXTURE_SWIZZLE_R
#undef GL_TEXTURE_SWIZZLE_RGBA
#undef GL_TEXTURE_TARGET
#undef GL_TEXTURE_UPDATE_BARRIER_BIT
#undef GL_TEXTURE_VIEW
#undef GL_TEXTURE_VIEW_MIN_LAYER
#undef GL_TEXTURE_VIEW_MIN_LEVEL
#undef GL_TEXTURE_VIEW_NUM_LAYERS
#undef GL_TEXTURE_VIEW_NUM_LEVELS
#undef GL_TEXTURE_WIDTH
#undef GL_TEXTURE_WRAP_R
#undef GL_TEXTURE_WRAP_S
#undef GL_TEXTURE_WRAP_T
#undef GL_TIMEOUT_EXPIRED
#undef GL_TIMEOUT_IGNORED
#undef GL_TIMESTAMP
#undef GL_TIME_ELAPSED
#undef GL_TOP_LEVEL_ARRAY_SIZE
#undef GL_TOP_LEVEL_ARRAY_STRIDE
#undef GL_TRANSFORM_FEEDBACK
#undef GL_TRANSFORM_FEEDBACK_ACTIVE
#undef GL_TRANSFORM_FEEDBACK_BARRIER_BIT
#undef GL_TRANSFORM_FEEDBACK_BINDING
#undef GL_TRANSFORM_FEEDBACK_BUFFER
#undef GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE
#undef GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
#undef GL_TRANSFORM_FEEDBACK_BUFFER_INDEX
#undef GL_TRANSFORM_FEEDBACK_BUFFER_MODE
#undef GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED
#undef GL_TRANSFORM_FEEDBACK_BUFFER_SIZE
#undef GL_TRANSFORM_FEEDBACK_BUFFER_START
#undef GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE
#undef GL_TRANSFORM_FEEDBACK_OVERFLOW
#undef GL_TRANSFORM_FEEDBACK_PAUSED
#undef GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
#undef GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW
#undef GL_TRANSFORM_FEEDBACK_VARYING
#undef GL_TRANSFORM_FEEDBACK_VARYINGS
#undef GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH
#undef GL_TRIANGLES
#undef GL_TRIANGLES_ADJACENCY
#undef GL_TRIANGLE_FAN
#undef GL_TRIANGLE_STRIP
#undef GL_TRIANGLE_STRIP_ADJACENCY
#undef GL_TRUE
#undef GL_TYPE
#undef GL_UNDEFINED_VERTEX
#undef GL_UNIFORM
#undef GL_UNIFORM_ARRAY_STRIDE
#undef GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX
#undef GL_UNIFORM_BARRIER_BIT
#undef GL_UNIFORM_BLOCK
#undef GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS
#undef GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES
#undef GL_UNIFORM_BLOCK_BINDING
#undef GL_UNIFORM_BLOCK_DATA_SIZE
#undef GL_UNIFORM_BLOCK_INDEX
#undef GL_UNIFORM_BLOCK_NAME_LENGTH
#undef GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER
#undef GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER
#undef GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER
#undef GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER
#undef GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER
#undef GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER
#undef GL_UNIFORM_BUFFER
#undef GL_UNIFORM_BUFFER_BINDING
#undef GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT
#undef GL_UNIFORM_BUFFER_SIZE
#undef GL_UNIFORM_BUFFER_START
#undef GL_UNIFORM_IS_ROW_MAJOR
#undef GL_UNIFORM_MATRIX_STRIDE
#undef GL_UNIFORM_NAME_LENGTH
#undef GL_UNIFORM_OFFSET
#undef GL_UNIFORM_SIZE
#undef GL_UNIFORM_TYPE
#undef GL_UNKNOWN_CONTEXT_RESET
#undef GL_UNPACK_ALIGNMENT
#undef GL_UNPACK_COMPRESSED_BLOCK_DEPTH
#undef GL_UNPACK_COMPRESSED_BLOCK_HEIGHT
#undef GL_UNPACK_COMPRESSED_BLOCK_SIZE
#undef GL_UNPACK_COMPRESSED_BLOCK_WIDTH
#undef GL_UNPACK_IMAGE_HEIGHT
#undef GL_UNPACK_LSB_FIRST
#undef GL_UNPACK_ROW_LENGTH
#undef GL_UNPACK_SKIP_IMAGES
#undef GL_UNPACK_SKIP_PIXELS
#undef GL_UNPACK_SKIP_ROWS
#undef GL_UNPACK_SWAP_BYTES
#undef GL_UNSIGNALED
#undef GL_UNSIGNED_BYTE
#undef GL_UNSIGNED_BYTE_2_3_3_REV
#undef GL_UNSIGNED_BYTE_3_3_2
#undef GL_UNSIGNED_INT
#undef GL_UNSIGNED_INT_10F_11F_11F_REV
#undef GL_UNSIGNED_INT_10_10_10_2
#undef GL_UNSIGNED_INT_24_8
#undef GL_UNSIGNED_INT_2_10_10_10_REV
#undef GL_UNSIGNED_INT_5_9_9_9_REV
#undef GL_UNSIGNED_INT_8_8_8_8
#undef GL_UNSIGNED_INT_8_8_8_8_REV
#undef GL_UNSIGNED_INT_ATOMIC_COUNTER
#undef GL_UNSIGNED_INT_IMAGE_1D
#undef GL_UNSIGNED_INT_IMAGE_1D_ARRAY
#undef GL_UNSIGNED_INT_IMAGE_2D
#undef GL_UNSIGNED_INT_IMAGE_2D_ARRAY
#undef GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE
#undef GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY
#undef GL_UNSIGNED_INT_IMAGE_2D_RECT
#undef GL_UNSIGNED_INT_IMAGE_3D
#undef GL_UNSIGNED_INT_IMAGE_BUFFER
#undef GL_UNSIGNED_INT_IMAGE_CUBE
#undef GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY
#undef GL_UNSIGNED_INT_SAMPLER_1D
#undef GL_UNSIGNED_INT_SAMPLER_1D_ARRAY
#undef GL_UNSIGNED_INT_SAMPLER_2D
#undef GL_UNSIGNED_INT_SAMPLER_2D_ARRAY
#undef GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE
#undef GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY
#undef GL_UNSIGNED_INT_SAMPLER_2D_RECT
#undef GL_UNSIGNED_INT_SAMPLER_3D
#undef GL_UNSIGNED_INT_SAMPLER_BUFFER
#undef GL_UNSIGNED_INT_SAMPLER_CUBE
#undef GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY
#undef GL_UNSIGNED_INT_VEC2
#undef GL_UNSIGNED_INT_VEC3
#undef GL_UNSIGNED_INT_VEC4
#undef GL_UNSIGNED_NORMALIZED
#undef GL_UNSIGNED_SHORT
#undef GL_UNSIGNED_SHORT_1_5_5_5_REV
#undef GL_UNSIGNED_SHORT_4_4_4_4
#undef GL_UNSIGNED_SHORT_4_4_4_4_REV
#undef GL_UNSIGNED_SHORT_5_5_5_1
#undef GL_UNSIGNED_SHORT_5_6_5
#undef GL_UNSIGNED_SHORT_5_6_5_REV
#undef GL_UPPER_LEFT
#undef GL_VALIDATE_STATUS
#undef GL_VENDOR
#undef GL_VERSION
#undef GL_VERTEX_ARRAY
#undef GL_VERTEX_ARRAY_BINDING
#undef GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT
#undef GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
#undef GL_VERTEX_ATTRIB_ARRAY_DIVISOR
#undef GL_VERTEX_ATTRIB_ARRAY_ENABLED
#undef GL_VERTEX_ATTRIB_ARRAY_INTEGER
#undef GL_VERTEX_ATTRIB_ARRAY_LONG
#undef GL_VERTEX_ATTRIB_ARRAY_NORMALIZED
#undef GL_VERTEX_ATTRIB_ARRAY_POINTER
#undef GL_VERTEX_ATTRIB_ARRAY_SIZE
#undef GL_VERTEX_ATTRIB_ARRAY_STRIDE
#undef GL_VERTEX_ATTRIB_ARRAY_TYPE
#undef GL_VERTEX_ATTRIB_BINDING
#undef GL_VERTEX_ATTRIB_RELATIVE_OFFSET
#undef GL_VERTEX_BINDING_BUFFER
#undef GL_VERTEX_BINDING_DIVISOR
#undef GL_VERTEX_BINDING_OFFSET
#undef GL_VERTEX_BINDING_STRIDE
#undef GL_VERTEX_PROGRAM_POINT_SIZE
#undef GL_VERTEX_SHADER
#undef GL_VERTEX_SHADER_BIT
#undef GL_VERTEX_SHADER_INVOCATIONS
#undef GL_VERTEX_SUBROUTINE
#undef GL_VERTEX_SUBROUTINE_UNIFORM
#undef GL_VERTEX_TEXTURE
#undef GL_VERTICES_SUBMITTED
#undef GL_VIEWPORT
#undef GL_VIEWPORT_BOUNDS_RANGE
#undef GL_VIEWPORT_INDEX_PROVOKING_VERTEX
#undef GL_VIEWPORT_SUBPIXEL_BITS
#undef GL_VIEW_CLASS_128_BITS
#undef GL_VIEW_CLASS_16_BITS
#undef GL_VIEW_CLASS_24_BITS
#undef GL_VIEW_CLASS_32_BITS
#undef GL_VIEW_CLASS_48_BITS
#undef GL_VIEW_CLASS_64_BITS
#undef GL_VIEW_CLASS_8_BITS
#undef GL_VIEW_CLASS_96_BITS
#undef GL_VIEW_CLASS_BPTC_FLOAT
#undef GL_VIEW_CLASS_BPTC_UNORM
#undef GL_VIEW_CLASS_RGTC1_RED
#undef GL_VIEW_CLASS_RGTC2_RG
#undef GL_VIEW_CLASS_S3TC_DXT1_RGB
#undef GL_VIEW_CLASS_S3TC_DXT1_RGBA
#undef GL_VIEW_CLASS_S3TC_DXT3_RGBA
#undef GL_VIEW_CLASS_S3TC_DXT5_RGBA
#undef GL_VIEW_COMPATIBILITY_CLASS
#undef GL_WAIT_FAILED
#undef GL_WRITE_ONLY
#undef GL_XOR
#undef GL_ZERO
#undef GL_ZERO_TO_ONE
constexpr auto GL_ACTIVE_ATOMIC_COUNTER_BUFFERS{0x92D9};
constexpr auto GL_ACTIVE_ATTRIBUTES{0x8B89};
constexpr auto GL_ACTIVE_ATTRIBUTE_MAX_LENGTH{0x8B8A};
constexpr auto GL_ACTIVE_PROGRAM{0x8259};
constexpr auto GL_ACTIVE_RESOURCES{0x92F5};
constexpr auto GL_ACTIVE_SUBROUTINES{0x8DE5};
constexpr auto GL_ACTIVE_SUBROUTINE_MAX_LENGTH{0x8E48};
constexpr auto GL_ACTIVE_SUBROUTINE_UNIFORMS{0x8DE6};
constexpr auto GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS{0x8E47};
constexpr auto GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH{0x8E49};
constexpr auto GL_ACTIVE_TEXTURE{0x84E0};
constexpr auto GL_ACTIVE_UNIFORMS{0x8B86};
constexpr auto GL_ACTIVE_UNIFORM_BLOCKS{0x8A36};
constexpr auto GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH{0x8A35};
constexpr auto GL_ACTIVE_UNIFORM_MAX_LENGTH{0x8B87};
constexpr auto GL_ACTIVE_VARIABLES{0x9305};
constexpr auto GL_ALIASED_LINE_WIDTH_RANGE{0x846E};
constexpr auto GL_ALL_BARRIER_BITS{0xFFFFFFFF};
constexpr auto GL_ALL_SHADER_BITS{0xFFFFFFFF};
constexpr auto GL_ALPHA{0x1906};
constexpr auto GL_ALREADY_SIGNALED{0x911A};
constexpr auto GL_ALWAYS{0x0207};
constexpr auto GL_AND{0x1501};
constexpr auto GL_AND_INVERTED{0x1504};
constexpr auto GL_AND_REVERSE{0x1502};
constexpr auto GL_ANY_SAMPLES_PASSED{0x8C2F};
constexpr auto GL_ANY_SAMPLES_PASSED_CONSERVATIVE{0x8D6A};
constexpr auto GL_ARRAY_BUFFER{0x8892};
constexpr auto GL_ARRAY_BUFFER_BINDING{0x8894};
constexpr auto GL_ARRAY_SIZE{0x92FB};
constexpr auto GL_ARRAY_STRIDE{0x92FE};
constexpr auto GL_ATOMIC_COUNTER_BARRIER_BIT{0x00001000};
constexpr auto GL_ATOMIC_COUNTER_BUFFER{0x92C0};
constexpr auto GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS{0x92C5};
constexpr auto GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES{0x92C6};
constexpr auto GL_ATOMIC_COUNTER_BUFFER_BINDING{0x92C1};
constexpr auto GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE{0x92C4};
constexpr auto GL_ATOMIC_COUNTER_BUFFER_INDEX{0x9301};
constexpr auto GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER{0x90ED};
constexpr auto GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER{0x92CB};
constexpr auto GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER{0x92CA};
constexpr auto GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER{
    0x92C8};
constexpr auto GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER{
    0x92C9};
constexpr auto GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER{0x92C7};
constexpr auto GL_ATOMIC_COUNTER_BUFFER_SIZE{0x92C3};
constexpr auto GL_ATOMIC_COUNTER_BUFFER_START{0x92C2};
constexpr auto GL_ATTACHED_SHADERS{0x8B85};
constexpr auto GL_AUTO_GENERATE_MIPMAP{0x8295};
constexpr auto GL_BACK{0x0405};
constexpr auto GL_BACK_LEFT{0x0402};
constexpr auto GL_BACK_RIGHT{0x0403};
constexpr auto GL_BGR{0x80E0};
constexpr auto GL_BGRA{0x80E1};
constexpr auto GL_BGRA_INTEGER{0x8D9B};
constexpr auto GL_BGR_INTEGER{0x8D9A};
constexpr auto GL_BLEND{0x0BE2};
constexpr auto GL_BLEND_COLOR{0x8005};
constexpr auto GL_BLEND_DST{0x0BE0};
constexpr auto GL_BLEND_DST_ALPHA{0x80CA};
constexpr auto GL_BLEND_DST_RGB{0x80C8};
constexpr auto GL_BLEND_EQUATION{0x8009};
constexpr auto GL_BLEND_EQUATION_ALPHA{0x883D};
constexpr auto GL_BLEND_EQUATION_RGB{0x8009};
constexpr auto GL_BLEND_SRC{0x0BE1};
constexpr auto GL_BLEND_SRC_ALPHA{0x80CB};
constexpr auto GL_BLEND_SRC_RGB{0x80C9};
constexpr auto GL_BLOCK_INDEX{0x92FD};
constexpr auto GL_BLUE{0x1905};
constexpr auto GL_BLUE_INTEGER{0x8D96};
constexpr auto GL_BOOL{0x8B56};
constexpr auto GL_BOOL_VEC2{0x8B57};
constexpr auto GL_BOOL_VEC3{0x8B58};
constexpr auto GL_BOOL_VEC4{0x8B59};
constexpr auto GL_BUFFER{0x82E0};
constexpr auto GL_BUFFER_ACCESS{0x88BB};
constexpr auto GL_BUFFER_ACCESS_FLAGS{0x911F};
constexpr auto GL_BUFFER_BINDING{0x9302};
constexpr auto GL_BUFFER_DATA_SIZE{0x9303};
constexpr auto GL_BUFFER_IMMUTABLE_STORAGE{0x821F};
constexpr auto GL_BUFFER_MAPPED{0x88BC};
constexpr auto GL_BUFFER_MAP_LENGTH{0x9120};
constexpr auto GL_BUFFER_MAP_OFFSET{0x9121};
constexpr auto GL_BUFFER_MAP_POINTER{0x88BD};
constexpr auto GL_BUFFER_SIZE{0x8764};
constexpr auto GL_BUFFER_STORAGE_FLAGS{0x8220};
constexpr auto GL_BUFFER_UPDATE_BARRIER_BIT{0x00000200};
constexpr auto GL_BUFFER_USAGE{0x8765};
constexpr auto GL_BUFFER_VARIABLE{0x92E5};
constexpr auto GL_BYTE{0x1400};
constexpr auto GL_CAVEAT_SUPPORT{0x82B8};
constexpr auto GL_CCW{0x0901};
constexpr auto GL_CLAMP_READ_COLOR{0x891C};
constexpr auto GL_CLAMP_TO_BORDER{0x812D};
constexpr auto GL_CLAMP_TO_EDGE{0x812F};
constexpr auto GL_CLEAR{0x1500};
constexpr auto GL_CLEAR_BUFFER{0x82B4};
constexpr auto GL_CLEAR_TEXTURE{0x9365};
constexpr auto GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT{0x00004000};
constexpr auto GL_CLIENT_STORAGE_BIT{0x0200};
constexpr auto GL_CLIPPING_INPUT_PRIMITIVES{0x82F6};
constexpr auto GL_CLIPPING_OUTPUT_PRIMITIVES{0x82F7};
constexpr auto GL_CLIP_DEPTH_MODE{0x935D};
constexpr auto GL_CLIP_DISTANCE0{0x3000};
constexpr auto GL_CLIP_DISTANCE1{0x3001};
constexpr auto GL_CLIP_DISTANCE2{0x3002};
constexpr auto GL_CLIP_DISTANCE3{0x3003};
constexpr auto GL_CLIP_DISTANCE4{0x3004};
constexpr auto GL_CLIP_DISTANCE5{0x3005};
constexpr auto GL_CLIP_DISTANCE6{0x3006};
constexpr auto GL_CLIP_DISTANCE7{0x3007};
constexpr auto GL_CLIP_ORIGIN{0x935C};
constexpr auto GL_COLOR{0x1800};
constexpr auto GL_COLOR_ATTACHMENT0{0x8CE0};
constexpr auto GL_COLOR_ATTACHMENT1{0x8CE1};
constexpr auto GL_COLOR_ATTACHMENT10{0x8CEA};
constexpr auto GL_COLOR_ATTACHMENT11{0x8CEB};
constexpr auto GL_COLOR_ATTACHMENT12{0x8CEC};
constexpr auto GL_COLOR_ATTACHMENT13{0x8CED};
constexpr auto GL_COLOR_ATTACHMENT14{0x8CEE};
constexpr auto GL_COLOR_ATTACHMENT15{0x8CEF};
constexpr auto GL_COLOR_ATTACHMENT16{0x8CF0};
constexpr auto GL_COLOR_ATTACHMENT17{0x8CF1};
constexpr auto GL_COLOR_ATTACHMENT18{0x8CF2};
constexpr auto GL_COLOR_ATTACHMENT19{0x8CF3};
constexpr auto GL_COLOR_ATTACHMENT2{0x8CE2};
constexpr auto GL_COLOR_ATTACHMENT20{0x8CF4};
constexpr auto GL_COLOR_ATTACHMENT21{0x8CF5};
constexpr auto GL_COLOR_ATTACHMENT22{0x8CF6};
constexpr auto GL_COLOR_ATTACHMENT23{0x8CF7};
constexpr auto GL_COLOR_ATTACHMENT24{0x8CF8};
constexpr auto GL_COLOR_ATTACHMENT25{0x8CF9};
constexpr auto GL_COLOR_ATTACHMENT26{0x8CFA};
constexpr auto GL_COLOR_ATTACHMENT27{0x8CFB};
constexpr auto GL_COLOR_ATTACHMENT28{0x8CFC};
constexpr auto GL_COLOR_ATTACHMENT29{0x8CFD};
constexpr auto GL_COLOR_ATTACHMENT3{0x8CE3};
constexpr auto GL_COLOR_ATTACHMENT30{0x8CFE};
constexpr auto GL_COLOR_ATTACHMENT31{0x8CFF};
constexpr auto GL_COLOR_ATTACHMENT4{0x8CE4};
constexpr auto GL_COLOR_ATTACHMENT5{0x8CE5};
constexpr auto GL_COLOR_ATTACHMENT6{0x8CE6};
constexpr auto GL_COLOR_ATTACHMENT7{0x8CE7};
constexpr auto GL_COLOR_ATTACHMENT8{0x8CE8};
constexpr auto GL_COLOR_ATTACHMENT9{0x8CE9};
constexpr auto GL_COLOR_BUFFER_BIT{0x00004000};
constexpr auto GL_COLOR_CLEAR_VALUE{0x0C22};
constexpr auto GL_COLOR_COMPONENTS{0x8283};
constexpr auto GL_COLOR_ENCODING{0x8296};
constexpr auto GL_COLOR_LOGIC_OP{0x0BF2};
constexpr auto GL_COLOR_RENDERABLE{0x8286};
constexpr auto GL_COLOR_WRITEMASK{0x0C23};
constexpr auto GL_COMMAND_BARRIER_BIT{0x00000040};
constexpr auto GL_COMPARE_REF_TO_TEXTURE{0x884E};
constexpr auto GL_COMPATIBLE_SUBROUTINES{0x8E4B};
constexpr auto GL_COMPILE_STATUS{0x8B81};
constexpr auto GL_COMPRESSED_R11_EAC{0x9270};
constexpr auto GL_COMPRESSED_RED{0x8225};
constexpr auto GL_COMPRESSED_RED_RGTC1{0x8DBB};
constexpr auto GL_COMPRESSED_RG{0x8226};
constexpr auto GL_COMPRESSED_RG11_EAC{0x9272};
constexpr auto GL_COMPRESSED_RGB{0x84ED};
constexpr auto GL_COMPRESSED_RGB8_ETC2{0x9274};
constexpr auto GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2{0x9276};
constexpr auto GL_COMPRESSED_RGBA{0x84EE};
constexpr auto GL_COMPRESSED_RGBA8_ETC2_EAC{0x9278};
constexpr auto GL_COMPRESSED_RGBA_BPTC_UNORM{0x8E8C};
constexpr auto GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT{0x8E8E};
constexpr auto GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT{0x8E8F};
constexpr auto GL_COMPRESSED_RG_RGTC2{0x8DBD};
constexpr auto GL_COMPRESSED_SIGNED_R11_EAC{0x9271};
constexpr auto GL_COMPRESSED_SIGNED_RED_RGTC1{0x8DBC};
constexpr auto GL_COMPRESSED_SIGNED_RG11_EAC{0x9273};
constexpr auto GL_COMPRESSED_SIGNED_RG_RGTC2{0x8DBE};
constexpr auto GL_COMPRESSED_SRGB{0x8C48};
constexpr auto GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC{0x9279};
constexpr auto GL_COMPRESSED_SRGB8_ETC2{0x9275};
constexpr auto GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2{0x9277};
constexpr auto GL_COMPRESSED_SRGB_ALPHA{0x8C49};
constexpr auto GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM{0x8E8D};
constexpr auto GL_COMPRESSED_TEXTURE_FORMATS{0x86A3};
constexpr auto GL_COMPUTE_SHADER{0x91B9};
constexpr auto GL_COMPUTE_SHADER_BIT{0x00000020};
constexpr auto GL_COMPUTE_SHADER_INVOCATIONS{0x82F5};
constexpr auto GL_COMPUTE_SUBROUTINE{0x92ED};
constexpr auto GL_COMPUTE_SUBROUTINE_UNIFORM{0x92F3};
constexpr auto GL_COMPUTE_TEXTURE{0x82A0};
constexpr auto GL_COMPUTE_WORK_GROUP_SIZE{0x8267};
constexpr auto GL_CONDITION_SATISFIED{0x911C};
constexpr auto GL_CONSTANT_ALPHA{0x8003};
constexpr auto GL_CONSTANT_COLOR{0x8001};
constexpr auto GL_CONTEXT_COMPATIBILITY_PROFILE_BIT{0x00000002};
constexpr auto GL_CONTEXT_CORE_PROFILE_BIT{0x00000001};
constexpr auto GL_CONTEXT_FLAGS{0x821E};
constexpr auto GL_CONTEXT_FLAG_DEBUG_BIT{0x00000002};
constexpr auto GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT{0x00000001};
constexpr auto GL_CONTEXT_FLAG_NO_ERROR_BIT{0x00000008};
constexpr auto GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT{0x00000004};
constexpr auto GL_CONTEXT_LOST{0x0507};
constexpr auto GL_CONTEXT_PROFILE_MASK{0x9126};
constexpr auto GL_CONTEXT_RELEASE_BEHAVIOR{0x82FB};
constexpr auto GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH{0x82FC};
constexpr auto GL_COPY{0x1503};
constexpr auto GL_COPY_INVERTED{0x150C};
constexpr auto GL_COPY_READ_BUFFER{0x8F36};
constexpr auto GL_COPY_READ_BUFFER_BINDING{0x8F36};
constexpr auto GL_COPY_WRITE_BUFFER{0x8F37};
constexpr auto GL_COPY_WRITE_BUFFER_BINDING{0x8F37};
constexpr auto GL_CULL_FACE{0x0B44};
constexpr auto GL_CULL_FACE_MODE{0x0B45};
constexpr auto GL_CURRENT_PROGRAM{0x8B8D};
constexpr auto GL_CURRENT_QUERY{0x8865};
constexpr auto GL_CURRENT_VERTEX_ATTRIB{0x8626};
constexpr auto GL_CW{0x0900};
constexpr auto GL_DEBUG_CALLBACK_FUNCTION{0x8244};
constexpr auto GL_DEBUG_CALLBACK_USER_PARAM{0x8245};
constexpr auto GL_DEBUG_GROUP_STACK_DEPTH{0x826D};
constexpr auto GL_DEBUG_LOGGED_MESSAGES{0x9145};
constexpr auto GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH{0x8243};
constexpr auto GL_DEBUG_OUTPUT{0x92E0};
constexpr auto GL_DEBUG_OUTPUT_SYNCHRONOUS{0x8242};
constexpr auto GL_DEBUG_SEVERITY_HIGH{0x9146};
constexpr auto GL_DEBUG_SEVERITY_LOW{0x9148};
constexpr auto GL_DEBUG_SEVERITY_MEDIUM{0x9147};
constexpr auto GL_DEBUG_SEVERITY_NOTIFICATION{0x826B};
constexpr auto GL_DEBUG_SOURCE_API{0x8246};
constexpr auto GL_DEBUG_SOURCE_APPLICATION{0x824A};
constexpr auto GL_DEBUG_SOURCE_OTHER{0x824B};
constexpr auto GL_DEBUG_SOURCE_SHADER_COMPILER{0x8248};
constexpr auto GL_DEBUG_SOURCE_THIRD_PARTY{0x8249};
constexpr auto GL_DEBUG_SOURCE_WINDOW_SYSTEM{0x8247};
constexpr auto GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR{0x824D};
constexpr auto GL_DEBUG_TYPE_ERROR{0x824C};
constexpr auto GL_DEBUG_TYPE_MARKER{0x8268};
constexpr auto GL_DEBUG_TYPE_OTHER{0x8251};
constexpr auto GL_DEBUG_TYPE_PERFORMANCE{0x8250};
constexpr auto GL_DEBUG_TYPE_POP_GROUP{0x826A};
constexpr auto GL_DEBUG_TYPE_PORTABILITY{0x824F};
constexpr auto GL_DEBUG_TYPE_PUSH_GROUP{0x8269};
constexpr auto GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR{0x824E};
constexpr auto GL_DECR{0x1E03};
constexpr auto GL_DECR_WRAP{0x8508};
constexpr auto GL_DELETE_STATUS{0x8B80};
constexpr auto GL_DEPTH{0x1801};
constexpr auto GL_DEPTH24_STENCIL8{0x88F0};
constexpr auto GL_DEPTH32F_STENCIL8{0x8CAD};
constexpr auto GL_DEPTH_ATTACHMENT{0x8D00};
constexpr auto GL_DEPTH_BUFFER_BIT{0x00000100};
constexpr auto GL_DEPTH_CLAMP{0x864F};
constexpr auto GL_DEPTH_CLEAR_VALUE{0x0B73};
constexpr auto GL_DEPTH_COMPONENT{0x1902};
constexpr auto GL_DEPTH_COMPONENT16{0x81A5};
constexpr auto GL_DEPTH_COMPONENT24{0x81A6};
constexpr auto GL_DEPTH_COMPONENT32{0x81A7};
constexpr auto GL_DEPTH_COMPONENT32F{0x8CAC};
constexpr auto GL_DEPTH_COMPONENTS{0x8284};
constexpr auto GL_DEPTH_FUNC{0x0B74};
constexpr auto GL_DEPTH_RANGE{0x0B70};
constexpr auto GL_DEPTH_RENDERABLE{0x8287};
constexpr auto GL_DEPTH_STENCIL{0x84F9};
constexpr auto GL_DEPTH_STENCIL_ATTACHMENT{0x821A};
constexpr auto GL_DEPTH_STENCIL_TEXTURE_MODE{0x90EA};
constexpr auto GL_DEPTH_TEST{0x0B71};
constexpr auto GL_DEPTH_WRITEMASK{0x0B72};
constexpr auto GL_DISPATCH_INDIRECT_BUFFER{0x90EE};
constexpr auto GL_DISPATCH_INDIRECT_BUFFER_BINDING{0x90EF};
constexpr auto GL_DITHER{0x0BD0};
constexpr auto GL_DONT_CARE{0x1100};
constexpr auto GL_DOUBLE{0x140A};
constexpr auto GL_DOUBLEBUFFER{0x0C32};
constexpr auto GL_DOUBLE_MAT2{0x8F46};
constexpr auto GL_DOUBLE_MAT2x3{0x8F49};
constexpr auto GL_DOUBLE_MAT2x4{0x8F4A};
constexpr auto GL_DOUBLE_MAT3{0x8F47};
constexpr auto GL_DOUBLE_MAT3x2{0x8F4B};
constexpr auto GL_DOUBLE_MAT3x4{0x8F4C};
constexpr auto GL_DOUBLE_MAT4{0x8F48};
constexpr auto GL_DOUBLE_MAT4x2{0x8F4D};
constexpr auto GL_DOUBLE_MAT4x3{0x8F4E};
constexpr auto GL_DOUBLE_VEC2{0x8FFC};
constexpr auto GL_DOUBLE_VEC3{0x8FFD};
constexpr auto GL_DOUBLE_VEC4{0x8FFE};
constexpr auto GL_DRAW_BUFFER{0x0C01};
constexpr auto GL_DRAW_BUFFER0{0x8825};
constexpr auto GL_DRAW_BUFFER1{0x8826};
constexpr auto GL_DRAW_BUFFER10{0x882F};
constexpr auto GL_DRAW_BUFFER11{0x8830};
constexpr auto GL_DRAW_BUFFER12{0x8831};
constexpr auto GL_DRAW_BUFFER13{0x8832};
constexpr auto GL_DRAW_BUFFER14{0x8833};
constexpr auto GL_DRAW_BUFFER15{0x8834};
constexpr auto GL_DRAW_BUFFER2{0x8827};
constexpr auto GL_DRAW_BUFFER3{0x8828};
constexpr auto GL_DRAW_BUFFER4{0x8829};
constexpr auto GL_DRAW_BUFFER5{0x882A};
constexpr auto GL_DRAW_BUFFER6{0x882B};
constexpr auto GL_DRAW_BUFFER7{0x882C};
constexpr auto GL_DRAW_BUFFER8{0x882D};
constexpr auto GL_DRAW_BUFFER9{0x882E};
constexpr auto GL_DRAW_FRAMEBUFFER{0x8CA9};
constexpr auto GL_DRAW_FRAMEBUFFER_BINDING{0x8CA6};
constexpr auto GL_DRAW_INDIRECT_BUFFER{0x8F3F};
constexpr auto GL_DRAW_INDIRECT_BUFFER_BINDING{0x8F43};
constexpr auto GL_DST_ALPHA{0x0304};
constexpr auto GL_DST_COLOR{0x0306};
constexpr auto GL_DYNAMIC_COPY{0x88EA};
constexpr auto GL_DYNAMIC_DRAW{0x88E8};
constexpr auto GL_DYNAMIC_READ{0x88E9};
constexpr auto GL_DYNAMIC_STORAGE_BIT{0x0100};
constexpr auto GL_ELEMENT_ARRAY_BARRIER_BIT{0x00000002};
constexpr auto GL_ELEMENT_ARRAY_BUFFER{0x8893};
constexpr auto GL_ELEMENT_ARRAY_BUFFER_BINDING{0x8895};
constexpr auto GL_EQUAL{0x0202};
constexpr auto GL_EQUIV{0x1509};
constexpr auto GL_EXTENSIONS{0x1F03};
constexpr auto GL_FALSE{0};
constexpr auto GL_FASTEST{0x1101};
constexpr auto GL_FILL{0x1B02};
constexpr auto GL_FILTER{0x829A};
constexpr auto GL_FIRST_VERTEX_CONVENTION{0x8E4D};
constexpr auto GL_FIXED{0x140C};
constexpr auto GL_FIXED_ONLY{0x891D};
constexpr auto GL_FLOAT{0x1406};
constexpr auto GL_FLOAT_32_UNSIGNED_INT_24_8_REV{0x8DAD};
constexpr auto GL_FLOAT_MAT2{0x8B5A};
constexpr auto GL_FLOAT_MAT2x3{0x8B65};
constexpr auto GL_FLOAT_MAT2x4{0x8B66};
constexpr auto GL_FLOAT_MAT3{0x8B5B};
constexpr auto GL_FLOAT_MAT3x2{0x8B67};
constexpr auto GL_FLOAT_MAT3x4{0x8B68};
constexpr auto GL_FLOAT_MAT4{0x8B5C};
constexpr auto GL_FLOAT_MAT4x2{0x8B69};
constexpr auto GL_FLOAT_MAT4x3{0x8B6A};
constexpr auto GL_FLOAT_VEC2{0x8B50};
constexpr auto GL_FLOAT_VEC3{0x8B51};
constexpr auto GL_FLOAT_VEC4{0x8B52};
constexpr auto GL_FRACTIONAL_EVEN{0x8E7C};
constexpr auto GL_FRACTIONAL_ODD{0x8E7B};
constexpr auto GL_FRAGMENT_INTERPOLATION_OFFSET_BITS{0x8E5D};
constexpr auto GL_FRAGMENT_SHADER{0x8B30};
constexpr auto GL_FRAGMENT_SHADER_BIT{0x00000002};
constexpr auto GL_FRAGMENT_SHADER_DERIVATIVE_HINT{0x8B8B};
constexpr auto GL_FRAGMENT_SHADER_INVOCATIONS{0x82F4};
constexpr auto GL_FRAGMENT_SUBROUTINE{0x92EC};
constexpr auto GL_FRAGMENT_SUBROUTINE_UNIFORM{0x92F2};
constexpr auto GL_FRAGMENT_TEXTURE{0x829F};
constexpr auto GL_FRAMEBUFFER{0x8D40};
constexpr auto GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE{0x8215};
constexpr auto GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE{0x8214};
constexpr auto GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING{0x8210};
constexpr auto GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE{0x8211};
constexpr auto GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE{0x8216};
constexpr auto GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE{0x8213};
constexpr auto GL_FRAMEBUFFER_ATTACHMENT_LAYERED{0x8DA7};
constexpr auto GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME{0x8CD1};
constexpr auto GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE{0x8CD0};
constexpr auto GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE{0x8212};
constexpr auto GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE{0x8217};
constexpr auto GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE{0x8CD3};
constexpr auto GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER{0x8CD4};
constexpr auto GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL{0x8CD2};
constexpr auto GL_FRAMEBUFFER_BARRIER_BIT{0x00000400};
constexpr auto GL_FRAMEBUFFER_BINDING{0x8CA6};
constexpr auto GL_FRAMEBUFFER_BLEND{0x828B};
constexpr auto GL_FRAMEBUFFER_COMPLETE{0x8CD5};
constexpr auto GL_FRAMEBUFFER_DEFAULT{0x8218};
constexpr auto GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS{0x9314};
constexpr auto GL_FRAMEBUFFER_DEFAULT_HEIGHT{0x9311};
constexpr auto GL_FRAMEBUFFER_DEFAULT_LAYERS{0x9312};
constexpr auto GL_FRAMEBUFFER_DEFAULT_SAMPLES{0x9313};
constexpr auto GL_FRAMEBUFFER_DEFAULT_WIDTH{0x9310};
constexpr auto GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT{0x8CD6};
constexpr auto GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER{0x8CDB};
constexpr auto GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS{0x8DA8};
constexpr auto GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT{0x8CD7};
constexpr auto GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE{0x8D56};
constexpr auto GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER{0x8CDC};
constexpr auto GL_FRAMEBUFFER_RENDERABLE{0x8289};
constexpr auto GL_FRAMEBUFFER_RENDERABLE_LAYERED{0x828A};
constexpr auto GL_FRAMEBUFFER_SRGB{0x8DB9};
constexpr auto GL_FRAMEBUFFER_UNDEFINED{0x8219};
constexpr auto GL_FRAMEBUFFER_UNSUPPORTED{0x8CDD};
constexpr auto GL_FRONT{0x0404};
constexpr auto GL_FRONT_AND_BACK{0x0408};
constexpr auto GL_FRONT_FACE{0x0B46};
constexpr auto GL_FRONT_LEFT{0x0400};
constexpr auto GL_FRONT_RIGHT{0x0401};
constexpr auto GL_FULL_SUPPORT{0x82B7};
constexpr auto GL_FUNC_ADD{0x8006};
constexpr auto GL_FUNC_REVERSE_SUBTRACT{0x800B};
constexpr auto GL_FUNC_SUBTRACT{0x800A};
constexpr auto GL_GEOMETRY_INPUT_TYPE{0x8917};
constexpr auto GL_GEOMETRY_OUTPUT_TYPE{0x8918};
constexpr auto GL_GEOMETRY_SHADER{0x8DD9};
constexpr auto GL_GEOMETRY_SHADER_BIT{0x00000004};
constexpr auto GL_GEOMETRY_SHADER_INVOCATIONS{0x887F};
constexpr auto GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED{0x82F3};
constexpr auto GL_GEOMETRY_SUBROUTINE{0x92EB};
constexpr auto GL_GEOMETRY_SUBROUTINE_UNIFORM{0x92F1};
constexpr auto GL_GEOMETRY_TEXTURE{0x829E};
constexpr auto GL_GEOMETRY_VERTICES_OUT{0x8916};
constexpr auto GL_GEQUAL{0x0206};
constexpr auto GL_GET_TEXTURE_IMAGE_FORMAT{0x8291};
constexpr auto GL_GET_TEXTURE_IMAGE_TYPE{0x8292};
constexpr auto GL_GREATER{0x0204};
constexpr auto GL_GREEN{0x1904};
constexpr auto GL_GREEN_INTEGER{0x8D95};
constexpr auto GL_GUILTY_CONTEXT_RESET{0x8253};
constexpr auto GL_HALF_FLOAT{0x140B};
constexpr auto GL_HIGH_FLOAT{0x8DF2};
constexpr auto GL_HIGH_INT{0x8DF5};
constexpr auto GL_IMAGE_1D{0x904C};
constexpr auto GL_IMAGE_1D_ARRAY{0x9052};
constexpr auto GL_IMAGE_2D{0x904D};
constexpr auto GL_IMAGE_2D_ARRAY{0x9053};
constexpr auto GL_IMAGE_2D_MULTISAMPLE{0x9055};
constexpr auto GL_IMAGE_2D_MULTISAMPLE_ARRAY{0x9056};
constexpr auto GL_IMAGE_2D_RECT{0x904F};
constexpr auto GL_IMAGE_3D{0x904E};
constexpr auto GL_IMAGE_BINDING_ACCESS{0x8F3E};
constexpr auto GL_IMAGE_BINDING_FORMAT{0x906E};
constexpr auto GL_IMAGE_BINDING_LAYER{0x8F3D};
constexpr auto GL_IMAGE_BINDING_LAYERED{0x8F3C};
constexpr auto GL_IMAGE_BINDING_LEVEL{0x8F3B};
constexpr auto GL_IMAGE_BINDING_NAME{0x8F3A};
constexpr auto GL_IMAGE_BUFFER{0x9051};
constexpr auto GL_IMAGE_CLASS_10_10_10_2{0x82C3};
constexpr auto GL_IMAGE_CLASS_11_11_10{0x82C2};
constexpr auto GL_IMAGE_CLASS_1_X_16{0x82BE};
constexpr auto GL_IMAGE_CLASS_1_X_32{0x82BB};
constexpr auto GL_IMAGE_CLASS_1_X_8{0x82C1};
constexpr auto GL_IMAGE_CLASS_2_X_16{0x82BD};
constexpr auto GL_IMAGE_CLASS_2_X_32{0x82BA};
constexpr auto GL_IMAGE_CLASS_2_X_8{0x82C0};
constexpr auto GL_IMAGE_CLASS_4_X_16{0x82BC};
constexpr auto GL_IMAGE_CLASS_4_X_32{0x82B9};
constexpr auto GL_IMAGE_CLASS_4_X_8{0x82BF};
constexpr auto GL_IMAGE_COMPATIBILITY_CLASS{0x82A8};
constexpr auto GL_IMAGE_CUBE{0x9050};
constexpr auto GL_IMAGE_CUBE_MAP_ARRAY{0x9054};
constexpr auto GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS{0x90C9};
constexpr auto GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE{0x90C8};
constexpr auto GL_IMAGE_FORMAT_COMPATIBILITY_TYPE{0x90C7};
constexpr auto GL_IMAGE_PIXEL_FORMAT{0x82A9};
constexpr auto GL_IMAGE_PIXEL_TYPE{0x82AA};
constexpr auto GL_IMAGE_TEXEL_SIZE{0x82A7};
constexpr auto GL_IMPLEMENTATION_COLOR_READ_FORMAT{0x8B9B};
constexpr auto GL_IMPLEMENTATION_COLOR_READ_TYPE{0x8B9A};
constexpr auto GL_INCR{0x1E02};
constexpr auto GL_INCR_WRAP{0x8507};
constexpr auto GL_INFO_LOG_LENGTH{0x8B84};
constexpr auto GL_INNOCENT_CONTEXT_RESET{0x8254};
constexpr auto GL_INT{0x1404};
constexpr auto GL_INTERLEAVED_ATTRIBS{0x8C8C};
constexpr auto GL_INTERNALFORMAT_ALPHA_SIZE{0x8274};
constexpr auto GL_INTERNALFORMAT_ALPHA_TYPE{0x827B};
constexpr auto GL_INTERNALFORMAT_BLUE_SIZE{0x8273};
constexpr auto GL_INTERNALFORMAT_BLUE_TYPE{0x827A};
constexpr auto GL_INTERNALFORMAT_DEPTH_SIZE{0x8275};
constexpr auto GL_INTERNALFORMAT_DEPTH_TYPE{0x827C};
constexpr auto GL_INTERNALFORMAT_GREEN_SIZE{0x8272};
constexpr auto GL_INTERNALFORMAT_GREEN_TYPE{0x8279};
constexpr auto GL_INTERNALFORMAT_PREFERRED{0x8270};
constexpr auto GL_INTERNALFORMAT_RED_SIZE{0x8271};
constexpr auto GL_INTERNALFORMAT_RED_TYPE{0x8278};
constexpr auto GL_INTERNALFORMAT_SHARED_SIZE{0x8277};
constexpr auto GL_INTERNALFORMAT_STENCIL_SIZE{0x8276};
constexpr auto GL_INTERNALFORMAT_STENCIL_TYPE{0x827D};
constexpr auto GL_INTERNALFORMAT_SUPPORTED{0x826F};
constexpr auto GL_INT_2_10_10_10_REV{0x8D9F};
constexpr auto GL_INT_IMAGE_1D{0x9057};
constexpr auto GL_INT_IMAGE_1D_ARRAY{0x905D};
constexpr auto GL_INT_IMAGE_2D{0x9058};
constexpr auto GL_INT_IMAGE_2D_ARRAY{0x905E};
constexpr auto GL_INT_IMAGE_2D_MULTISAMPLE{0x9060};
constexpr auto GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY{0x9061};
constexpr auto GL_INT_IMAGE_2D_RECT{0x905A};
constexpr auto GL_INT_IMAGE_3D{0x9059};
constexpr auto GL_INT_IMAGE_BUFFER{0x905C};
constexpr auto GL_INT_IMAGE_CUBE{0x905B};
constexpr auto GL_INT_IMAGE_CUBE_MAP_ARRAY{0x905F};
constexpr auto GL_INT_SAMPLER_1D{0x8DC9};
constexpr auto GL_INT_SAMPLER_1D_ARRAY{0x8DCE};
constexpr auto GL_INT_SAMPLER_2D{0x8DCA};
constexpr auto GL_INT_SAMPLER_2D_ARRAY{0x8DCF};
constexpr auto GL_INT_SAMPLER_2D_MULTISAMPLE{0x9109};
constexpr auto GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY{0x910C};
constexpr auto GL_INT_SAMPLER_2D_RECT{0x8DCD};
constexpr auto GL_INT_SAMPLER_3D{0x8DCB};
constexpr auto GL_INT_SAMPLER_BUFFER{0x8DD0};
constexpr auto GL_INT_SAMPLER_CUBE{0x8DCC};
constexpr auto GL_INT_SAMPLER_CUBE_MAP_ARRAY{0x900E};
constexpr auto GL_INT_VEC2{0x8B53};
constexpr auto GL_INT_VEC3{0x8B54};
constexpr auto GL_INT_VEC4{0x8B55};
constexpr auto GL_INVALID_ENUM{0x0500};
constexpr auto GL_INVALID_FRAMEBUFFER_OPERATION{0x0506};
constexpr auto GL_INVALID_INDEX{0xFFFFFFFF};
constexpr auto GL_INVALID_OPERATION{0x0502};
constexpr auto GL_INVALID_VALUE{0x0501};
constexpr auto GL_INVERT{0x150A};
constexpr auto GL_ISOLINES{0x8E7A};
constexpr auto GL_IS_PER_PATCH{0x92E7};
constexpr auto GL_IS_ROW_MAJOR{0x9300};
constexpr auto GL_KEEP{0x1E00};
constexpr auto GL_LAST_VERTEX_CONVENTION{0x8E4E};
constexpr auto GL_LAYER_PROVOKING_VERTEX{0x825E};
constexpr auto GL_LEFT{0x0406};
constexpr auto GL_LEQUAL{0x0203};
constexpr auto GL_LESS{0x0201};
constexpr auto GL_LINE{0x1B01};
constexpr auto GL_LINEAR{0x2601};
constexpr auto GL_LINEAR_MIPMAP_LINEAR{0x2703};
constexpr auto GL_LINEAR_MIPMAP_NEAREST{0x2701};
constexpr auto GL_LINES{0x0001};
constexpr auto GL_LINES_ADJACENCY{0x000A};
constexpr auto GL_LINE_LOOP{0x0002};
constexpr auto GL_LINE_SMOOTH{0x0B20};
constexpr auto GL_LINE_SMOOTH_HINT{0x0C52};
constexpr auto GL_LINE_STRIP{0x0003};
constexpr auto GL_LINE_STRIP_ADJACENCY{0x000B};
constexpr auto GL_LINE_WIDTH{0x0B21};
constexpr auto GL_LINE_WIDTH_GRANULARITY{0x0B23};
constexpr auto GL_LINE_WIDTH_RANGE{0x0B22};
constexpr auto GL_LINK_STATUS{0x8B82};
constexpr auto GL_LOCATION{0x930E};
constexpr auto GL_LOCATION_COMPONENT{0x934A};
constexpr auto GL_LOCATION_INDEX{0x930F};
constexpr auto GL_LOGIC_OP_MODE{0x0BF0};
constexpr auto GL_LOSE_CONTEXT_ON_RESET{0x8252};
constexpr auto GL_LOWER_LEFT{0x8CA1};
constexpr auto GL_LOW_FLOAT{0x8DF0};
constexpr auto GL_LOW_INT{0x8DF3};
constexpr auto GL_MAJOR_VERSION{0x821B};
constexpr auto GL_MANUAL_GENERATE_MIPMAP{0x8294};
constexpr auto GL_MAP_COHERENT_BIT{0x0080};
constexpr auto GL_MAP_FLUSH_EXPLICIT_BIT{0x0010};
constexpr auto GL_MAP_INVALIDATE_BUFFER_BIT{0x0008};
constexpr auto GL_MAP_INVALIDATE_RANGE_BIT{0x0004};
constexpr auto GL_MAP_PERSISTENT_BIT{0x0040};
constexpr auto GL_MAP_READ_BIT{0x0001};
constexpr auto GL_MAP_UNSYNCHRONIZED_BIT{0x0020};
constexpr auto GL_MAP_WRITE_BIT{0x0002};
constexpr auto GL_MATRIX_STRIDE{0x92FF};
constexpr auto GL_MAX{0x8008};
constexpr auto GL_MAX_3D_TEXTURE_SIZE{0x8073};
constexpr auto GL_MAX_ARRAY_TEXTURE_LAYERS{0x88FF};
constexpr auto GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS{0x92DC};
constexpr auto GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE{0x92D8};
constexpr auto GL_MAX_CLIP_DISTANCES{0x0D32};
constexpr auto GL_MAX_COLOR_ATTACHMENTS{0x8CDF};
constexpr auto GL_MAX_COLOR_TEXTURE_SAMPLES{0x910E};
constexpr auto GL_MAX_COMBINED_ATOMIC_COUNTERS{0x92D7};
constexpr auto GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS{0x92D1};
constexpr auto GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES{0x82FA};
constexpr auto GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS{0x8266};
constexpr auto GL_MAX_COMBINED_DIMENSIONS{0x8282};
constexpr auto GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS{0x8A33};
constexpr auto GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS{0x8A32};
constexpr auto GL_MAX_COMBINED_IMAGE_UNIFORMS{0x90CF};
constexpr auto GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS{0x8F39};
constexpr auto GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES{0x8F39};
constexpr auto GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS{0x90DC};
constexpr auto GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS{0x8E1E};
constexpr auto GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS{0x8E1F};
constexpr auto GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS{0x8B4D};
constexpr auto GL_MAX_COMBINED_UNIFORM_BLOCKS{0x8A2E};
constexpr auto GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS{0x8A31};
constexpr auto GL_MAX_COMPUTE_ATOMIC_COUNTERS{0x8265};
constexpr auto GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS{0x8264};
constexpr auto GL_MAX_COMPUTE_IMAGE_UNIFORMS{0x91BD};
constexpr auto GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS{0x90DB};
constexpr auto GL_MAX_COMPUTE_SHARED_MEMORY_SIZE{0x8262};
constexpr auto GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS{0x91BC};
constexpr auto GL_MAX_COMPUTE_UNIFORM_BLOCKS{0x91BB};
constexpr auto GL_MAX_COMPUTE_UNIFORM_COMPONENTS{0x8263};
constexpr auto GL_MAX_COMPUTE_WORK_GROUP_COUNT{0x91BE};
constexpr auto GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS{0x90EB};
constexpr auto GL_MAX_COMPUTE_WORK_GROUP_SIZE{0x91BF};
constexpr auto GL_MAX_CUBE_MAP_TEXTURE_SIZE{0x851C};
constexpr auto GL_MAX_CULL_DISTANCES{0x82F9};
constexpr auto GL_MAX_DEBUG_GROUP_STACK_DEPTH{0x826C};
constexpr auto GL_MAX_DEBUG_LOGGED_MESSAGES{0x9144};
constexpr auto GL_MAX_DEBUG_MESSAGE_LENGTH{0x9143};
constexpr auto GL_MAX_DEPTH{0x8280};
constexpr auto GL_MAX_DEPTH_TEXTURE_SAMPLES{0x910F};
constexpr auto GL_MAX_DRAW_BUFFERS{0x8824};
constexpr auto GL_MAX_DUAL_SOURCE_DRAW_BUFFERS{0x88FC};
constexpr auto GL_MAX_ELEMENTS_INDICES{0x80E9};
constexpr auto GL_MAX_ELEMENTS_VERTICES{0x80E8};
constexpr auto GL_MAX_ELEMENT_INDEX{0x8D6B};
constexpr auto GL_MAX_FRAGMENT_ATOMIC_COUNTERS{0x92D6};
constexpr auto GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS{0x92D0};
constexpr auto GL_MAX_FRAGMENT_IMAGE_UNIFORMS{0x90CE};
constexpr auto GL_MAX_FRAGMENT_INPUT_COMPONENTS{0x9125};
constexpr auto GL_MAX_FRAGMENT_INTERPOLATION_OFFSET{0x8E5C};
constexpr auto GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS{0x90DA};
constexpr auto GL_MAX_FRAGMENT_UNIFORM_BLOCKS{0x8A2D};
constexpr auto GL_MAX_FRAGMENT_UNIFORM_COMPONENTS{0x8B49};
constexpr auto GL_MAX_FRAGMENT_UNIFORM_VECTORS{0x8DFD};
constexpr auto GL_MAX_FRAMEBUFFER_HEIGHT{0x9316};
constexpr auto GL_MAX_FRAMEBUFFER_LAYERS{0x9317};
constexpr auto GL_MAX_FRAMEBUFFER_SAMPLES{0x9318};
constexpr auto GL_MAX_FRAMEBUFFER_WIDTH{0x9315};
constexpr auto GL_MAX_GEOMETRY_ATOMIC_COUNTERS{0x92D5};
constexpr auto GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS{0x92CF};
constexpr auto GL_MAX_GEOMETRY_IMAGE_UNIFORMS{0x90CD};
constexpr auto GL_MAX_GEOMETRY_INPUT_COMPONENTS{0x9123};
constexpr auto GL_MAX_GEOMETRY_OUTPUT_COMPONENTS{0x9124};
constexpr auto GL_MAX_GEOMETRY_OUTPUT_VERTICES{0x8DE0};
constexpr auto GL_MAX_GEOMETRY_SHADER_INVOCATIONS{0x8E5A};
constexpr auto GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS{0x90D7};
constexpr auto GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS{0x8C29};
constexpr auto GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS{0x8DE1};
constexpr auto GL_MAX_GEOMETRY_UNIFORM_BLOCKS{0x8A2C};
constexpr auto GL_MAX_GEOMETRY_UNIFORM_COMPONENTS{0x8DDF};
constexpr auto GL_MAX_HEIGHT{0x827F};
constexpr auto GL_MAX_IMAGE_SAMPLES{0x906D};
constexpr auto GL_MAX_IMAGE_UNITS{0x8F38};
constexpr auto GL_MAX_INTEGER_SAMPLES{0x9110};
constexpr auto GL_MAX_LABEL_LENGTH{0x82E8};
constexpr auto GL_MAX_LAYERS{0x8281};
constexpr auto GL_MAX_NAME_LENGTH{0x92F6};
constexpr auto GL_MAX_NUM_ACTIVE_VARIABLES{0x92F7};
constexpr auto GL_MAX_NUM_COMPATIBLE_SUBROUTINES{0x92F8};
constexpr auto GL_MAX_PATCH_VERTICES{0x8E7D};
constexpr auto GL_MAX_PROGRAM_TEXEL_OFFSET{0x8905};
constexpr auto GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET{0x8E5F};
constexpr auto GL_MAX_RECTANGLE_TEXTURE_SIZE{0x84F8};
constexpr auto GL_MAX_RENDERBUFFER_SIZE{0x84E8};
constexpr auto GL_MAX_SAMPLES{0x8D57};
constexpr auto GL_MAX_SAMPLE_MASK_WORDS{0x8E59};
constexpr auto GL_MAX_SERVER_WAIT_TIMEOUT{0x9111};
constexpr auto GL_MAX_SHADER_STORAGE_BLOCK_SIZE{0x90DE};
constexpr auto GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS{0x90DD};
constexpr auto GL_MAX_SUBROUTINES{0x8DE7};
constexpr auto GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS{0x8DE8};
constexpr auto GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS{0x92D3};
constexpr auto GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS{0x92CD};
constexpr auto GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS{0x90CB};
constexpr auto GL_MAX_TESS_CONTROL_INPUT_COMPONENTS{0x886C};
constexpr auto GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS{0x8E83};
constexpr auto GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS{0x90D8};
constexpr auto GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS{0x8E81};
constexpr auto GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS{0x8E85};
constexpr auto GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS{0x8E89};
constexpr auto GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS{0x8E7F};
constexpr auto GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS{0x92D4};
constexpr auto GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS{0x92CE};
constexpr auto GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS{0x90CC};
constexpr auto GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS{0x886D};
constexpr auto GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS{0x8E86};
constexpr auto GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS{0x90D9};
constexpr auto GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS{0x8E82};
constexpr auto GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS{0x8E8A};
constexpr auto GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS{0x8E80};
constexpr auto GL_MAX_TESS_GEN_LEVEL{0x8E7E};
constexpr auto GL_MAX_TESS_PATCH_COMPONENTS{0x8E84};
constexpr auto GL_MAX_TEXTURE_BUFFER_SIZE{0x8C2B};
constexpr auto GL_MAX_TEXTURE_IMAGE_UNITS{0x8872};
constexpr auto GL_MAX_TEXTURE_LOD_BIAS{0x84FD};
constexpr auto GL_MAX_TEXTURE_MAX_ANISOTROPY{0x84FF};
constexpr auto GL_MAX_TEXTURE_SIZE{0x0D33};
constexpr auto GL_MAX_TRANSFORM_FEEDBACK_BUFFERS{0x8E70};
constexpr auto GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS{0x8C8A};
constexpr auto GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS{0x8C8B};
constexpr auto GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS{0x8C80};
constexpr auto GL_MAX_UNIFORM_BLOCK_SIZE{0x8A30};
constexpr auto GL_MAX_UNIFORM_BUFFER_BINDINGS{0x8A2F};
constexpr auto GL_MAX_UNIFORM_LOCATIONS{0x826E};
constexpr auto GL_MAX_VARYING_COMPONENTS{0x8B4B};
constexpr auto GL_MAX_VARYING_FLOATS{0x8B4B};
constexpr auto GL_MAX_VARYING_VECTORS{0x8DFC};
constexpr auto GL_MAX_VERTEX_ATOMIC_COUNTERS{0x92D2};
constexpr auto GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS{0x92CC};
constexpr auto GL_MAX_VERTEX_ATTRIBS{0x8869};
constexpr auto GL_MAX_VERTEX_ATTRIB_BINDINGS{0x82DA};
constexpr auto GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET{0x82D9};
constexpr auto GL_MAX_VERTEX_ATTRIB_STRIDE{0x82E5};
constexpr auto GL_MAX_VERTEX_IMAGE_UNIFORMS{0x90CA};
constexpr auto GL_MAX_VERTEX_OUTPUT_COMPONENTS{0x9122};
constexpr auto GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS{0x90D6};
constexpr auto GL_MAX_VERTEX_STREAMS{0x8E71};
constexpr auto GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS{0x8B4C};
constexpr auto GL_MAX_VERTEX_UNIFORM_BLOCKS{0x8A2B};
constexpr auto GL_MAX_VERTEX_UNIFORM_COMPONENTS{0x8B4A};
constexpr auto GL_MAX_VERTEX_UNIFORM_VECTORS{0x8DFB};
constexpr auto GL_MAX_VIEWPORTS{0x825B};
constexpr auto GL_MAX_VIEWPORT_DIMS{0x0D3A};
constexpr auto GL_MAX_WIDTH{0x827E};
constexpr auto GL_MEDIUM_FLOAT{0x8DF1};
constexpr auto GL_MEDIUM_INT{0x8DF4};
constexpr auto GL_MIN{0x8007};
constexpr auto GL_MINOR_VERSION{0x821C};
constexpr auto GL_MIN_FRAGMENT_INTERPOLATION_OFFSET{0x8E5B};
constexpr auto GL_MIN_MAP_BUFFER_ALIGNMENT{0x90BC};
constexpr auto GL_MIN_PROGRAM_TEXEL_OFFSET{0x8904};
constexpr auto GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET{0x8E5E};
constexpr auto GL_MIN_SAMPLE_SHADING_VALUE{0x8C37};
constexpr auto GL_MIPMAP{0x8293};
constexpr auto GL_MIRRORED_REPEAT{0x8370};
constexpr auto GL_MIRROR_CLAMP_TO_EDGE{0x8743};
constexpr auto GL_MULTISAMPLE{0x809D};
constexpr auto GL_NAME_LENGTH{0x92F9};
constexpr auto GL_NAND{0x150E};
constexpr auto GL_NEAREST{0x2600};
constexpr auto GL_NEAREST_MIPMAP_LINEAR{0x2702};
constexpr auto GL_NEAREST_MIPMAP_NEAREST{0x2700};
constexpr auto GL_NEGATIVE_ONE_TO_ONE{0x935E};
constexpr auto GL_NEVER{0x0200};
constexpr auto GL_NICEST{0x1102};
constexpr auto GL_NONE{0};
constexpr auto GL_NOOP{0x1505};
constexpr auto GL_NOR{0x1508};
constexpr auto GL_NOTEQUAL{0x0205};
constexpr auto GL_NO_ERROR{0};
constexpr auto GL_NO_RESET_NOTIFICATION{0x8261};
constexpr auto GL_NUM_ACTIVE_VARIABLES{0x9304};
constexpr auto GL_NUM_COMPATIBLE_SUBROUTINES{0x8E4A};
constexpr auto GL_NUM_COMPRESSED_TEXTURE_FORMATS{0x86A2};
constexpr auto GL_NUM_EXTENSIONS{0x821D};
constexpr auto GL_NUM_PROGRAM_BINARY_FORMATS{0x87FE};
constexpr auto GL_NUM_SAMPLE_COUNTS{0x9380};
constexpr auto GL_NUM_SHADER_BINARY_FORMATS{0x8DF9};
constexpr auto GL_NUM_SHADING_LANGUAGE_VERSIONS{0x82E9};
constexpr auto GL_NUM_SPIR_V_EXTENSIONS{0x9554};
constexpr auto GL_OBJECT_TYPE{0x9112};
constexpr auto GL_OFFSET{0x92FC};
constexpr auto GL_ONE{1};
constexpr auto GL_ONE_MINUS_CONSTANT_ALPHA{0x8004};
constexpr auto GL_ONE_MINUS_CONSTANT_COLOR{0x8002};
constexpr auto GL_ONE_MINUS_DST_ALPHA{0x0305};
constexpr auto GL_ONE_MINUS_DST_COLOR{0x0307};
constexpr auto GL_ONE_MINUS_SRC1_ALPHA{0x88FB};
constexpr auto GL_ONE_MINUS_SRC1_COLOR{0x88FA};
constexpr auto GL_ONE_MINUS_SRC_ALPHA{0x0303};
constexpr auto GL_ONE_MINUS_SRC_COLOR{0x0301};
constexpr auto GL_OR{0x1507};
constexpr auto GL_OR_INVERTED{0x150D};
constexpr auto GL_OR_REVERSE{0x150B};
constexpr auto GL_OUT_OF_MEMORY{0x0505};
constexpr auto GL_PACK_ALIGNMENT{0x0D05};
constexpr auto GL_PACK_COMPRESSED_BLOCK_DEPTH{0x912D};
constexpr auto GL_PACK_COMPRESSED_BLOCK_HEIGHT{0x912C};
constexpr auto GL_PACK_COMPRESSED_BLOCK_SIZE{0x912E};
constexpr auto GL_PACK_COMPRESSED_BLOCK_WIDTH{0x912B};
constexpr auto GL_PACK_IMAGE_HEIGHT{0x806C};
constexpr auto GL_PACK_LSB_FIRST{0x0D01};
constexpr auto GL_PACK_ROW_LENGTH{0x0D02};
constexpr auto GL_PACK_SKIP_IMAGES{0x806B};
constexpr auto GL_PACK_SKIP_PIXELS{0x0D04};
constexpr auto GL_PACK_SKIP_ROWS{0x0D03};
constexpr auto GL_PACK_SWAP_BYTES{0x0D00};
constexpr auto GL_PARAMETER_BUFFER{0x80EE};
constexpr auto GL_PARAMETER_BUFFER_BINDING{0x80EF};
constexpr auto GL_PATCHES{0x000E};
constexpr auto GL_PATCH_DEFAULT_INNER_LEVEL{0x8E73};
constexpr auto GL_PATCH_DEFAULT_OUTER_LEVEL{0x8E74};
constexpr auto GL_PATCH_VERTICES{0x8E72};
constexpr auto GL_PIXEL_BUFFER_BARRIER_BIT{0x00000080};
constexpr auto GL_PIXEL_PACK_BUFFER{0x88EB};
constexpr auto GL_PIXEL_PACK_BUFFER_BINDING{0x88ED};
constexpr auto GL_PIXEL_UNPACK_BUFFER{0x88EC};
constexpr auto GL_PIXEL_UNPACK_BUFFER_BINDING{0x88EF};
constexpr auto GL_POINT{0x1B00};
constexpr auto GL_POINTS{0x0000};
constexpr auto GL_POINT_FADE_THRESHOLD_SIZE{0x8128};
constexpr auto GL_POINT_SIZE{0x0B11};
constexpr auto GL_POINT_SIZE_GRANULARITY{0x0B13};
constexpr auto GL_POINT_SIZE_RANGE{0x0B12};
constexpr auto GL_POINT_SPRITE_COORD_ORIGIN{0x8CA0};
constexpr auto GL_POLYGON_MODE{0x0B40};
constexpr auto GL_POLYGON_OFFSET_CLAMP{0x8E1B};
constexpr auto GL_POLYGON_OFFSET_FACTOR{0x8038};
constexpr auto GL_POLYGON_OFFSET_FILL{0x8037};
constexpr auto GL_POLYGON_OFFSET_LINE{0x2A02};
constexpr auto GL_POLYGON_OFFSET_POINT{0x2A01};
constexpr auto GL_POLYGON_OFFSET_UNITS{0x2A00};
constexpr auto GL_POLYGON_SMOOTH{0x0B41};
constexpr auto GL_POLYGON_SMOOTH_HINT{0x0C53};
constexpr auto GL_PRIMITIVES_GENERATED{0x8C87};
constexpr auto GL_PRIMITIVES_SUBMITTED{0x82EF};
constexpr auto GL_PRIMITIVE_RESTART{0x8F9D};
constexpr auto GL_PRIMITIVE_RESTART_FIXED_INDEX{0x8D69};
constexpr auto GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED{0x8221};
constexpr auto GL_PRIMITIVE_RESTART_INDEX{0x8F9E};
constexpr auto GL_PROGRAM{0x82E2};
constexpr auto GL_PROGRAM_BINARY_FORMATS{0x87FF};
constexpr auto GL_PROGRAM_BINARY_LENGTH{0x8741};
constexpr auto GL_PROGRAM_BINARY_RETRIEVABLE_HINT{0x8257};
constexpr auto GL_PROGRAM_INPUT{0x92E3};
constexpr auto GL_PROGRAM_OUTPUT{0x92E4};
constexpr auto GL_PROGRAM_PIPELINE{0x82E4};
constexpr auto GL_PROGRAM_PIPELINE_BINDING{0x825A};
constexpr auto GL_PROGRAM_POINT_SIZE{0x8642};
constexpr auto GL_PROGRAM_SEPARABLE{0x8258};
constexpr auto GL_PROVOKING_VERTEX{0x8E4F};
constexpr auto GL_PROXY_TEXTURE_1D{0x8063};
constexpr auto GL_PROXY_TEXTURE_1D_ARRAY{0x8C19};
constexpr auto GL_PROXY_TEXTURE_2D{0x8064};
constexpr auto GL_PROXY_TEXTURE_2D_ARRAY{0x8C1B};
constexpr auto GL_PROXY_TEXTURE_2D_MULTISAMPLE{0x9101};
constexpr auto GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY{0x9103};
constexpr auto GL_PROXY_TEXTURE_3D{0x8070};
constexpr auto GL_PROXY_TEXTURE_CUBE_MAP{0x851B};
constexpr auto GL_PROXY_TEXTURE_CUBE_MAP_ARRAY{0x900B};
constexpr auto GL_PROXY_TEXTURE_RECTANGLE{0x84F7};
constexpr auto GL_QUADS{0x0007};
constexpr auto GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION{0x8E4C};
constexpr auto GL_QUERY{0x82E3};
constexpr auto GL_QUERY_BUFFER{0x9192};
constexpr auto GL_QUERY_BUFFER_BARRIER_BIT{0x00008000};
constexpr auto GL_QUERY_BUFFER_BINDING{0x9193};
constexpr auto GL_QUERY_BY_REGION_NO_WAIT{0x8E16};
constexpr auto GL_QUERY_BY_REGION_NO_WAIT_INVERTED{0x8E1A};
constexpr auto GL_QUERY_BY_REGION_WAIT{0x8E15};
constexpr auto GL_QUERY_BY_REGION_WAIT_INVERTED{0x8E19};
constexpr auto GL_QUERY_COUNTER_BITS{0x8864};
constexpr auto GL_QUERY_NO_WAIT{0x8E14};
constexpr auto GL_QUERY_NO_WAIT_INVERTED{0x8E18};
constexpr auto GL_QUERY_RESULT{0x8866};
constexpr auto GL_QUERY_RESULT_AVAILABLE{0x8867};
constexpr auto GL_QUERY_RESULT_NO_WAIT{0x9194};
constexpr auto GL_QUERY_TARGET{0x82EA};
constexpr auto GL_QUERY_WAIT{0x8E13};
constexpr auto GL_QUERY_WAIT_INVERTED{0x8E17};
constexpr auto GL_R11F_G11F_B10F{0x8C3A};
constexpr auto GL_R16{0x822A};
constexpr auto GL_R16F{0x822D};
constexpr auto GL_R16I{0x8233};
constexpr auto GL_R16UI{0x8234};
constexpr auto GL_R16_SNORM{0x8F98};
constexpr auto GL_R32F{0x822E};
constexpr auto GL_R32I{0x8235};
constexpr auto GL_R32UI{0x8236};
constexpr auto GL_R3_G3_B2{0x2A10};
constexpr auto GL_R8{0x8229};
constexpr auto GL_R8I{0x8231};
constexpr auto GL_R8UI{0x8232};
constexpr auto GL_R8_SNORM{0x8F94};
constexpr auto GL_RASTERIZER_DISCARD{0x8C89};
constexpr auto GL_READ_BUFFER{0x0C02};
constexpr auto GL_READ_FRAMEBUFFER{0x8CA8};
constexpr auto GL_READ_FRAMEBUFFER_BINDING{0x8CAA};
constexpr auto GL_READ_ONLY{0x88B8};
constexpr auto GL_READ_PIXELS{0x828C};
constexpr auto GL_READ_PIXELS_FORMAT{0x828D};
constexpr auto GL_READ_PIXELS_TYPE{0x828E};
constexpr auto GL_READ_WRITE{0x88BA};
constexpr auto GL_RED{0x1903};
constexpr auto GL_RED_INTEGER{0x8D94};
constexpr auto GL_REFERENCED_BY_COMPUTE_SHADER{0x930B};
constexpr auto GL_REFERENCED_BY_FRAGMENT_SHADER{0x930A};
constexpr auto GL_REFERENCED_BY_GEOMETRY_SHADER{0x9309};
constexpr auto GL_REFERENCED_BY_TESS_CONTROL_SHADER{0x9307};
constexpr auto GL_REFERENCED_BY_TESS_EVALUATION_SHADER{0x9308};
constexpr auto GL_REFERENCED_BY_VERTEX_SHADER{0x9306};
constexpr auto GL_RENDERBUFFER{0x8D41};
constexpr auto GL_RENDERBUFFER_ALPHA_SIZE{0x8D53};
constexpr auto GL_RENDERBUFFER_BINDING{0x8CA7};
constexpr auto GL_RENDERBUFFER_BLUE_SIZE{0x8D52};
constexpr auto GL_RENDERBUFFER_DEPTH_SIZE{0x8D54};
constexpr auto GL_RENDERBUFFER_GREEN_SIZE{0x8D51};
constexpr auto GL_RENDERBUFFER_HEIGHT{0x8D43};
constexpr auto GL_RENDERBUFFER_INTERNAL_FORMAT{0x8D44};
constexpr auto GL_RENDERBUFFER_RED_SIZE{0x8D50};
constexpr auto GL_RENDERBUFFER_SAMPLES{0x8CAB};
constexpr auto GL_RENDERBUFFER_STENCIL_SIZE{0x8D55};
constexpr auto GL_RENDERBUFFER_WIDTH{0x8D42};
constexpr auto GL_RENDERER{0x1F01};
constexpr auto GL_REPEAT{0x2901};
constexpr auto GL_REPLACE{0x1E01};
constexpr auto GL_RESET_NOTIFICATION_STRATEGY{0x8256};
constexpr auto GL_RG{0x8227};
constexpr auto GL_RG16{0x822C};
constexpr auto GL_RG16F{0x822F};
constexpr auto GL_RG16I{0x8239};
constexpr auto GL_RG16UI{0x823A};
constexpr auto GL_RG16_SNORM{0x8F99};
constexpr auto GL_RG32F{0x8230};
constexpr auto GL_RG32I{0x823B};
constexpr auto GL_RG32UI{0x823C};
constexpr auto GL_RG8{0x822B};
constexpr auto GL_RG8I{0x8237};
constexpr auto GL_RG8UI{0x8238};
constexpr auto GL_RG8_SNORM{0x8F95};
constexpr auto GL_RGB{0x1907};
constexpr auto GL_RGB10{0x8052};
constexpr auto GL_RGB10_A2{0x8059};
constexpr auto GL_RGB10_A2UI{0x906F};
constexpr auto GL_RGB12{0x8053};
constexpr auto GL_RGB16{0x8054};
constexpr auto GL_RGB16F{0x881B};
constexpr auto GL_RGB16I{0x8D89};
constexpr auto GL_RGB16UI{0x8D77};
constexpr auto GL_RGB16_SNORM{0x8F9A};
constexpr auto GL_RGB32F{0x8815};
constexpr auto GL_RGB32I{0x8D83};
constexpr auto GL_RGB32UI{0x8D71};
constexpr auto GL_RGB4{0x804F};
constexpr auto GL_RGB5{0x8050};
constexpr auto GL_RGB565{0x8D62};
constexpr auto GL_RGB5_A1{0x8057};
constexpr auto GL_RGB8{0x8051};
constexpr auto GL_RGB8I{0x8D8F};
constexpr auto GL_RGB8UI{0x8D7D};
constexpr auto GL_RGB8_SNORM{0x8F96};
constexpr auto GL_RGB9_E5{0x8C3D};
constexpr auto GL_RGBA{0x1908};
constexpr auto GL_RGBA12{0x805A};
constexpr auto GL_RGBA16{0x805B};
constexpr auto GL_RGBA16F{0x881A};
constexpr auto GL_RGBA16I{0x8D88};
constexpr auto GL_RGBA16UI{0x8D76};
constexpr auto GL_RGBA16_SNORM{0x8F9B};
constexpr auto GL_RGBA2{0x8055};
constexpr auto GL_RGBA32F{0x8814};
constexpr auto GL_RGBA32I{0x8D82};
constexpr auto GL_RGBA32UI{0x8D70};
constexpr auto GL_RGBA4{0x8056};
constexpr auto GL_RGBA8{0x8058};
constexpr auto GL_RGBA8I{0x8D8E};
constexpr auto GL_RGBA8UI{0x8D7C};
constexpr auto GL_RGBA8_SNORM{0x8F97};
constexpr auto GL_RGBA_INTEGER{0x8D99};
constexpr auto GL_RGB_INTEGER{0x8D98};
constexpr auto GL_RG_INTEGER{0x8228};
constexpr auto GL_RIGHT{0x0407};
constexpr auto GL_SAMPLER{0x82E6};
constexpr auto GL_SAMPLER_1D{0x8B5D};
constexpr auto GL_SAMPLER_1D_ARRAY{0x8DC0};
constexpr auto GL_SAMPLER_1D_ARRAY_SHADOW{0x8DC3};
constexpr auto GL_SAMPLER_1D_SHADOW{0x8B61};
constexpr auto GL_SAMPLER_2D{0x8B5E};
constexpr auto GL_SAMPLER_2D_ARRAY{0x8DC1};
constexpr auto GL_SAMPLER_2D_ARRAY_SHADOW{0x8DC4};
constexpr auto GL_SAMPLER_2D_MULTISAMPLE{0x9108};
constexpr auto GL_SAMPLER_2D_MULTISAMPLE_ARRAY{0x910B};
constexpr auto GL_SAMPLER_2D_RECT{0x8B63};
constexpr auto GL_SAMPLER_2D_RECT_SHADOW{0x8B64};
constexpr auto GL_SAMPLER_2D_SHADOW{0x8B62};
constexpr auto GL_SAMPLER_3D{0x8B5F};
constexpr auto GL_SAMPLER_BINDING{0x8919};
constexpr auto GL_SAMPLER_BUFFER{0x8DC2};
constexpr auto GL_SAMPLER_CUBE{0x8B60};
constexpr auto GL_SAMPLER_CUBE_MAP_ARRAY{0x900C};
constexpr auto GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW{0x900D};
constexpr auto GL_SAMPLER_CUBE_SHADOW{0x8DC5};
constexpr auto GL_SAMPLES{0x80A9};
constexpr auto GL_SAMPLES_PASSED{0x8914};
constexpr auto GL_SAMPLE_ALPHA_TO_COVERAGE{0x809E};
constexpr auto GL_SAMPLE_ALPHA_TO_ONE{0x809F};
constexpr auto GL_SAMPLE_BUFFERS{0x80A8};
constexpr auto GL_SAMPLE_COVERAGE{0x80A0};
constexpr auto GL_SAMPLE_COVERAGE_INVERT{0x80AB};
constexpr auto GL_SAMPLE_COVERAGE_VALUE{0x80AA};
constexpr auto GL_SAMPLE_MASK{0x8E51};
constexpr auto GL_SAMPLE_MASK_VALUE{0x8E52};
constexpr auto GL_SAMPLE_POSITION{0x8E50};
constexpr auto GL_SAMPLE_SHADING{0x8C36};
constexpr auto GL_SCISSOR_BOX{0x0C10};
constexpr auto GL_SCISSOR_TEST{0x0C11};
constexpr auto GL_SEPARATE_ATTRIBS{0x8C8D};
constexpr auto GL_SET{0x150F};
constexpr auto GL_SHADER{0x82E1};
constexpr auto GL_SHADER_BINARY_FORMATS{0x8DF8};
constexpr auto GL_SHADER_BINARY_FORMAT_SPIR_V{0x9551};
constexpr auto GL_SHADER_COMPILER{0x8DFA};
constexpr auto GL_SHADER_IMAGE_ACCESS_BARRIER_BIT{0x00000020};
constexpr auto GL_SHADER_IMAGE_ATOMIC{0x82A6};
constexpr auto GL_SHADER_IMAGE_LOAD{0x82A4};
constexpr auto GL_SHADER_IMAGE_STORE{0x82A5};
constexpr auto GL_SHADER_SOURCE_LENGTH{0x8B88};
constexpr auto GL_SHADER_STORAGE_BARRIER_BIT{0x00002000};
constexpr auto GL_SHADER_STORAGE_BLOCK{0x92E6};
constexpr auto GL_SHADER_STORAGE_BUFFER{0x90D2};
constexpr auto GL_SHADER_STORAGE_BUFFER_BINDING{0x90D3};
constexpr auto GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT{0x90DF};
constexpr auto GL_SHADER_STORAGE_BUFFER_SIZE{0x90D5};
constexpr auto GL_SHADER_STORAGE_BUFFER_START{0x90D4};
constexpr auto GL_SHADER_TYPE{0x8B4F};
constexpr auto GL_SHADING_LANGUAGE_VERSION{0x8B8C};
constexpr auto GL_SHORT{0x1402};
constexpr auto GL_SIGNALED{0x9119};
constexpr auto GL_SIGNED_NORMALIZED{0x8F9C};
constexpr auto GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST{0x82AC};
constexpr auto GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE{0x82AE};
constexpr auto GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST{0x82AD};
constexpr auto GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE{0x82AF};
constexpr auto GL_SMOOTH_LINE_WIDTH_GRANULARITY{0x0B23};
constexpr auto GL_SMOOTH_LINE_WIDTH_RANGE{0x0B22};
constexpr auto GL_SMOOTH_POINT_SIZE_GRANULARITY{0x0B13};
constexpr auto GL_SMOOTH_POINT_SIZE_RANGE{0x0B12};
constexpr auto GL_SPIR_V_BINARY{0x9552};
constexpr auto GL_SPIR_V_EXTENSIONS{0x9553};
constexpr auto GL_SRC1_ALPHA{0x8589};
constexpr auto GL_SRC1_COLOR{0x88F9};
constexpr auto GL_SRC_ALPHA{0x0302};
constexpr auto GL_SRC_ALPHA_SATURATE{0x0308};
constexpr auto GL_SRC_COLOR{0x0300};
constexpr auto GL_SRGB{0x8C40};
constexpr auto GL_SRGB8{0x8C41};
constexpr auto GL_SRGB8_ALPHA8{0x8C43};
constexpr auto GL_SRGB_ALPHA{0x8C42};
constexpr auto GL_SRGB_READ{0x8297};
constexpr auto GL_SRGB_WRITE{0x8298};
constexpr auto GL_STACK_OVERFLOW{0x0503};
constexpr auto GL_STACK_UNDERFLOW{0x0504};
constexpr auto GL_STATIC_COPY{0x88E6};
constexpr auto GL_STATIC_DRAW{0x88E4};
constexpr auto GL_STATIC_READ{0x88E5};
constexpr auto GL_STENCIL{0x1802};
constexpr auto GL_STENCIL_ATTACHMENT{0x8D20};
constexpr auto GL_STENCIL_BACK_FAIL{0x8801};
constexpr auto GL_STENCIL_BACK_FUNC{0x8800};
constexpr auto GL_STENCIL_BACK_PASS_DEPTH_FAIL{0x8802};
constexpr auto GL_STENCIL_BACK_PASS_DEPTH_PASS{0x8803};
constexpr auto GL_STENCIL_BACK_REF{0x8CA3};
constexpr auto GL_STENCIL_BACK_VALUE_MASK{0x8CA4};
constexpr auto GL_STENCIL_BACK_WRITEMASK{0x8CA5};
constexpr auto GL_STENCIL_BUFFER_BIT{0x00000400};
constexpr auto GL_STENCIL_CLEAR_VALUE{0x0B91};
constexpr auto GL_STENCIL_COMPONENTS{0x8285};
constexpr auto GL_STENCIL_FAIL{0x0B94};
constexpr auto GL_STENCIL_FUNC{0x0B92};
constexpr auto GL_STENCIL_INDEX{0x1901};
constexpr auto GL_STENCIL_INDEX1{0x8D46};
constexpr auto GL_STENCIL_INDEX16{0x8D49};
constexpr auto GL_STENCIL_INDEX4{0x8D47};
constexpr auto GL_STENCIL_INDEX8{0x8D48};
constexpr auto GL_STENCIL_PASS_DEPTH_FAIL{0x0B95};
constexpr auto GL_STENCIL_PASS_DEPTH_PASS{0x0B96};
constexpr auto GL_STENCIL_REF{0x0B97};
constexpr auto GL_STENCIL_RENDERABLE{0x8288};
constexpr auto GL_STENCIL_TEST{0x0B90};
constexpr auto GL_STENCIL_VALUE_MASK{0x0B93};
constexpr auto GL_STENCIL_WRITEMASK{0x0B98};
constexpr auto GL_STEREO{0x0C33};
constexpr auto GL_STREAM_COPY{0x88E2};
constexpr auto GL_STREAM_DRAW{0x88E0};
constexpr auto GL_STREAM_READ{0x88E1};
constexpr auto GL_SUBPIXEL_BITS{0x0D50};
constexpr auto GL_SYNC_CONDITION{0x9113};
constexpr auto GL_SYNC_FENCE{0x9116};
constexpr auto GL_SYNC_FLAGS{0x9115};
constexpr auto GL_SYNC_FLUSH_COMMANDS_BIT{0x00000001};
constexpr auto GL_SYNC_GPU_COMMANDS_COMPLETE{0x9117};
constexpr auto GL_SYNC_STATUS{0x9114};
constexpr auto GL_TESS_CONTROL_OUTPUT_VERTICES{0x8E75};
constexpr auto GL_TESS_CONTROL_SHADER{0x8E88};
constexpr auto GL_TESS_CONTROL_SHADER_BIT{0x00000008};
constexpr auto GL_TESS_CONTROL_SHADER_PATCHES{0x82F1};
constexpr auto GL_TESS_CONTROL_SUBROUTINE{0x92E9};
constexpr auto GL_TESS_CONTROL_SUBROUTINE_UNIFORM{0x92EF};
constexpr auto GL_TESS_CONTROL_TEXTURE{0x829C};
constexpr auto GL_TESS_EVALUATION_SHADER{0x8E87};
constexpr auto GL_TESS_EVALUATION_SHADER_BIT{0x00000010};
constexpr auto GL_TESS_EVALUATION_SHADER_INVOCATIONS{0x82F2};
constexpr auto GL_TESS_EVALUATION_SUBROUTINE{0x92EA};
constexpr auto GL_TESS_EVALUATION_SUBROUTINE_UNIFORM{0x92F0};
constexpr auto GL_TESS_EVALUATION_TEXTURE{0x829D};
constexpr auto GL_TESS_GEN_MODE{0x8E76};
constexpr auto GL_TESS_GEN_POINT_MODE{0x8E79};
constexpr auto GL_TESS_GEN_SPACING{0x8E77};
constexpr auto GL_TESS_GEN_VERTEX_ORDER{0x8E78};
constexpr auto GL_TEXTURE{0x1702};
constexpr auto GL_TEXTURE0{0x84C0};
constexpr auto GL_TEXTURE1{0x84C1};
constexpr auto GL_TEXTURE10{0x84CA};
constexpr auto GL_TEXTURE11{0x84CB};
constexpr auto GL_TEXTURE12{0x84CC};
constexpr auto GL_TEXTURE13{0x84CD};
constexpr auto GL_TEXTURE14{0x84CE};
constexpr auto GL_TEXTURE15{0x84CF};
constexpr auto GL_TEXTURE16{0x84D0};
constexpr auto GL_TEXTURE17{0x84D1};
constexpr auto GL_TEXTURE18{0x84D2};
constexpr auto GL_TEXTURE19{0x84D3};
constexpr auto GL_TEXTURE2{0x84C2};
constexpr auto GL_TEXTURE20{0x84D4};
constexpr auto GL_TEXTURE21{0x84D5};
constexpr auto GL_TEXTURE22{0x84D6};
constexpr auto GL_TEXTURE23{0x84D7};
constexpr auto GL_TEXTURE24{0x84D8};
constexpr auto GL_TEXTURE25{0x84D9};
constexpr auto GL_TEXTURE26{0x84DA};
constexpr auto GL_TEXTURE27{0x84DB};
constexpr auto GL_TEXTURE28{0x84DC};
constexpr auto GL_TEXTURE29{0x84DD};
constexpr auto GL_TEXTURE3{0x84C3};
constexpr auto GL_TEXTURE30{0x84DE};
constexpr auto GL_TEXTURE31{0x84DF};
constexpr auto GL_TEXTURE4{0x84C4};
constexpr auto GL_TEXTURE5{0x84C5};
constexpr auto GL_TEXTURE6{0x84C6};
constexpr auto GL_TEXTURE7{0x84C7};
constexpr auto GL_TEXTURE8{0x84C8};
constexpr auto GL_TEXTURE9{0x84C9};
constexpr auto GL_TEXTURE_1D{0x0DE0};
constexpr auto GL_TEXTURE_1D_ARRAY{0x8C18};
constexpr auto GL_TEXTURE_2D{0x0DE1};
constexpr auto GL_TEXTURE_2D_ARRAY{0x8C1A};
constexpr auto GL_TEXTURE_2D_MULTISAMPLE{0x9100};
constexpr auto GL_TEXTURE_2D_MULTISAMPLE_ARRAY{0x9102};
constexpr auto GL_TEXTURE_3D{0x806F};
constexpr auto GL_TEXTURE_ALPHA_SIZE{0x805F};
constexpr auto GL_TEXTURE_ALPHA_TYPE{0x8C13};
constexpr auto GL_TEXTURE_BASE_LEVEL{0x813C};
constexpr auto GL_TEXTURE_BINDING_1D{0x8068};
constexpr auto GL_TEXTURE_BINDING_1D_ARRAY{0x8C1C};
constexpr auto GL_TEXTURE_BINDING_2D{0x8069};
constexpr auto GL_TEXTURE_BINDING_2D_ARRAY{0x8C1D};
constexpr auto GL_TEXTURE_BINDING_2D_MULTISAMPLE{0x9104};
constexpr auto GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY{0x9105};
constexpr auto GL_TEXTURE_BINDING_3D{0x806A};
constexpr auto GL_TEXTURE_BINDING_BUFFER{0x8C2C};
constexpr auto GL_TEXTURE_BINDING_CUBE_MAP{0x8514};
constexpr auto GL_TEXTURE_BINDING_CUBE_MAP_ARRAY{0x900A};
constexpr auto GL_TEXTURE_BINDING_RECTANGLE{0x84F6};
constexpr auto GL_TEXTURE_BLUE_SIZE{0x805E};
constexpr auto GL_TEXTURE_BLUE_TYPE{0x8C12};
constexpr auto GL_TEXTURE_BORDER_COLOR{0x1004};
constexpr auto GL_TEXTURE_BUFFER{0x8C2A};
constexpr auto GL_TEXTURE_BUFFER_BINDING{0x8C2A};
constexpr auto GL_TEXTURE_BUFFER_DATA_STORE_BINDING{0x8C2D};
constexpr auto GL_TEXTURE_BUFFER_OFFSET{0x919D};
constexpr auto GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT{0x919F};
constexpr auto GL_TEXTURE_BUFFER_SIZE{0x919E};
constexpr auto GL_TEXTURE_COMPARE_FUNC{0x884D};
constexpr auto GL_TEXTURE_COMPARE_MODE{0x884C};
constexpr auto GL_TEXTURE_COMPRESSED{0x86A1};
constexpr auto GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT{0x82B2};
constexpr auto GL_TEXTURE_COMPRESSED_BLOCK_SIZE{0x82B3};
constexpr auto GL_TEXTURE_COMPRESSED_BLOCK_WIDTH{0x82B1};
constexpr auto GL_TEXTURE_COMPRESSED_IMAGE_SIZE{0x86A0};
constexpr auto GL_TEXTURE_COMPRESSION_HINT{0x84EF};
constexpr auto GL_TEXTURE_CUBE_MAP{0x8513};
constexpr auto GL_TEXTURE_CUBE_MAP_ARRAY{0x9009};
constexpr auto GL_TEXTURE_CUBE_MAP_NEGATIVE_X{0x8516};
constexpr auto GL_TEXTURE_CUBE_MAP_NEGATIVE_Y{0x8518};
constexpr auto GL_TEXTURE_CUBE_MAP_NEGATIVE_Z{0x851A};
constexpr auto GL_TEXTURE_CUBE_MAP_POSITIVE_X{0x8515};
constexpr auto GL_TEXTURE_CUBE_MAP_POSITIVE_Y{0x8517};
constexpr auto GL_TEXTURE_CUBE_MAP_POSITIVE_Z{0x8519};
constexpr auto GL_TEXTURE_CUBE_MAP_SEAMLESS{0x884F};
constexpr auto GL_TEXTURE_DEPTH{0x8071};
constexpr auto GL_TEXTURE_DEPTH_SIZE{0x884A};
constexpr auto GL_TEXTURE_DEPTH_TYPE{0x8C16};
constexpr auto GL_TEXTURE_FETCH_BARRIER_BIT{0x00000008};
constexpr auto GL_TEXTURE_FIXED_SAMPLE_LOCATIONS{0x9107};
constexpr auto GL_TEXTURE_GATHER{0x82A2};
constexpr auto GL_TEXTURE_GATHER_SHADOW{0x82A3};
constexpr auto GL_TEXTURE_GREEN_SIZE{0x805D};
constexpr auto GL_TEXTURE_GREEN_TYPE{0x8C11};
constexpr auto GL_TEXTURE_HEIGHT{0x1001};
constexpr auto GL_TEXTURE_IMAGE_FORMAT{0x828F};
constexpr auto GL_TEXTURE_IMAGE_TYPE{0x8290};
constexpr auto GL_TEXTURE_IMMUTABLE_FORMAT{0x912F};
constexpr auto GL_TEXTURE_IMMUTABLE_LEVELS{0x82DF};
constexpr auto GL_TEXTURE_INTERNAL_FORMAT{0x1003};
constexpr auto GL_TEXTURE_LOD_BIAS{0x8501};
constexpr auto GL_TEXTURE_MAG_FILTER{0x2800};
constexpr auto GL_TEXTURE_MAX_ANISOTROPY{0x84FE};
constexpr auto GL_TEXTURE_MAX_LEVEL{0x813D};
constexpr auto GL_TEXTURE_MAX_LOD{0x813B};
constexpr auto GL_TEXTURE_MIN_FILTER{0x2801};
constexpr auto GL_TEXTURE_MIN_LOD{0x813A};
constexpr auto GL_TEXTURE_RECTANGLE{0x84F5};
constexpr auto GL_TEXTURE_RED_SIZE{0x805C};
constexpr auto GL_TEXTURE_RED_TYPE{0x8C10};
constexpr auto GL_TEXTURE_SAMPLES{0x9106};
constexpr auto GL_TEXTURE_SHADOW{0x82A1};
constexpr auto GL_TEXTURE_SHARED_SIZE{0x8C3F};
constexpr auto GL_TEXTURE_STENCIL_SIZE{0x88F1};
constexpr auto GL_TEXTURE_SWIZZLE_A{0x8E45};
constexpr auto GL_TEXTURE_SWIZZLE_B{0x8E44};
constexpr auto GL_TEXTURE_SWIZZLE_G{0x8E43};
constexpr auto GL_TEXTURE_SWIZZLE_R{0x8E42};
constexpr auto GL_TEXTURE_SWIZZLE_RGBA{0x8E46};
constexpr auto GL_TEXTURE_TARGET{0x1006};
constexpr auto GL_TEXTURE_UPDATE_BARRIER_BIT{0x00000100};
constexpr auto GL_TEXTURE_VIEW{0x82B5};
constexpr auto GL_TEXTURE_VIEW_MIN_LAYER{0x82DD};
constexpr auto GL_TEXTURE_VIEW_MIN_LEVEL{0x82DB};
constexpr auto GL_TEXTURE_VIEW_NUM_LAYERS{0x82DE};
constexpr auto GL_TEXTURE_VIEW_NUM_LEVELS{0x82DC};
constexpr auto GL_TEXTURE_WIDTH{0x1000};
constexpr auto GL_TEXTURE_WRAP_R{0x8072};
constexpr auto GL_TEXTURE_WRAP_S{0x2802};
constexpr auto GL_TEXTURE_WRAP_T{0x2803};
constexpr auto GL_TIMEOUT_EXPIRED{0x911B};
constexpr auto GL_TIMEOUT_IGNORED{0xFFFFFFFFFFFFFFFF};
constexpr auto GL_TIMESTAMP{0x8E28};
constexpr auto GL_TIME_ELAPSED{0x88BF};
constexpr auto GL_TOP_LEVEL_ARRAY_SIZE{0x930C};
constexpr auto GL_TOP_LEVEL_ARRAY_STRIDE{0x930D};
constexpr auto GL_TRANSFORM_FEEDBACK{0x8E22};
constexpr auto GL_TRANSFORM_FEEDBACK_ACTIVE{0x8E24};
constexpr auto GL_TRANSFORM_FEEDBACK_BARRIER_BIT{0x00000800};
constexpr auto GL_TRANSFORM_FEEDBACK_BINDING{0x8E25};
constexpr auto GL_TRANSFORM_FEEDBACK_BUFFER{0x8C8E};
constexpr auto GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE{0x8E24};
constexpr auto GL_TRANSFORM_FEEDBACK_BUFFER_BINDING{0x8C8F};
constexpr auto GL_TRANSFORM_FEEDBACK_BUFFER_INDEX{0x934B};
constexpr auto GL_TRANSFORM_FEEDBACK_BUFFER_MODE{0x8C7F};
constexpr auto GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED{0x8E23};
constexpr auto GL_TRANSFORM_FEEDBACK_BUFFER_SIZE{0x8C85};
constexpr auto GL_TRANSFORM_FEEDBACK_BUFFER_START{0x8C84};
constexpr auto GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE{0x934C};
constexpr auto GL_TRANSFORM_FEEDBACK_OVERFLOW{0x82EC};
constexpr auto GL_TRANSFORM_FEEDBACK_PAUSED{0x8E23};
constexpr auto GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN{0x8C88};
constexpr auto GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW{0x82ED};
constexpr auto GL_TRANSFORM_FEEDBACK_VARYING{0x92F4};
constexpr auto GL_TRANSFORM_FEEDBACK_VARYINGS{0x8C83};
constexpr auto GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH{0x8C76};
constexpr auto GL_TRIANGLES{0x0004};
constexpr auto GL_TRIANGLES_ADJACENCY{0x000C};
constexpr auto GL_TRIANGLE_FAN{0x0006};
constexpr auto GL_TRIANGLE_STRIP{0x0005};
constexpr auto GL_TRIANGLE_STRIP_ADJACENCY{0x000D};
constexpr auto GL_TRUE{1};
constexpr auto GL_TYPE{0x92FA};
constexpr auto GL_UNDEFINED_VERTEX{0x8260};
constexpr auto GL_UNIFORM{0x92E1};
constexpr auto GL_UNIFORM_ARRAY_STRIDE{0x8A3C};
constexpr auto GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX{0x92DA};
constexpr auto GL_UNIFORM_BARRIER_BIT{0x00000004};
constexpr auto GL_UNIFORM_BLOCK{0x92E2};
constexpr auto GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS{0x8A42};
constexpr auto GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES{0x8A43};
constexpr auto GL_UNIFORM_BLOCK_BINDING{0x8A3F};
constexpr auto GL_UNIFORM_BLOCK_DATA_SIZE{0x8A40};
constexpr auto GL_UNIFORM_BLOCK_INDEX{0x8A3A};
constexpr auto GL_UNIFORM_BLOCK_NAME_LENGTH{0x8A41};
constexpr auto GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER{0x90EC};
constexpr auto GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER{0x8A46};
constexpr auto GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER{0x8A45};
constexpr auto GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER{0x84F0};
constexpr auto GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER{0x84F1};
constexpr auto GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER{0x8A44};
constexpr auto GL_UNIFORM_BUFFER{0x8A11};
constexpr auto GL_UNIFORM_BUFFER_BINDING{0x8A28};
constexpr auto GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT{0x8A34};
constexpr auto GL_UNIFORM_BUFFER_SIZE{0x8A2A};
constexpr auto GL_UNIFORM_BUFFER_START{0x8A29};
constexpr auto GL_UNIFORM_IS_ROW_MAJOR{0x8A3E};
constexpr auto GL_UNIFORM_MATRIX_STRIDE{0x8A3D};
constexpr auto GL_UNIFORM_NAME_LENGTH{0x8A39};
constexpr auto GL_UNIFORM_OFFSET{0x8A3B};
constexpr auto GL_UNIFORM_SIZE{0x8A38};
constexpr auto GL_UNIFORM_TYPE{0x8A37};
constexpr auto GL_UNKNOWN_CONTEXT_RESET{0x8255};
constexpr auto GL_UNPACK_ALIGNMENT{0x0CF5};
constexpr auto GL_UNPACK_COMPRESSED_BLOCK_DEPTH{0x9129};
constexpr auto GL_UNPACK_COMPRESSED_BLOCK_HEIGHT{0x9128};
constexpr auto GL_UNPACK_COMPRESSED_BLOCK_SIZE{0x912A};
constexpr auto GL_UNPACK_COMPRESSED_BLOCK_WIDTH{0x9127};
constexpr auto GL_UNPACK_IMAGE_HEIGHT{0x806E};
constexpr auto GL_UNPACK_LSB_FIRST{0x0CF1};
constexpr auto GL_UNPACK_ROW_LENGTH{0x0CF2};
constexpr auto GL_UNPACK_SKIP_IMAGES{0x806D};
constexpr auto GL_UNPACK_SKIP_PIXELS{0x0CF4};
constexpr auto GL_UNPACK_SKIP_ROWS{0x0CF3};
constexpr auto GL_UNPACK_SWAP_BYTES{0x0CF0};
constexpr auto GL_UNSIGNALED{0x9118};
constexpr auto GL_UNSIGNED_BYTE{0x1401};
constexpr auto GL_UNSIGNED_BYTE_2_3_3_REV{0x8362};
constexpr auto GL_UNSIGNED_BYTE_3_3_2{0x8032};
constexpr auto GL_UNSIGNED_INT{0x1405};
constexpr auto GL_UNSIGNED_INT_10F_11F_11F_REV{0x8C3B};
constexpr auto GL_UNSIGNED_INT_10_10_10_2{0x8036};
constexpr auto GL_UNSIGNED_INT_24_8{0x84FA};
constexpr auto GL_UNSIGNED_INT_2_10_10_10_REV{0x8368};
constexpr auto GL_UNSIGNED_INT_5_9_9_9_REV{0x8C3E};
constexpr auto GL_UNSIGNED_INT_8_8_8_8{0x8035};
constexpr auto GL_UNSIGNED_INT_8_8_8_8_REV{0x8367};
constexpr auto GL_UNSIGNED_INT_ATOMIC_COUNTER{0x92DB};
constexpr auto GL_UNSIGNED_INT_IMAGE_1D{0x9062};
constexpr auto GL_UNSIGNED_INT_IMAGE_1D_ARRAY{0x9068};
constexpr auto GL_UNSIGNED_INT_IMAGE_2D{0x9063};
constexpr auto GL_UNSIGNED_INT_IMAGE_2D_ARRAY{0x9069};
constexpr auto GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE{0x906B};
constexpr auto GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY{0x906C};
constexpr auto GL_UNSIGNED_INT_IMAGE_2D_RECT{0x9065};
constexpr auto GL_UNSIGNED_INT_IMAGE_3D{0x9064};
constexpr auto GL_UNSIGNED_INT_IMAGE_BUFFER{0x9067};
constexpr auto GL_UNSIGNED_INT_IMAGE_CUBE{0x9066};
constexpr auto GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY{0x906A};
constexpr auto GL_UNSIGNED_INT_SAMPLER_1D{0x8DD1};
constexpr auto GL_UNSIGNED_INT_SAMPLER_1D_ARRAY{0x8DD6};
constexpr auto GL_UNSIGNED_INT_SAMPLER_2D{0x8DD2};
constexpr auto GL_UNSIGNED_INT_SAMPLER_2D_ARRAY{0x8DD7};
constexpr auto GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE{0x910A};
constexpr auto GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY{0x910D};
constexpr auto GL_UNSIGNED_INT_SAMPLER_2D_RECT{0x8DD5};
constexpr auto GL_UNSIGNED_INT_SAMPLER_3D{0x8DD3};
constexpr auto GL_UNSIGNED_INT_SAMPLER_BUFFER{0x8DD8};
constexpr auto GL_UNSIGNED_INT_SAMPLER_CUBE{0x8DD4};
constexpr auto GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY{0x900F};
constexpr auto GL_UNSIGNED_INT_VEC2{0x8DC6};
constexpr auto GL_UNSIGNED_INT_VEC3{0x8DC7};
constexpr auto GL_UNSIGNED_INT_VEC4{0x8DC8};
constexpr auto GL_UNSIGNED_NORMALIZED{0x8C17};
constexpr auto GL_UNSIGNED_SHORT{0x1403};
constexpr auto GL_UNSIGNED_SHORT_1_5_5_5_REV{0x8366};
constexpr auto GL_UNSIGNED_SHORT_4_4_4_4{0x8033};
constexpr auto GL_UNSIGNED_SHORT_4_4_4_4_REV{0x8365};
constexpr auto GL_UNSIGNED_SHORT_5_5_5_1{0x8034};
constexpr auto GL_UNSIGNED_SHORT_5_6_5{0x8363};
constexpr auto GL_UNSIGNED_SHORT_5_6_5_REV{0x8364};
constexpr auto GL_UPPER_LEFT{0x8CA2};
constexpr auto GL_VALIDATE_STATUS{0x8B83};
constexpr auto GL_VENDOR{0x1F00};
constexpr auto GL_VERSION{0x1F02};
constexpr auto GL_VERTEX_ARRAY{0x8074};
constexpr auto GL_VERTEX_ARRAY_BINDING{0x85B5};
constexpr auto GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT{0x00000001};
constexpr auto GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING{0x889F};
constexpr auto GL_VERTEX_ATTRIB_ARRAY_DIVISOR{0x88FE};
constexpr auto GL_VERTEX_ATTRIB_ARRAY_ENABLED{0x8622};
constexpr auto GL_VERTEX_ATTRIB_ARRAY_INTEGER{0x88FD};
constexpr auto GL_VERTEX_ATTRIB_ARRAY_LONG{0x874E};
constexpr auto GL_VERTEX_ATTRIB_ARRAY_NORMALIZED{0x886A};
constexpr auto GL_VERTEX_ATTRIB_ARRAY_POINTER{0x8645};
constexpr auto GL_VERTEX_ATTRIB_ARRAY_SIZE{0x8623};
constexpr auto GL_VERTEX_ATTRIB_ARRAY_STRIDE{0x8624};
constexpr auto GL_VERTEX_ATTRIB_ARRAY_TYPE{0x8625};
constexpr auto GL_VERTEX_ATTRIB_BINDING{0x82D4};
constexpr auto GL_VERTEX_ATTRIB_RELATIVE_OFFSET{0x82D5};
constexpr auto GL_VERTEX_BINDING_BUFFER{0x8F4F};
constexpr auto GL_VERTEX_BINDING_DIVISOR{0x82D6};
constexpr auto GL_VERTEX_BINDING_OFFSET{0x82D7};
constexpr auto GL_VERTEX_BINDING_STRIDE{0x82D8};
constexpr auto GL_VERTEX_PROGRAM_POINT_SIZE{0x8642};
constexpr auto GL_VERTEX_SHADER{0x8B31};
constexpr auto GL_VERTEX_SHADER_BIT{0x00000001};
constexpr auto GL_VERTEX_SHADER_INVOCATIONS{0x82F0};
constexpr auto GL_VERTEX_SUBROUTINE{0x92E8};
constexpr auto GL_VERTEX_SUBROUTINE_UNIFORM{0x92EE};
constexpr auto GL_VERTEX_TEXTURE{0x829B};
constexpr auto GL_VERTICES_SUBMITTED{0x82EE};
constexpr auto GL_VIEWPORT{0x0BA2};
constexpr auto GL_VIEWPORT_BOUNDS_RANGE{0x825D};
constexpr auto GL_VIEWPORT_INDEX_PROVOKING_VERTEX{0x825F};
constexpr auto GL_VIEWPORT_SUBPIXEL_BITS{0x825C};
constexpr auto GL_VIEW_CLASS_128_BITS{0x82C4};
constexpr auto GL_VIEW_CLASS_16_BITS{0x82CA};
constexpr auto GL_VIEW_CLASS_24_BITS{0x82C9};
constexpr auto GL_VIEW_CLASS_32_BITS{0x82C8};
constexpr auto GL_VIEW_CLASS_48_BITS{0x82C7};
constexpr auto GL_VIEW_CLASS_64_BITS{0x82C6};
constexpr auto GL_VIEW_CLASS_8_BITS{0x82CB};
constexpr auto GL_VIEW_CLASS_96_BITS{0x82C5};
constexpr auto GL_VIEW_CLASS_BPTC_FLOAT{0x82D3};
constexpr auto GL_VIEW_CLASS_BPTC_UNORM{0x82D2};
constexpr auto GL_VIEW_CLASS_RGTC1_RED{0x82D0};
constexpr auto GL_VIEW_CLASS_RGTC2_RG{0x82D1};
constexpr auto GL_VIEW_CLASS_S3TC_DXT1_RGB{0x82CC};
constexpr auto GL_VIEW_CLASS_S3TC_DXT1_RGBA{0x82CD};
constexpr auto GL_VIEW_CLASS_S3TC_DXT3_RGBA{0x82CE};
constexpr auto GL_VIEW_CLASS_S3TC_DXT5_RGBA{0x82CF};
constexpr auto GL_VIEW_COMPATIBILITY_CLASS{0x82B6};
constexpr auto GL_WAIT_FAILED{0x911D};
constexpr auto GL_WRITE_ONLY{0x88B9};
constexpr auto GL_XOR{0x1506};
constexpr auto GL_ZERO{0};
constexpr auto GL_ZERO_TO_ONE{0x935F};

#undef glActiveShaderProgram
#undef glActiveTexture
#undef glAttachShader
#undef glBeginConditionalRender
#undef glEndConditionalRender
#undef glBeginQuery
#undef glEndQuery
#undef glBeginQueryIndexed
#undef glEndQueryIndexed
#undef glBeginTransformFeedback
#undef glEndTransformFeedback
#undef glBindAttribLocation
#undef glBindBuffer
#undef glBindBufferBase
#undef glBindBufferRange
#undef glBindBuffersBase
#undef glBindBuffersRange
#undef glBindFragDataLocation
#undef glBindFragDataLocationIndexed
#undef glBindFramebuffer
#undef glBindImageTexture
#undef glBindImageTextures
#undef glBindProgramPipeline
#undef glBindRenderbuffer
#undef glBindSampler
#undef glBindSamplers
#undef glBindTexture
#undef glBindTextureUnit
#undef glBindTextures
#undef glBindTransformFeedback
#undef glBindVertexArray
#undef glBindVertexBuffer
#undef glVertexArrayVertexBuffer
#undef glBindVertexBuffers
#undef glVertexArrayVertexBuffers
#undef glBlendColor
#undef glBlendEquation
#undef glBlendEquationi
#undef glBlendEquationSeparate
#undef glBlendEquationSeparatei
#undef glBlendFunc
#undef glBlendFunci
#undef glBlendFuncSeparate
#undef glBlendFuncSeparatei
#undef glBlitFramebuffer
#undef glBlitNamedFramebuffer
#undef glBufferData
#undef glNamedBufferData
#undef glBufferStorage
#undef glNamedBufferStorage
#undef glBufferSubData
#undef glNamedBufferSubData
#undef glCheckFramebufferStatus
#undef glCheckNamedFramebufferStatus
#undef glClampColor
#undef glClear
#undef glClearBufferiv
#undef glClearBufferuiv
#undef glClearBufferfv
#undef glClearBufferfi
#undef glClearNamedFramebufferiv
#undef glClearNamedFramebufferuiv
#undef glClearNamedFramebufferfv
#undef glClearNamedFramebufferfi
#undef glClearBufferData
#undef glClearNamedBufferData
#undef glClearBufferSubData
#undef glClearNamedBufferSubData
#undef glClearColor
#undef glClearDepth
#undef glClearDepthf
#undef glClearStencil
#undef glClearTexImage
#undef glClearTexSubImage
#undef glClientWaitSync
#undef glClipControl
#undef glColorMask
#undef glColorMaski
#undef glCompileShader
#undef glCompressedTexImage1D
#undef glCompressedTexImage2D
#undef glCompressedTexImage3D
#undef glCompressedTexSubImage1D
#undef glCompressedTextureSubImage1D
#undef glCompressedTexSubImage2D
#undef glCompressedTextureSubImage2D
#undef glCompressedTexSubImage3D
#undef glCompressedTextureSubImage3D
#undef glCopyBufferSubData
#undef glCopyNamedBufferSubData
#undef glCopyImageSubData
#undef glCopyTexImage1D
#undef glCopyTexImage2D
#undef glCopyTexSubImage1D
#undef glCopyTextureSubImage1D
#undef glCopyTexSubImage2D
#undef glCopyTextureSubImage2D
#undef glCopyTexSubImage3D
#undef glCopyTextureSubImage3D
#undef glCreateBuffers
#undef glCreateFramebuffers
#undef glCreateProgram
#undef glCreateProgramPipelines
#undef glCreateQueries
#undef glCreateRenderbuffers
#undef glCreateSamplers
#undef glCreateShader
#undef glCreateShaderProgramv
#undef glCreateTextures
#undef glCreateTransformFeedbacks
#undef glCreateVertexArrays
#undef glCullFace
#undef glDebugMessageCallback
#undef glDebugMessageControl
#undef glDebugMessageInsert
#undef glDeleteBuffers
#undef glDeleteFramebuffers
#undef glDeleteProgram
#undef glDeleteProgramPipelines
#undef glDeleteQueries
#undef glDeleteRenderbuffers
#undef glDeleteSamplers
#undef glDeleteShader
#undef glDeleteSync
#undef glDeleteTextures
#undef glDeleteTransformFeedbacks
#undef glDeleteVertexArrays
#undef glDepthFunc
#undef glDepthMask
#undef glDepthRange
#undef glDepthRangef
#undef glDepthRangeArrayv
#undef glDepthRangeIndexed
#undef glDetachShader
#undef glDispatchCompute
#undef glDispatchComputeIndirect
#undef glDrawArrays
#undef glDrawArraysIndirect
#undef glDrawArraysInstanced
#undef glDrawArraysInstancedBaseInstance
#undef glDrawBuffer
#undef glNamedFramebufferDrawBuffer
#undef glDrawBuffers
#undef glNamedFramebufferDrawBuffers
#undef glDrawElements
#undef glDrawElementsBaseVertex
#undef glDrawElementsIndirect
#undef glDrawElementsInstanced
#undef glDrawElementsInstancedBaseInstance
#undef glDrawElementsInstancedBaseVertex
#undef glDrawElementsInstancedBaseVertexBaseInstance
#undef glDrawRangeElements
#undef glDrawRangeElementsBaseVertex
#undef glDrawTransformFeedback
#undef glDrawTransformFeedbackInstanced
#undef glDrawTransformFeedbackStream
#undef glDrawTransformFeedbackStreamInstanced
#undef glEnable
#undef glDisable
#undef glEnablei
#undef glDisablei
#undef glEnableVertexAttribArray
#undef glDisableVertexAttribArray
#undef glEnableVertexArrayAttrib
#undef glDisableVertexArrayAttrib
#undef glFenceSync
#undef glFinish
#undef glFlush
#undef glFlushMappedBufferRange
#undef glFlushMappedNamedBufferRange
#undef glFramebufferParameteri
#undef glNamedFramebufferParameteri
#undef glFramebufferRenderbuffer
#undef glNamedFramebufferRenderbuffer
#undef glFramebufferTexture
#undef glFramebufferTexture1D
#undef glFramebufferTexture2D
#undef glFramebufferTexture3D
#undef glNamedFramebufferTexture
#undef glFramebufferTextureLayer
#undef glNamedFramebufferTextureLayer
#undef glFrontFace
#undef glGenBuffers
#undef glGenFramebuffers
#undef glGenProgramPipelines
#undef glGenQueries
#undef glGenRenderbuffers
#undef glGenSamplers
#undef glGenTextures
#undef glGenTransformFeedbacks
#undef glGenVertexArrays
#undef glGenerateMipmap
#undef glGenerateTextureMipmap
#undef glGetBooleanv
#undef glGetDoublev
#undef glGetFloatv
#undef glGetIntegerv
#undef glGetInteger64v
#undef glGetBooleani_v
#undef glGetIntegeri_v
#undef glGetFloati_v
#undef glGetDoublei_v
#undef glGetInteger64i_v
#undef glGetActiveAtomicCounterBufferiv
#undef glGetActiveAttrib
#undef glGetActiveSubroutineName
#undef glGetActiveSubroutineUniformiv
#undef glGetActiveSubroutineUniformName
#undef glGetActiveUniform
#undef glGetActiveUniformBlockiv
#undef glGetActiveUniformBlockName
#undef glGetActiveUniformName
#undef glGetActiveUniformsiv
#undef glGetAttachedShaders
#undef glGetAttribLocation
#undef glGetBufferParameteriv
#undef glGetBufferParameteri64v
#undef glGetNamedBufferParameteriv
#undef glGetNamedBufferParameteri64v
#undef glGetBufferPointerv
#undef glGetNamedBufferPointerv
#undef glGetBufferSubData
#undef glGetNamedBufferSubData
#undef glGetCompressedTexImage
#undef glGetnCompressedTexImage
#undef glGetCompressedTextureImage
#undef glGetCompressedTextureSubImage
#undef glGetDebugMessageLog
#undef glGetError
#undef glGetFragDataIndex
#undef glGetFragDataLocation
#undef glGetFramebufferAttachmentParameteriv
#undef glGetNamedFramebufferAttachmentParameteriv
#undef glGetFramebufferParameteriv
#undef glGetNamedFramebufferParameteriv
#undef glGetGraphicsResetStatus
#undef glGetInternalformativ
#undef glGetInternalformati64v
#undef glGetMultisamplefv
#undef glGetObjectLabel
#undef glGetObjectPtrLabel
#undef glGetPointerv
#undef glGetProgramiv
#undef glGetProgramBinary
#undef glGetProgramInfoLog
#undef glGetProgramInterfaceiv
#undef glGetProgramPipelineiv
#undef glGetProgramPipelineInfoLog
#undef glGetProgramResourceiv
#undef glGetProgramResourceIndex
#undef glGetProgramResourceLocation
#undef glGetProgramResourceLocationIndex
#undef glGetProgramResourceName
#undef glGetProgramStageiv
#undef glGetQueryIndexediv
#undef glGetQueryObjectiv
#undef glGetQueryObjectuiv
#undef glGetQueryObjecti64v
#undef glGetQueryObjectui64v
#undef glGetQueryiv
#undef glGetRenderbufferParameteriv
#undef glGetNamedRenderbufferParameteriv
#undef glGetSamplerParameterfv
#undef glGetSamplerParameteriv
#undef glGetSamplerParameterIiv
#undef glGetSamplerParameterIuiv
#undef glGetShaderiv
#undef glGetShaderInfoLog
#undef glGetShaderPrecisionFormat
#undef glGetShaderSource
#undef glGetString
#undef glGetStringi
#undef glGetSubroutineIndex
#undef glGetSubroutineUniformLocation
#undef glGetSynciv
#undef glGetTexImage
#undef glGetnTexImage
#undef glGetTextureImage
#undef glGetTexLevelParameterfv
#undef glGetTexLevelParameteriv
#undef glGetTextureLevelParameterfv
#undef glGetTextureLevelParameteriv
#undef glGetTexParameterfv
#undef glGetTexParameteriv
#undef glGetTexParameterIiv
#undef glGetTexParameterIuiv
#undef glGetTextureParameterfv
#undef glGetTextureParameteriv
#undef glGetTextureParameterIiv
#undef glGetTextureParameterIuiv
#undef glGetTextureSubImage
#undef glGetTransformFeedbackiv
#undef glGetTransformFeedbacki_v
#undef glGetTransformFeedbacki64_v
#undef glGetTransformFeedbackVarying
#undef glGetUniformfv
#undef glGetUniformiv
#undef glGetUniformuiv
#undef glGetUniformdv
#undef glGetnUniformfv
#undef glGetnUniformiv
#undef glGetnUniformuiv
#undef glGetnUniformdv
#undef glGetUniformBlockIndex
#undef glGetUniformIndices
#undef glGetUniformLocation
#undef glGetUniformSubroutineuiv
#undef glGetVertexArrayIndexed64iv
#undef glGetVertexArrayIndexediv
#undef glGetVertexArrayiv
#undef glGetVertexAttribdv
#undef glGetVertexAttribfv
#undef glGetVertexAttribiv
#undef glGetVertexAttribIiv
#undef glGetVertexAttribIuiv
#undef glGetVertexAttribLdv
#undef glGetVertexAttribPointerv
#undef glHint
#undef glInvalidateBufferData
#undef glInvalidateBufferSubData
#undef glInvalidateFramebuffer
#undef glInvalidateNamedFramebufferData
#undef glInvalidateSubFramebuffer
#undef glInvalidateNamedFramebufferSubData
#undef glInvalidateTexImage
#undef glInvalidateTexSubImage
#undef glIsBuffer
#undef glIsEnabled
#undef glIsEnabledi
#undef glIsFramebuffer
#undef glIsProgram
#undef glIsProgramPipeline
#undef glIsQuery
#undef glIsRenderbuffer
#undef glIsSampler
#undef glIsShader
#undef glIsSync
#undef glIsTexture
#undef glIsTransformFeedback
#undef glIsVertexArray
#undef glLineWidth
#undef glLinkProgram
#undef glLogicOp
#undef glMapBuffer
#undef glMapNamedBuffer
#undef glMapBufferRange
#undef glMapNamedBufferRange
#undef glMemoryBarrier
#undef glMemoryBarrierByRegion
#undef glMinSampleShading
#undef glMultiDrawArrays
#undef glMultiDrawArraysIndirect
#undef glMultiDrawElements
#undef glMultiDrawElementsBaseVertex
#undef glMultiDrawElementsIndirect
#undef glObjectLabel
#undef glObjectPtrLabel
#undef glPatchParameteri
#undef glPatchParameterfv
#undef glPauseTransformFeedback
#undef glPixelStoref
#undef glPixelStorei
#undef glPointParameterf
#undef glPointParameteri
#undef glPointParameterfv
#undef glPointParameteriv
#undef glPointSize
#undef glPolygonMode
#undef glPolygonOffset
#undef glPopDebugGroup
#undef glPrimitiveRestartIndex
#undef glProgramBinary
#undef glProgramParameteri
#undef glProgramUniform1f
#undef glProgramUniform2f
#undef glProgramUniform3f
#undef glProgramUniform4f
#undef glProgramUniform1i
#undef glProgramUniform2i
#undef glProgramUniform3i
#undef glProgramUniform4i
#undef glProgramUniform1ui
#undef glProgramUniform2ui
#undef glProgramUniform3ui
#undef glProgramUniform4ui
#undef glProgramUniform1fv
#undef glProgramUniform2fv
#undef glProgramUniform3fv
#undef glProgramUniform4fv
#undef glProgramUniform1iv
#undef glProgramUniform2iv
#undef glProgramUniform3iv
#undef glProgramUniform4iv
#undef glProgramUniform1uiv
#undef glProgramUniform2uiv
#undef glProgramUniform3uiv
#undef glProgramUniform4uiv
#undef glProgramUniformMatrix2fv
#undef glProgramUniformMatrix3fv
#undef glProgramUniformMatrix4fv
#undef glProgramUniformMatrix2x3fv
#undef glProgramUniformMatrix3x2fv
#undef glProgramUniformMatrix2x4fv
#undef glProgramUniformMatrix4x2fv
#undef glProgramUniformMatrix3x4fv
#undef glProgramUniformMatrix4x3fv
#undef glProvokingVertex
#undef glPushDebugGroup
#undef glQueryCounter
#undef glReadBuffer
#undef glNamedFramebufferReadBuffer
#undef glReadPixels
#undef glReadnPixels
#undef glReleaseShaderCompiler
#undef glRenderbufferStorage
#undef glNamedRenderbufferStorage
#undef glRenderbufferStorageMultisample
#undef glNamedRenderbufferStorageMultisample
#undef glResumeTransformFeedback
#undef glSampleCoverage
#undef glSampleMaski
#undef glSamplerParameterf
#undef glSamplerParameteri
#undef glSamplerParameterfv
#undef glSamplerParameteriv
#undef glSamplerParameterIiv
#undef glSamplerParameterIuiv
#undef glScissor
#undef glScissorArrayv
#undef glScissorIndexed
#undef glScissorIndexedv
#undef glShaderBinary
#undef glShaderSource
#undef glShaderStorageBlockBinding
#undef glStencilFunc
#undef glStencilFuncSeparate
#undef glStencilMask
#undef glStencilMaskSeparate
#undef glStencilOp
#undef glStencilOpSeparate
#undef glTexBuffer
#undef glTextureBuffer
#undef glTexBufferRange
#undef glTextureBufferRange
#undef glTexImage1D
#undef glTexImage2D
#undef glTexImage2DMultisample
#undef glTexImage3D
#undef glTexImage3DMultisample
#undef glTexParameterf
#undef glTexParameteri
#undef glTextureParameterf
#undef glTextureParameteri
#undef glTexParameterfv
#undef glTexParameteriv
#undef glTexParameterIiv
#undef glTexParameterIuiv
#undef glTextureParameterfv
#undef glTextureParameteriv
#undef glTextureParameterIiv
#undef glTextureParameterIuiv
#undef glTexStorage1D
#undef glTextureStorage1D
#undef glTexStorage2D
#undef glTextureStorage2D
#undef glTexStorage2DMultisample
#undef glTextureStorage2DMultisample
#undef glTexStorage3D
#undef glTextureStorage3D
#undef glTexStorage3DMultisample
#undef glTextureStorage3DMultisample
#undef glTexSubImage1D
#undef glTextureSubImage1D
#undef glTexSubImage2D
#undef glTextureSubImage2D
#undef glTexSubImage3D
#undef glTextureSubImage3D
#undef glTextureBarrier
#undef glTextureView
#undef glTransformFeedbackBufferBase
#undef glTransformFeedbackBufferRange
#undef glTransformFeedbackVaryings
#undef glUniform1f
#undef glUniform2f
#undef glUniform3f
#undef glUniform4f
#undef glUniform1i
#undef glUniform2i
#undef glUniform3i
#undef glUniform4i
#undef glUniform1ui
#undef glUniform2ui
#undef glUniform3ui
#undef glUniform4ui
#undef glUniform1fv
#undef glUniform2fv
#undef glUniform3fv
#undef glUniform4fv
#undef glUniform1iv
#undef glUniform2iv
#undef glUniform3iv
#undef glUniform4iv
#undef glUniform1uiv
#undef glUniform2uiv
#undef glUniform3uiv
#undef glUniform4uiv
#undef glUniformMatrix2fv
#undef glUniformMatrix3fv
#undef glUniformMatrix4fv
#undef glUniformMatrix2x3fv
#undef glUniformMatrix3x2fv
#undef glUniformMatrix2x4fv
#undef glUniformMatrix4x2fv
#undef glUniformMatrix3x4fv
#undef glUniformMatrix4x3fv
#undef glUniformBlockBinding
#undef glUniformSubroutinesuiv
#undef glUnmapBuffer
#undef glUnmapNamedBuffer
#undef glUseProgram
#undef glUseProgramStages
#undef glValidateProgram
#undef glValidateProgramPipeline
#undef glVertexArrayElementBuffer
#undef glVertexAttrib1f
#undef glVertexAttrib1s
#undef glVertexAttrib1d
#undef glVertexAttribI1i
#undef glVertexAttribI1ui
#undef glVertexAttrib2f
#undef glVertexAttrib2s
#undef glVertexAttrib2d
#undef glVertexAttribI2i
#undef glVertexAttribI2ui
#undef glVertexAttrib3f
#undef glVertexAttrib3s
#undef glVertexAttrib3d
#undef glVertexAttribI3i
#undef glVertexAttribI3ui
#undef glVertexAttrib4f
#undef glVertexAttrib4s
#undef glVertexAttrib4d
#undef glVertexAttrib4Nub
#undef glVertexAttribI4i
#undef glVertexAttribI4ui
#undef glVertexAttribL1d
#undef glVertexAttribL2d
#undef glVertexAttribL3d
#undef glVertexAttribL4d
#undef glVertexAttrib1fv
#undef glVertexAttrib1sv
#undef glVertexAttrib1dv
#undef glVertexAttribI1iv
#undef glVertexAttribI1uiv
#undef glVertexAttrib2fv
#undef glVertexAttrib2sv
#undef glVertexAttrib2dv
#undef glVertexAttribI2iv
#undef glVertexAttribI2uiv
#undef glVertexAttrib3fv
#undef glVertexAttrib3sv
#undef glVertexAttrib3dv
#undef glVertexAttribI3iv
#undef glVertexAttribI3uiv
#undef glVertexAttrib4fv
#undef glVertexAttrib4sv
#undef glVertexAttrib4dv
#undef glVertexAttrib4iv
#undef glVertexAttrib4bv
#undef glVertexAttrib4ubv
#undef glVertexAttrib4usv
#undef glVertexAttrib4uiv
#undef glVertexAttrib4Nbv
#undef glVertexAttrib4Nsv
#undef glVertexAttrib4Niv
#undef glVertexAttrib4Nubv
#undef glVertexAttrib4Nusv
#undef glVertexAttrib4Nuiv
#undef glVertexAttribI4bv
#undef glVertexAttribI4ubv
#undef glVertexAttribI4sv
#undef glVertexAttribI4usv
#undef glVertexAttribI4iv
#undef glVertexAttribI4uiv
#undef glVertexAttribL1dv
#undef glVertexAttribL2dv
#undef glVertexAttribL3dv
#undef glVertexAttribL4dv
#undef glVertexAttribP1ui
#undef glVertexAttribP2ui
#undef glVertexAttribP3ui
#undef glVertexAttribP4ui
#undef glVertexAttribBinding
#undef glVertexArrayAttribBinding
#undef glVertexAttribDivisor
#undef glVertexAttribFormat
#undef glVertexAttribIFormat
#undef glVertexAttribLFormat
#undef glVertexArrayAttribFormat
#undef glVertexArrayAttribIFormat
#undef glVertexArrayAttribLFormat
#undef glVertexAttribPointer
#undef glVertexAttribIPointer
#undef glVertexAttribLPointer
#undef glVertexBindingDivisor
#undef glVertexArrayBindingDivisor
#undef glViewport
#undef glViewportArrayv
#undef glViewportIndexedf
#undef glViewportIndexedfv
#undef glWaitSync
/**
 * glActiveShaderProgram — set the active program object for a program
 * pipeline object
 *
 * @param [pipeline] Specifies the program pipeline object to set the active
 * program object for.
 *
 * @param [program] Specifies the program object to set as the active program
 * pipeline object pipeline.
 */
static inline void glActiveShaderProgram(GLuint pipeline, GLuint program)
{
  glad_glActiveShaderProgram(pipeline, program);
}
/**
 * glActiveTexture — select active texture unit
 *
 * @param [texture] Specifies which texture unit to make active. The number of
 * texture units is implementation dependent, but must be at least 80. texture
 * must be one of GL_TEXTUREi, where i ranges from zero to the value of
 * GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS minus one. The initial value is
 * GL_TEXTURE0.
 */
static inline void glActiveTexture(GLenum texture)
{
  glad_glActiveTexture(texture);
}
/**
 * glAttachShader — Attaches a shader object to a program object
 *
 * @param [program] Specifies the program object to which a shader object will
 * be attached.
 *
 * @param [shader] Specifies the shader object that is to be attached.
 */
static inline void glAttachShader(GLuint program, GLuint shader)
{
  glad_glAttachShader(program, shader);
}
/**
 * glBeginConditionalRender — start conditional rendering
 */
static inline void glBeginConditionalRender(GLuint id, GLenum mode)
{
  glad_glBeginConditionalRender(id, mode);
}
/**
 * glBeginConditionalRender — start conditional rendering
 */
static inline void glEndConditionalRender(void)
{
  glad_glEndConditionalRender();
}
/**
 * glBeginQuery — delimit the boundaries of a query object
 */
static inline void glBeginQuery(GLenum target, GLuint id)
{
  glad_glBeginQuery(target, id);
}
/**
 * glBeginQuery — delimit the boundaries of a query object
 */
static inline void glEndQuery(GLenum target) { glad_glEndQuery(target); }
/**
 * glBeginQueryIndexed, glEndQueryIndexed — delimit the boundaries of a query
 * object on an indexed target
 */
static inline void glBeginQueryIndexed(GLenum target, GLuint index, GLuint id)
{
  glad_glBeginQueryIndexed(target, index, id);
}
/**
 * glBeginQueryIndexed, glEndQueryIndexed — delimit the boundaries of a query
 * object on an indexed target
 */
static inline void glEndQueryIndexed(GLenum target, GLuint index)
{
  glad_glEndQueryIndexed(target, index);
}
/**
 * glBeginTransformFeedback — start transform feedback operation
 */
static inline void glBeginTransformFeedback(GLenum primitiveMode)
{
  glad_glBeginTransformFeedback(primitiveMode);
}
/**
 * glBeginTransformFeedback — start transform feedback operation
 */
static inline void glEndTransformFeedback(void)
{
  glad_glEndTransformFeedback();
}
/**
 * glBindAttribLocation — Associates a generic vertex attribute index with a
 * named attribute variable
 *
 * @param [program] Specifies the handle of the program object in which the
 * association is to be made.
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * bound.
 *
 * @param [name] Specifies a null terminated string containing the name of the
 * vertex shader attribute variable to which index is to be bound.
 */
static inline void glBindAttribLocation(GLuint program, GLuint index,
                                        const GLchar *name)
{
  glad_glBindAttribLocation(program, index, name);
}
/**
 * glBindBuffer — bind a named buffer object
 *
 * @param [target] Specifies the target to which the buffer object is bound,
 * which must be one of the buffer binding targets in the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of a buffer object.
 */
static inline void glBindBuffer(GLenum target, GLuint buffer)
{
  glad_glBindBuffer(target, buffer);
}
/**
 * glBindBufferBase — bind a buffer object to an indexed buffer target
 *
 * @param [target] Specify the target of the bind operation. target must be
 * one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER,
 * GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
 *
 * @param [index] Specify the index of the binding point within the array
 * specified by target.
 *
 * @param [buffer] The name of a buffer object to bind to the specified
 * binding point.
 */
static inline void glBindBufferBase(GLenum target, GLuint index, GLuint buffer)
{
  glad_glBindBufferBase(target, index, buffer);
}
/**
 * glBindBufferRange — bind a range within a buffer object to an indexed
 * buffer target
 *
 * @param [target] Specify the target of the bind operation. target must be
 * one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER,
 * GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER.
 *
 * @param [index] Specify the index of the binding point within the array
 * specified by target.
 *
 * @param [buffer] The name of a buffer object to bind to the specified
 * binding point.
 *
 * @param [offset] The starting offset in basic machine units into the buffer
 * object buffer.
 *
 * @param [size] The amount of data in machine units that can be read from the
 * buffer object while used as an indexed target.
 */
static inline void glBindBufferRange(GLenum target, GLuint index, GLuint buffer,
                                     GLintptr offset, GLsizeiptr size)
{
  glad_glBindBufferRange(target, index, buffer, offset, size);
}
/**
 * glBindBuffersBase — bind one or more buffer objects to a sequence of
 * indexed buffer targets
 *
 * @param [target] Specify the target of the bind operation. target must be
 * one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER,
 * GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
 *
 * @param [index] Specify the index of the first binding point within the
 * array specified by target.
 *
 * @param [count] Specify the number of contiguous binding points to which to
 * bind buffers.
 *
 * @param [buffers] A pointer to an array of names of buffer objects to bind
 * to the targets on the specified binding point, or NULL.
 */
static inline void glBindBuffersBase(GLenum target, GLuint first, GLsizei count,
                                     const GLuint *buffers)
{
  glad_glBindBuffersBase(target, first, count, buffers);
}
/**
 * glBindBuffersRange — bind ranges of one or more buffer objects to a
 * sequence of indexed buffer targets
 *
 * @param [target] Specify the target of the bind operation. target must be
 * one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER,
 * GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
 *
 * @param [index] Specify the index of the first binding point within the
 * array specified by target.
 *
 * @param [count] Specify the number of contiguous binding points to which to
 * bind buffers.
 *
 * @param [buffers] A pointer to an array of names of buffer objects to bind
 * to the targets on the specified binding point, or NULL.
 */
static inline void glBindBuffersRange(GLenum target, GLuint first,
                                      GLsizei count, const GLuint *buffers,
                                      const GLintptr *offsets,
                                      const GLintptr *sizes)
{
  glad_glBindBuffersRange(target, first, count, buffers, offsets, sizes);
}
/**
 * glBindFragDataLocation — bind a user-defined varying out variable to a
 * fragment shader color number
 *
 * @param [program] The name of the program containing varying out variable
 * whose binding to modify
 *
 * @param [colorNumber] The color number to bind the user-defined varying out
 * variable to
 *
 * @param [name] The name of the user-defined varying out variable whose
 * binding to modify
 */
static inline void glBindFragDataLocation(GLuint program, GLuint colorNumber,
                                          const char *name)
{
  glad_glBindFragDataLocation(program, colorNumber, name);
}
/**
 * glBindFragDataLocationIndexed — bind a user-defined varying out variable to
 * a fragment shader color number and index
 *
 * @param [program] The name of the program containing varying out variable
 * whose binding to modify
 *
 * @param [colorNumber] The color number to bind the user-defined varying out
 * variable to
 *
 * @param [index] The index of the color input to bind the user-defined
 * varying out variable to
 *
 * @param [name] The name of the user-defined varying out variable whose
 * binding to modify
 */
static inline void glBindFragDataLocationIndexed(GLuint program,
                                                 GLuint colorNumber,
                                                 GLuint index, const char *name)
{
  glad_glBindFragDataLocationIndexed(program, colorNumber, index, name);
}
/**
 * glBindFramebuffer — bind a framebuffer to a framebuffer target
 *
 * @param [target] Specifies the framebuffer target of the binding operation.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object to bind.
 */
static inline void glBindFramebuffer(GLenum target, GLuint framebuffer)
{
  glad_glBindFramebuffer(target, framebuffer);
}
/**
 * glBindImageTexture — bind a level of a texture to an image unit
 *
 * @param [unit] Specifies the index of the image unit to which to bind the
 * texture
 *
 * @param [texture] Specifies the name of the texture to bind to the image
 * unit.
 *
 * @param [level] Specifies the level of the texture that is to be bound.
 *
 * @param [layered] Specifies whether a layered texture binding is to be
 * established.
 *
 * @param [layer] If layered is GL_FALSE, specifies the layer of texture to be
 * bound to the image unit. Ignored otherwise.
 *
 * @param [access] Specifies a token indicating the type of access that will
 * be performed on the image.
 *
 * @param [format] Specifies the format that the elements of the image will be
 * treated as for the purposes of formatted stores.
 */
static inline void glBindImageTexture(GLuint unit, GLuint texture, GLint level,
                                      GLboolean layered, GLint layer,
                                      GLenum access, GLenum format)
{
  glad_glBindImageTexture(unit, texture, level, layered, layer, access, format);
}
/**
 * glBindImageTextures — bind one or more named texture images to a sequence
 * of consecutive image units
 *
 * @param [first] Specifies the first image unit to which a texture is to be
 * bound.
 *
 * @param [count] Specifies the number of textures to bind.
 *
 * @param [textures] Specifies the address of an array of names of existing
 * texture objects.
 */
static inline void glBindImageTextures(GLuint first, GLsizei count,
                                       const GLuint *textures)
{
  glad_glBindImageTextures(first, count, textures);
}
/**
 * glBindProgramPipeline — bind a program pipeline to the current context
 *
 * @param [pipeline] Specifies the name of the pipeline object to bind to the
 * context.
 */
static inline void glBindProgramPipeline(GLuint pipeline)
{
  glad_glBindProgramPipeline(pipeline);
}
/**
 * glBindRenderbuffer — bind a renderbuffer to a renderbuffer target
 *
 * @param [target] Specifies the renderbuffer target of the binding operation.
 * target must be GL_RENDERBUFFER.
 *
 * @param [renderbuffer] Specifies the name of the renderbuffer object to
 * bind.
 */
static inline void glBindRenderbuffer(GLenum target, GLuint renderbuffer)
{
  glad_glBindRenderbuffer(target, renderbuffer);
}
/**
 * glBindSampler — bind a named sampler to a texturing target
 *
 * @param [unit] Specifies the index of the texture unit to which the sampler
 * is bound.
 *
 * @param [sampler] Specifies the name of a sampler.
 */
static inline void glBindSampler(GLuint unit, GLuint sampler)
{
  glad_glBindSampler(unit, sampler);
}
/**
 * glBindSamplers — bind one or more named sampler objects to a sequence of
 * consecutive sampler units
 *
 * @param [first] Specifies the first sampler unit to which a sampler object
 * is to be bound.
 *
 * @param [count] Specifies the number of samplers to bind.
 *
 * @param [samplers] Specifies the address of an array of names of existing
 * sampler objects.
 */
static inline void glBindSamplers(GLuint first, GLsizei count,
                                  const GLuint *samplers)
{
  glad_glBindSamplers(first, count, samplers);
}
/**
 * glBindTexture — bind a named texture to a texturing target
 *
 * @param [target] Specifies the target to which the texture is bound. Must be
 * one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP,
 * GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or
 * GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
 *
 * @param [texture] Specifies the name of a texture.
 */
static inline void glBindTexture(GLenum target, GLuint texture)
{
  glad_glBindTexture(target, texture);
}
/**
 * glBindTextureUnit — bind an existing texture object to the specified
 * texture unit
 *
 * @param [unit] Specifies the texture unit, to which the texture object
 * should be bound to.
 *
 * @param [texture] Specifies the name of a texture.
 */
static inline void glBindTextureUnit(GLuint unit, GLuint texture)
{
  glad_glBindTextureUnit(unit, texture);
}
/**
 * glBindTextures — bind one or more named textures to a sequence of
 * consecutive texture units
 *
 * @param [first] Specifies the first texture unit to which a texture is to be
 * bound.
 *
 * @param [count] Specifies the number of textures to bind.
 *
 * @param [textures] Specifies the address of an array of names of existing
 * texture objects.
 */
static inline void glBindTextures(GLuint first, GLsizei count,
                                  const GLuint *textures)
{
  glad_glBindTextures(first, count, textures);
}
/**
 * glBindTransformFeedback — bind a transform feedback object
 *
 * @param [target] Specifies the target to which to bind the transform
 * feedback object id. target must be GL_TRANSFORM_FEEDBACK.
 *
 * @param [id] Specifies the name of a transform feedback object reserved by
 * glGenTransformFeedbacks.
 */
static inline void glBindTransformFeedback(GLenum target, GLuint id)
{
  glad_glBindTransformFeedback(target, id);
}
/**
 * glBindVertexArray — bind a vertex array object
 *
 * @param [array] Specifies the name of the vertex array to bind.
 */
static inline void glBindVertexArray(GLuint array)
{
  glad_glBindVertexArray(array);
}
/**
 * glBindVertexBuffer, glVertexArrayVertexBuffer — bind a buffer to a vertex
 * buffer bind point
 *
 * @param [vaobj] Specifies the name of the vertex array object to be used by
 * glVertexArrayVertexBuffer function.
 *
 * @param [bindingindex] The index of the vertex buffer binding point to which
 * to bind the buffer.
 *
 * @param [buffer] The name of a buffer to bind to the vertex buffer binding
 * point.
 *
 * @param [offset] The offset of the first element of the buffer.
 *
 * @param [stride] The distance between elements within the buffer.
 */
static inline void glBindVertexBuffer(GLuint bindingindex, GLuint buffer,
                                      GLintptr offset, GLint stride)
{
  glad_glBindVertexBuffer(bindingindex, buffer, offset, stride);
}
/**
 * glBindVertexBuffer, glVertexArrayVertexBuffer — bind a buffer to a vertex
 * buffer bind point
 *
 * @param [vaobj] Specifies the name of the vertex array object to be used by
 * glVertexArrayVertexBuffer function.
 *
 * @param [bindingindex] The index of the vertex buffer binding point to which
 * to bind the buffer.
 *
 * @param [buffer] The name of a buffer to bind to the vertex buffer binding
 * point.
 *
 * @param [offset] The offset of the first element of the buffer.
 *
 * @param [stride] The distance between elements within the buffer.
 */
static inline void glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex,
                                             GLuint buffer, GLintptr offset,
                                             GLsizei stride)
{
  glad_glVertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride);
}
/**
 * glBindVertexBuffers, glVertexArrayVertexBuffers — attach multiple buffer
 * objects to a vertex array object
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 * glVertexArrayVertexBuffers.
 *
 * @param [first] Specifies the first vertex buffer binding point to which a
 * buffer object is to be bound.
 *
 * @param [count] Specifies the number of buffers to bind.
 *
 * @param [buffers] Specifies the address of an array of names of existing
 * buffer objects.
 *
 * @param [offsets] Specifies the address of an array of offsets to associate
 * with the binding points.
 *
 * @param [strides] Specifies the address of an array of strides to associate
 * with the binding points.
 */
static inline void glBindVertexBuffers(GLuint first, GLsizei count,
                                       const GLuint *buffers,
                                       const GLintptr *offsets,
                                       const GLsizei *strides)
{
  glad_glBindVertexBuffers(first, count, buffers, offsets, strides);
}
/**
 * glBindVertexBuffers, glVertexArrayVertexBuffers — attach multiple buffer
 * objects to a vertex array object
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 * glVertexArrayVertexBuffers.
 *
 * @param [first] Specifies the first vertex buffer binding point to which a
 * buffer object is to be bound.
 *
 * @param [count] Specifies the number of buffers to bind.
 *
 * @param [buffers] Specifies the address of an array of names of existing
 * buffer objects.
 *
 * @param [offsets] Specifies the address of an array of offsets to associate
 * with the binding points.
 *
 * @param [strides] Specifies the address of an array of strides to associate
 * with the binding points.
 */
static inline void glVertexArrayVertexBuffers(GLuint vaobj, GLuint first,
                                              GLsizei count,
                                              const GLuint *buffers,
                                              const GLintptr *offsets,
                                              const GLsizei *strides)
{
  glad_glVertexArrayVertexBuffers(vaobj, first, count, buffers, offsets,
                                  strides);
}
/**
 * glBlendColor — set the blend color
 *
 * @param [red, green, blue, alpha] specify the components of GL_BLEND_COLOR
 */
static inline void glBlendColor(GLfloat red, GLfloat green, GLfloat blue,
                                GLfloat alpha)
{
  glad_glBlendColor(red, green, blue, alpha);
}
/**
 * glBlendEquation — specify the equation used for both the RGB blend equation
 * and the Alpha blend equation
 *
 * @param [buf] for glBlendEquationi, specifies the index of the draw buffer
 * for which to set the blend equation.
 *
 * @param [mode] specifies how source and destination colors are combined. It
 * must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN,
 * GL_MAX.
 */
static inline void glBlendEquation(GLenum mode) { glad_glBlendEquation(mode); }
/**
 * glBlendEquation — specify the equation used for both the RGB blend equation
 * and the Alpha blend equation
 *
 * @param [buf] for glBlendEquationi, specifies the index of the draw buffer
 * for which to set the blend equation.
 *
 * @param [mode] specifies how source and destination colors are combined. It
 * must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN,
 * GL_MAX.
 */
static inline void glBlendEquationi(GLuint buf, GLenum mode)
{
  glad_glBlendEquationi(buf, mode);
}
/**
 * glBlendEquationSeparate — set the RGB blend equation and the alpha blend
 * equation separately
 *
 * @param [buf] for glBlendEquationSeparatei, specifies the index of the draw
 * buffer for which to set the blend equations.
 *
 * @param [modeRGB] specifies the RGB blend equation, how the red, green, and
 * blue components of the source and destination colors are combined. It must
 * be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
 *
 * @param [modeAlpha] specifies the alpha blend equation, how the alpha
 * component of the source and destination colors are combined. It must be
 * GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
 */
static inline void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
{
  glad_glBlendEquationSeparate(modeRGB, modeAlpha);
}
/**
 * glBlendEquationSeparate — set the RGB blend equation and the alpha blend
 * equation separately
 *
 * @param [buf] for glBlendEquationSeparatei, specifies the index of the draw
 * buffer for which to set the blend equations.
 *
 * @param [modeRGB] specifies the RGB blend equation, how the red, green, and
 * blue components of the source and destination colors are combined. It must
 * be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
 *
 * @param [modeAlpha] specifies the alpha blend equation, how the alpha
 * component of the source and destination colors are combined. It must be
 * GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
 */
static inline void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB,
                                            GLenum modeAlpha)
{
  glad_glBlendEquationSeparatei(buf, modeRGB, modeAlpha);
}
/**
 * glBlendFunc — specify pixel arithmetic
 *
 * @param [buf] For glBlendFunci, specifies the index of the draw buffer for
 * which to set the blend function.
 *
 * @param [sfactor] Specifies how the red, green, blue, and alpha source
 * blending factors are computed. The initial value is GL_ONE.
 *
 * @param [dfactor] Specifies how the red, green, blue, and alpha destination
 * blending factors are computed. The following symbolic constants are
 * accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR,
 * GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA,
 * GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR,
 * GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and
 * GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.
 */
static inline void glBlendFunc(GLenum sfactor, GLenum dfactor)
{
  glad_glBlendFunc(sfactor, dfactor);
}
/**
 * glBlendFunc — specify pixel arithmetic
 *
 * @param [buf] For glBlendFunci, specifies the index of the draw buffer for
 * which to set the blend function.
 *
 * @param [sfactor] Specifies how the red, green, blue, and alpha source
 * blending factors are computed. The initial value is GL_ONE.
 *
 * @param [dfactor] Specifies how the red, green, blue, and alpha destination
 * blending factors are computed. The following symbolic constants are
 * accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR,
 * GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA,
 * GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR,
 * GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and
 * GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.
 */
static inline void glBlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor)
{
  glad_glBlendFunci(buf, sfactor, dfactor);
}
/**
 * glBlendFuncSeparate — specify pixel arithmetic for RGB and alpha components
 * separately
 *
 * @param [buf] For glBlendFuncSeparatei, specifies the index of the draw
 * buffer for which to set the blend functions.
 *
 * @param [srcRGB] Specifies how the red, green, and blue blending factors are
 * computed. The initial value is GL_ONE.
 *
 * @param [dstRGB] Specifies how the red, green, and blue destination blending
 * factors are computed. The initial value is GL_ZERO.
 *
 * @param [srcAlpha] Specified how the alpha source blending factor is
 * computed. The initial value is GL_ONE.
 *
 * @param [dstAlpha] Specified how the alpha destination blending factor is
 * computed. The initial value is GL_ZERO.
 */
static inline void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB,
                                       GLenum srcAlpha, GLenum dstAlpha)
{
  glad_glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
}
/**
 * glBlendFuncSeparate — specify pixel arithmetic for RGB and alpha components
 * separately
 *
 * @param [buf] For glBlendFuncSeparatei, specifies the index of the draw
 * buffer for which to set the blend functions.
 *
 * @param [srcRGB] Specifies how the red, green, and blue blending factors are
 * computed. The initial value is GL_ONE.
 *
 * @param [dstRGB] Specifies how the red, green, and blue destination blending
 * factors are computed. The initial value is GL_ZERO.
 *
 * @param [srcAlpha] Specified how the alpha source blending factor is
 * computed. The initial value is GL_ONE.
 *
 * @param [dstAlpha] Specified how the alpha destination blending factor is
 * computed. The initial value is GL_ZERO.
 */
static inline void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB,
                                        GLenum dstRGB, GLenum srcAlpha,
                                        GLenum dstAlpha)
{
  glad_glBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}
/**
 * glBlitFramebuffer, glBlitNamedFramebuffer — copy a block of pixels from one
 * framebuffer object to another
 *
 * @param [readFramebuffer] Specifies the name of the source framebuffer
 * object for glBlitNamedFramebuffer.
 *
 * @param [drawFramebuffer] Specifies the name of the destination framebuffer
 * object for glBlitNamedFramebuffer.
 *
 * @param [srcX0, srcY0, srcX1, srcY1] Specify the bounds of the source
 * rectangle within the read buffer of the read framebuffer.
 *
 * @param [dstX0, dstY0, dstX1, dstY1] Specify the bounds of the destination
 * rectangle within the write buffer of the write framebuffer.
 *
 * @param [mask] The bitwise OR of the flags indicating which buffers are to
 * be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT
 * and GL_STENCIL_BUFFER_BIT.
 *
 * @param [filter] Specifies the interpolation to be applied if the image is
 * stretched. Must be GL_NEAREST or GL_LINEAR.
 */
static inline void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1,
                                     GLint srcY1, GLint dstX0, GLint dstY0,
                                     GLint dstX1, GLint dstY1, GLbitfield mask,
                                     GLenum filter)
{
  glad_glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1,
                         mask, filter);
}
/**
 * glBlitFramebuffer, glBlitNamedFramebuffer — copy a block of pixels from one
 * framebuffer object to another
 *
 * @param [readFramebuffer] Specifies the name of the source framebuffer
 * object for glBlitNamedFramebuffer.
 *
 * @param [drawFramebuffer] Specifies the name of the destination framebuffer
 * object for glBlitNamedFramebuffer.
 *
 * @param [srcX0, srcY0, srcX1, srcY1] Specify the bounds of the source
 * rectangle within the read buffer of the read framebuffer.
 *
 * @param [dstX0, dstY0, dstX1, dstY1] Specify the bounds of the destination
 * rectangle within the write buffer of the write framebuffer.
 *
 * @param [mask] The bitwise OR of the flags indicating which buffers are to
 * be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT
 * and GL_STENCIL_BUFFER_BIT.
 *
 * @param [filter] Specifies the interpolation to be applied if the image is
 * stretched. Must be GL_NEAREST or GL_LINEAR.
 */
static inline void glBlitNamedFramebuffer(GLuint readFramebuffer,
                                          GLuint drawFramebuffer, GLint srcX0,
                                          GLint srcY0, GLint srcX1, GLint srcY1,
                                          GLint dstX0, GLint dstY0, GLint dstX1,
                                          GLint dstY1, GLbitfield mask,
                                          GLenum filter)
{
  glad_glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0,
                              srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask,
                              filter);
}
/**
 * glBufferData, glNamedBufferData — creates and initializes a buffer object's
 data store
 *
 * @param [target] Specifies the target to which the buffer object is bound
 for glBufferData, which must be one of the buffer binding targets in the
 following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 glNamedBufferData function.
 *
 * @param [size] Specifies the size in bytes of the buffer object's new data
 store.
 *
 * @param [data] Specifies a pointer to data that will be copied into the data
 store for initialization, or NULL if no data is to be copied.
 *
 * @param [usage] Specifies the expected usage pattern of the data store. The
 symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY,
 GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW,
 GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
 */
static inline void glBufferData(GLenum target, GLsizeiptr size,
                                const GLvoid *data, GLenum usage)
{
  glad_glBufferData(target, size, data, usage);
}
/**
 * glBufferData, glNamedBufferData — creates and initializes a buffer object's
 data store
 *
 * @param [target] Specifies the target to which the buffer object is bound
 for glBufferData, which must be one of the buffer binding targets in the
 following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 glNamedBufferData function.
 *
 * @param [size] Specifies the size in bytes of the buffer object's new data
 store.
 *
 * @param [data] Specifies a pointer to data that will be copied into the data
 store for initialization, or NULL if no data is to be copied.
 *
 * @param [usage] Specifies the expected usage pattern of the data store. The
 symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY,
 GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW,
 GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
 */
static inline void glNamedBufferData(GLuint buffer, GLsizeiptr size,
                                     const void *data, GLenum usage)
{
  glad_glNamedBufferData(buffer, size, data, usage);
}
/**
 * glBufferStorage, glNamedBufferStorage — creates and initializes a buffer
 object's immutable data store
 *
 * @param [target] Specifies the target to which the buffer object is bound
 for glBufferStorage, which must be one of the buffer binding targets in the
 following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 glNamedBufferStorage function.
 *
 * @param [size] Specifies the size in bytes of the buffer object's new data
 store.
 *
 * @param [data] Specifies a pointer to data that will be copied into the data
 store for initialization, or NULL if no data is to be copied.
 *
 * @param [flags] Specifies the intended usage of the buffer's data store.
 Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT,
 GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT,
 and GL_CLIENT_STORAGE_BIT.
 */
static inline void glBufferStorage(GLenum target, GLsizeiptr size,
                                   const GLvoid *data, GLbitfield flags)
{
  glad_glBufferStorage(target, size, data, flags);
}
/**
 * glBufferStorage, glNamedBufferStorage — creates and initializes a buffer
 object's immutable data store
 *
 * @param [target] Specifies the target to which the buffer object is bound
 for glBufferStorage, which must be one of the buffer binding targets in the
 following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 glNamedBufferStorage function.
 *
 * @param [size] Specifies the size in bytes of the buffer object's new data
 store.
 *
 * @param [data] Specifies a pointer to data that will be copied into the data
 store for initialization, or NULL if no data is to be copied.
 *
 * @param [flags] Specifies the intended usage of the buffer's data store.
 Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT,
 GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT,
 and GL_CLIENT_STORAGE_BIT.
 */
static inline void glNamedBufferStorage(GLuint buffer, GLsizeiptr size,
                                        const void *data, GLbitfield flags)
{
  glad_glNamedBufferStorage(buffer, size, data, flags);
}
/**
 * glBufferSubData, glNamedBufferSubData — updates a subset of a buffer
 * object's data store
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glBufferSubData, which must be one of the buffer binding targets in the
 * following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glNamedBufferSubData.
 *
 * @param [offset] Specifies the offset into the buffer object's data store
 * where data replacement will begin, measured in bytes.
 *
 * @param [size] Specifies the size in bytes of the data store region being
 * replaced.
 *
 * @param [data] Specifies a pointer to the new data that will be copied into
 * the data store.
 */
static inline void glBufferSubData(GLenum target, GLintptr offset,
                                   GLsizeiptr size, const GLvoid *data)
{
  glad_glBufferSubData(target, offset, size, data);
}
/**
 * glBufferSubData, glNamedBufferSubData — updates a subset of a buffer
 * object's data store
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glBufferSubData, which must be one of the buffer binding targets in the
 * following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glNamedBufferSubData.
 *
 * @param [offset] Specifies the offset into the buffer object's data store
 * where data replacement will begin, measured in bytes.
 *
 * @param [size] Specifies the size in bytes of the data store region being
 * replaced.
 *
 * @param [data] Specifies a pointer to the new data that will be copied into
 * the data store.
 */
static inline void glNamedBufferSubData(GLuint buffer, GLintptr offset,
                                        GLsizei size, const void *data)
{
  glad_glNamedBufferSubData(buffer, offset, size, data);
}
/**
 * glCheckFramebufferStatus, glCheckNamedFramebufferStatus — check the
 * completeness status of a framebuffer
 *
 * @param [target] Specify the target to which the framebuffer is bound for
 * glCheckFramebufferStatus, and the target against which framebuffer
 * completeness of framebuffer is checked for glCheckNamedFramebufferStatus.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glCheckNamedFramebufferStatus
 */
static inline GLenum glCheckFramebufferStatus(GLenum target)
{
  return glad_glCheckFramebufferStatus(target);
}
/**
 * glCheckFramebufferStatus, glCheckNamedFramebufferStatus — check the
 * completeness status of a framebuffer
 *
 * @param [target] Specify the target to which the framebuffer is bound for
 * glCheckFramebufferStatus, and the target against which framebuffer
 * completeness of framebuffer is checked for glCheckNamedFramebufferStatus.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glCheckNamedFramebufferStatus
 */
static inline GLenum glCheckNamedFramebufferStatus(GLuint framebuffer,
                                                   GLenum target)
{
  return glad_glCheckNamedFramebufferStatus(framebuffer, target);
}
/**
 * glClampColor — specify whether data read via glReadPixels should be clamped
 *
 * @param [target] Target for color clamping. target must be
 * GL_CLAMP_READ_COLOR.
 *
 * @param [clamp] Specifies whether to apply color clamping. clamp must be
 * GL_TRUE or GL_FALSE.
 */
static inline void glClampColor(GLenum target, GLenum clamp)
{
  glad_glClampColor(target, clamp);
}
/**
 * glClear — clear buffers to preset values
 *
 * @param [mask] Bitwise OR of masks that indicate the buffers to be cleared.
 * The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and
 * GL_STENCIL_BUFFER_BIT.
 */
static inline void glClear(GLbitfield mask) { glad_glClear(mask); }
/**
 * glClearBuffer — clear individual buffers of a framebuffer
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glClearNamedFramebuffer*.
 *
 * @param [buffer] Specify the buffer to clear.
 *
 * @param [drawbuffer] Specify a particular draw buffer to clear.
 *
 * @param [value] A pointer to the value or values to clear the buffer to.
 *
 * @param [depth] The value to clear the depth buffer to.
 *
 * @param [stencil] The value to clear the stencil buffer to.
 */
static inline void glClearBufferiv(GLenum buffer, GLint drawbuffer,
                                   const GLint *value)
{
  glad_glClearBufferiv(buffer, drawbuffer, value);
}
/**
 * glClearBuffer — clear individual buffers of a framebuffer
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glClearNamedFramebuffer*.
 *
 * @param [buffer] Specify the buffer to clear.
 *
 * @param [drawbuffer] Specify a particular draw buffer to clear.
 *
 * @param [value] A pointer to the value or values to clear the buffer to.
 *
 * @param [depth] The value to clear the depth buffer to.
 *
 * @param [stencil] The value to clear the stencil buffer to.
 */
static inline void glClearBufferuiv(GLenum buffer, GLint drawbuffer,
                                    const GLuint *value)
{
  glad_glClearBufferuiv(buffer, drawbuffer, value);
}
/**
 * glClearBuffer — clear individual buffers of a framebuffer
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glClearNamedFramebuffer*.
 *
 * @param [buffer] Specify the buffer to clear.
 *
 * @param [drawbuffer] Specify a particular draw buffer to clear.
 *
 * @param [value] A pointer to the value or values to clear the buffer to.
 *
 * @param [depth] The value to clear the depth buffer to.
 *
 * @param [stencil] The value to clear the stencil buffer to.
 */
static inline void glClearBufferfv(GLenum buffer, GLint drawbuffer,
                                   const GLfloat *value)
{
  glad_glClearBufferfv(buffer, drawbuffer, value);
}
/**
 * glClearBuffer — clear individual buffers of a framebuffer
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glClearNamedFramebuffer*.
 *
 * @param [buffer] Specify the buffer to clear.
 *
 * @param [drawbuffer] Specify a particular draw buffer to clear.
 *
 * @param [value] A pointer to the value or values to clear the buffer to.
 *
 * @param [depth] The value to clear the depth buffer to.
 *
 * @param [stencil] The value to clear the stencil buffer to.
 */
static inline void glClearBufferfi(GLenum buffer, GLint drawbuffer,
                                   GLfloat depth, GLint stencil)
{
  glad_glClearBufferfi(buffer, drawbuffer, depth, stencil);
}
/**
 * glClearBuffer — clear individual buffers of a framebuffer
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glClearNamedFramebuffer*.
 *
 * @param [buffer] Specify the buffer to clear.
 *
 * @param [drawbuffer] Specify a particular draw buffer to clear.
 *
 * @param [value] A pointer to the value or values to clear the buffer to.
 *
 * @param [depth] The value to clear the depth buffer to.
 *
 * @param [stencil] The value to clear the stencil buffer to.
 */
static inline void glClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer,
                                             GLint drawbuffer,
                                             const GLint *value)
{
  glad_glClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value);
}
/**
 * glClearBuffer — clear individual buffers of a framebuffer
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glClearNamedFramebuffer*.
 *
 * @param [buffer] Specify the buffer to clear.
 *
 * @param [drawbuffer] Specify a particular draw buffer to clear.
 *
 * @param [value] A pointer to the value or values to clear the buffer to.
 *
 * @param [depth] The value to clear the depth buffer to.
 *
 * @param [stencil] The value to clear the stencil buffer to.
 */
static inline void glClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer,
                                              GLint drawbuffer,
                                              const GLuint *value)
{
  glad_glClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value);
}
/**
 * glClearBuffer — clear individual buffers of a framebuffer
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glClearNamedFramebuffer*.
 *
 * @param [buffer] Specify the buffer to clear.
 *
 * @param [drawbuffer] Specify a particular draw buffer to clear.
 *
 * @param [value] A pointer to the value or values to clear the buffer to.
 *
 * @param [depth] The value to clear the depth buffer to.
 *
 * @param [stencil] The value to clear the stencil buffer to.
 */
static inline void glClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer,
                                             GLint drawbuffer,
                                             const GLfloat *value)
{
  glad_glClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value);
}
/**
 * glClearBuffer — clear individual buffers of a framebuffer
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glClearNamedFramebuffer*.
 *
 * @param [buffer] Specify the buffer to clear.
 *
 * @param [drawbuffer] Specify a particular draw buffer to clear.
 *
 * @param [value] A pointer to the value or values to clear the buffer to.
 *
 * @param [depth] The value to clear the depth buffer to.
 *
 * @param [stencil] The value to clear the stencil buffer to.
 */
static inline void glClearNamedFramebufferfi(GLuint framebuffer, GLenum buffer,
                                             GLint drawbuffer,
                                             const GLfloat depth, GLint stencil)
{
  glad_glClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth,
                                 stencil);
}
/**
 * glClearBufferData, glClearNamedBufferData — fill a buffer object's data
 * store with a fixed value
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glClearBufferData, which must must be one of the buffer binding targets
 * in the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glClearNamedBufferData.
 *
 * @param [internalformat] The internal format with which the data will be
 * stored in the buffer object.
 *
 * @param [format] The format of the data in memory addressed by data.
 *
 * @param [type] The type of the data in memory addressed by data.
 *
 * @param [data] The address of a memory location storing the data to be
 * replicated into the buffer's data store.
 */
static inline void glClearBufferData(GLenum target, GLenum internalformat,
                                     GLenum format, GLenum type,
                                     const void *data)
{
  glad_glClearBufferData(target, internalformat, format, type, data);
}
/**
 * glClearBufferData, glClearNamedBufferData — fill a buffer object's data
 * store with a fixed value
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glClearBufferData, which must must be one of the buffer binding targets
 * in the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glClearNamedBufferData.
 *
 * @param [internalformat] The internal format with which the data will be
 * stored in the buffer object.
 *
 * @param [format] The format of the data in memory addressed by data.
 *
 * @param [type] The type of the data in memory addressed by data.
 *
 * @param [data] The address of a memory location storing the data to be
 * replicated into the buffer's data store.
 */
static inline void glClearNamedBufferData(GLuint buffer, GLenum internalformat,
                                          GLenum format, GLenum type,
                                          const void *data)
{
  glad_glClearNamedBufferData(buffer, internalformat, format, type, data);
}
/**
 * glClearBufferSubData, glClearNamedBufferSubData — fill all or part of
 * buffer object's data store with a fixed value
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glClearBufferSubData, which must be one of the buffer binding targets
 * in the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glClearNamedBufferSubData.
 *
 * @param [internalformat] The internal format with which the data will be
 * stored in the buffer object.
 *
 * @param [offset] The offset in basic machine units into the buffer object's
 * data store at which to start filling.
 *
 * @param [size] The size in basic machine units of the range of the data
 * store to fill.
 *
 * @param [format] The format of the data in memory addressed by data.
 *
 * @param [type] The type of the data in memory addressed by data.
 *
 * @param [data] The address of a memory location storing the data to be
 * replicated into the buffer's data store.
 */
static inline void glClearBufferSubData(GLenum target, GLenum internalformat,
                                        GLintptr offset, GLsizeiptr size,
                                        GLenum format, GLenum type,
                                        const void *data)
{
  glad_glClearBufferSubData(target, internalformat, offset, size, format, type,
                            data);
}
/**
 * glClearBufferSubData, glClearNamedBufferSubData — fill all or part of
 * buffer object's data store with a fixed value
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glClearBufferSubData, which must be one of the buffer binding targets
 * in the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glClearNamedBufferSubData.
 *
 * @param [internalformat] The internal format with which the data will be
 * stored in the buffer object.
 *
 * @param [offset] The offset in basic machine units into the buffer object's
 * data store at which to start filling.
 *
 * @param [size] The size in basic machine units of the range of the data
 * store to fill.
 *
 * @param [format] The format of the data in memory addressed by data.
 *
 * @param [type] The type of the data in memory addressed by data.
 *
 * @param [data] The address of a memory location storing the data to be
 * replicated into the buffer's data store.
 */
static inline void glClearNamedBufferSubData(GLuint buffer,
                                             GLenum internalformat,
                                             GLintptr offset, GLsizei size,
                                             GLenum format, GLenum type,
                                             const void *data)
{
  glad_glClearNamedBufferSubData(buffer, internalformat, offset, size, format,
                                 type, data);
}
/**
 * glClearColor — specify clear values for the color buffers
 *
 * @param [red, green, blue, alpha] Specify the red, green, blue, and alpha
 * values used when the color buffers are cleared. The initial values are all
 * 0.
 */
static inline void glClearColor(GLfloat red, GLfloat green, GLfloat blue,
                                GLfloat alpha)
{
  glad_glClearColor(red, green, blue, alpha);
}
/**
 * glClearDepth — specify the clear value for the depth buffer
 *
 * @param [depth] Specifies the depth value used when the depth buffer is
 * cleared. The initial value is 1.
 */
static inline void glClearDepth(GLdouble depth) { glad_glClearDepth(depth); }
/**
 * glClearDepth — specify the clear value for the depth buffer
 *
 * @param [depth] Specifies the depth value used when the depth buffer is
 * cleared. The initial value is 1.
 */
static inline void glClearDepthf(GLfloat depth) { glad_glClearDepthf(depth); }
/**
 * glClearStencil — specify the clear value for the stencil buffer
 *
 * @param [s] Specifies the index used when the stencil buffer is cleared. The
 * initial value is 0.
 */
static inline void glClearStencil(GLint s) { glad_glClearStencil(s); }
/**
 * glClearTexImage — fills all a texture image with a constant value
 *
 * @param [texture] The name of an existing texture object containing the
 * image to be cleared.
 *
 * @param [level] The level of texture containing the region to be cleared.
 *
 * @param [format] The format of the data whose address in memory is given by
 * data.
 *
 * @param [type] The type of the data whose address in memory is given by
 * data.
 *
 * @param [data] The address in memory of the data to be used to clear the
 * specified region.
 */
static inline void glClearTexImage(GLuint texture, GLint level, GLenum format,
                                   GLenum type, const void *data)
{
  glad_glClearTexImage(texture, level, format, type, data);
}
/**
 * glClearTexSubImage — fills all or part of a texture image with a constant
 * value
 *
 * @param [texture] The name of an existing texture object containing the
 * image to be cleared.
 *
 * @param [level] The level of texture containing the region to be cleared.
 *
 * @param [xoffset] The coordinate of the left edge of the region to be
 * cleared.
 *
 * @param [yoffset] The coordinate of the lower edge of the region to be
 * cleared.
 *
 * @param [zoffset] The coordinate of the front of the region to be cleared.
 *
 * @param [width] The width of the region to be cleared.
 *
 * @param [height] The height of the region to be cleared.
 *
 * @param [depth] The depth of the region to be cleared.
 *
 * @param [format] The format of the data whose address in memory is given by
 * data.
 *
 * @param [type] The type of the data whose address in memory is given by
 * data.
 *
 * @param [data] The address in memory of the data to be used to clear the
 * specified region.
 */
static inline void
glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset,
                   GLint zoffset, GLsizei width, GLsizei height, GLsizei depth,
                   GLenum format, GLenum type, const void *data)
{
  glad_glClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width,
                          height, depth, format, type, data);
}
/**
 * glClientWaitSync — block and wait for a sync object to become signaled
 *
 * @param [sync] The sync object whose status to wait on.
 *
 * @param [flags] A bitfield controlling the command flushing behavior. flags
 * may be GL_SYNC_FLUSH_COMMANDS_BIT.
 *
 * @param [timeout] The timeout, specified in nanoseconds, for which the
 * implementation should wait for sync to become signaled.
 */
static inline GLenum glClientWaitSync(GLsync sync, GLbitfield flags,
                                      GLuint64 timeout)
{
  return glad_glClientWaitSync(sync, flags, timeout);
}
/**
 * glClipControl — control clip coordinate to window coordinate behavior
 *
 * @param [origin] Specifies the clip control origin. Must be one of
 * GL_LOWER_LEFT or GL_UPPER_LEFT.
 *
 * @param [depth] Specifies the clip control depth mode. Must be one of
 * GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE.
 */
static inline void glClipControl(GLenum origin, GLenum depth)
{
  glad_glClipControl(origin, depth);
}
/**
 * glColorMask, glColorMaski — enable and disable writing of frame buffer
 * color components
 *
 * @param [buf] For glColorMaski, specifies the index of the draw buffer whose
 * color mask to set.
 *
 * @param [red, green, blue, alpha] Specify whether red, green, blue, and
 * alpha are to be written into the frame buffer. The initial values are all
 * GL_TRUE, indicating that the color components are written.
 */
static inline void glColorMask(GLboolean red, GLboolean green, GLboolean blue,
                               GLboolean alpha)
{
  glad_glColorMask(red, green, blue, alpha);
}
/**
 * glColorMask, glColorMaski — enable and disable writing of frame buffer
 * color components
 *
 * @param [buf] For glColorMaski, specifies the index of the draw buffer whose
 * color mask to set.
 *
 * @param [red, green, blue, alpha] Specify whether red, green, blue, and
 * alpha are to be written into the frame buffer. The initial values are all
 * GL_TRUE, indicating that the color components are written.
 */
static inline void glColorMaski(GLuint buf, GLboolean red, GLboolean green,
                                GLboolean blue, GLboolean alpha)
{
  glad_glColorMaski(buf, red, green, blue, alpha);
}
/**
 * glCompileShader — Compiles a shader object
 *
 * @param [shader] Specifies the shader object to be compiled.
 */
static inline void glCompileShader(GLuint shader)
{
  glad_glCompileShader(shader);
}
/**
 * glCompressedTexImage1D — specify a one-dimensional texture image in a
 * compressed format
 *
 * @param [target] Specifies the target texture. Must be GL_TEXTURE_1D or
 * GL_PROXY_TEXTURE_1D.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [internalformat] Specifies the format of the compressed image data
 * stored at address data.
 *
 * @param [width] Specifies the width of the texture image. All
 * implementations support texture images that are at least 64 texels wide.
 * The height of the 1D texture image is 1.
 *
 * @param [border] This value must be 0.
 *
 * @param [imageSize] Specifies the number of unsigned bytes of image data
 * starting at the address specified by data.
 *
 * @param [data] Specifies a pointer to the compressed image data in memory.
 */
static inline void glCompressedTexImage1D(GLenum target, GLint level,
                                          GLenum internalformat, GLsizei width,
                                          GLint border, GLsizei imageSize,
                                          const GLvoid *data)
{
  glad_glCompressedTexImage1D(target, level, internalformat, width, border,
                              imageSize, data);
}
/**
 * glCompressedTexImage2D — specify a two-dimensional texture image in a
 * compressed format
 *
 * @param [target] Specifies the target texture. Must be GL_TEXTURE_2D,
 * GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
 * GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
 * GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or
 * GL_PROXY_TEXTURE_CUBE_MAP.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [internalformat] Specifies the format of the compressed image data
 * stored at address data.
 *
 * @param [width] Specifies the width of the texture image. All
 * implementations support 2D texture and cube map texture images that are at
 * least 16384 texels wide.
 *
 * @param [height] Specifies the height of the texture image. All
 * implementations support 2D texture and cube map texture images that are at
 * least 16384 texels high.
 *
 * @param [border] This value must be 0.
 *
 * @param [imageSize] Specifies the number of unsigned bytes of image data
 * starting at the address specified by data.
 *
 * @param [data] Specifies a pointer to the compressed image data in memory.
 */
static inline void glCompressedTexImage2D(GLenum target, GLint level,
                                          GLenum internalformat, GLsizei width,
                                          GLsizei height, GLint border,
                                          GLsizei imageSize, const GLvoid *data)
{
  glad_glCompressedTexImage2D(target, level, internalformat, width, height,
                              border, imageSize, data);
}
/**
 * glCompressedTexImage3D — specify a three-dimensional texture image in a
 * compressed format
 *
 * @param [target] Specifies the target texture. Must be GL_TEXTURE_3D,
 * GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [internalformat] Specifies the format of the compressed image data
 * stored at address data.
 *
 * @param [width] Specifies the width of the texture image. All
 * implementations support 3D texture images that are at least 16 texels wide.
 *
 * @param [height] Specifies the height of the texture image. All
 * implementations support 3D texture images that are at least 16 texels high.
 *
 * @param [depth] Specifies the depth of the texture image. All
 * implementations support 3D texture images that are at least 16 texels deep.
 *
 * @param [border] This value must be 0.
 *
 * @param [imageSize] Specifies the number of unsigned bytes of image data
 * starting at the address specified by data.
 *
 * @param [data] Specifies a pointer to the compressed image data in memory.
 */
static inline void glCompressedTexImage3D(GLenum target, GLint level,
                                          GLenum internalformat, GLsizei width,
                                          GLsizei height, GLsizei depth,
                                          GLint border, GLsizei imageSize,
                                          const GLvoid *data)
{
  glad_glCompressedTexImage3D(target, level, internalformat, width, height,
                              depth, border, imageSize, data);
}
/**
 * glCompressedTexSubImage1D, glCompressedTextureSubImage1D — specify a
 one-dimensional texture subimage in a compressed format
 *
 * @param [target] Specifies the target, to which the texture is bound, for
 glCompressedTexSubImage1D function. Must be GL_TEXTURE_1D.
 *
 * @param [texture] Specifies the texture object name for
 glCompressedTextureSubImage1D function.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 texture array.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [format] Specifies the format of the compressed image data stored at
 address data.
 *
 * @param [imageSize] Specifies the number of unsigned bytes of image data
 starting at the address specified by data.
 *
 * @param [data] Specifies a pointer to the compressed image data in memory.
 */
static inline void glCompressedTexSubImage1D(GLenum target, GLint level,
                                             GLint xoffset, GLsizei width,
                                             GLenum format, GLsizei imageSize,
                                             const GLvoid *data)
{
  glad_glCompressedTexSubImage1D(target, level, xoffset, width, format,
                                 imageSize, data);
}
/**
 * glCompressedTexSubImage1D, glCompressedTextureSubImage1D — specify a
 one-dimensional texture subimage in a compressed format
 *
 * @param [target] Specifies the target, to which the texture is bound, for
 glCompressedTexSubImage1D function. Must be GL_TEXTURE_1D.
 *
 * @param [texture] Specifies the texture object name for
 glCompressedTextureSubImage1D function.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 texture array.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [format] Specifies the format of the compressed image data stored at
 address data.
 *
 * @param [imageSize] Specifies the number of unsigned bytes of image data
 starting at the address specified by data.
 *
 * @param [data] Specifies a pointer to the compressed image data in memory.
 */
static inline void glCompressedTextureSubImage1D(GLuint texture, GLint level,
                                                 GLint xoffset, GLsizei width,
                                                 GLenum format,
                                                 GLsizei imageSize,
                                                 const void *data)
{
  glad_glCompressedTextureSubImage1D(texture, level, xoffset, width, format,
                                     imageSize, data);
}
/**
 * glCompressedTexSubImage2D, glCompressedTextureSubImage2D — specify a
 * two-dimensional texture subimage in a compressed format
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glCompressedTexSubImage2D function. Must be GL_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
 *
 * @param [texture] Specifies the texture object name for
 * glCompressedTextureSubImage2D function.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 * texture array.
 *
 * @param [yoffset] Specifies a texel offset in the y direction within the
 * texture array.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [height] Specifies the height of the texture subimage.
 *
 * @param [format] Specifies the format of the compressed image data stored at
 * address data.
 *
 * @param [imageSize] Specifies the number of unsigned bytes of image data
 * starting at the address specified by data.
 *
 * @param [data] Specifies a pointer to the compressed image data in memory.
 */
static inline void glCompressedTexSubImage2D(GLenum target, GLint level,
                                             GLint xoffset, GLint yoffset,
                                             GLsizei width, GLsizei height,
                                             GLenum format, GLsizei imageSize,
                                             const GLvoid *data)
{
  glad_glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height,
                                 format, imageSize, data);
}
/**
 * glCompressedTexSubImage2D, glCompressedTextureSubImage2D — specify a
 * two-dimensional texture subimage in a compressed format
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glCompressedTexSubImage2D function. Must be GL_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
 *
 * @param [texture] Specifies the texture object name for
 * glCompressedTextureSubImage2D function.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 * texture array.
 *
 * @param [yoffset] Specifies a texel offset in the y direction within the
 * texture array.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [height] Specifies the height of the texture subimage.
 *
 * @param [format] Specifies the format of the compressed image data stored at
 * address data.
 *
 * @param [imageSize] Specifies the number of unsigned bytes of image data
 * starting at the address specified by data.
 *
 * @param [data] Specifies a pointer to the compressed image data in memory.
 */
static inline void glCompressedTextureSubImage2D(
    GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width,
    GLsizei height, GLenum format, GLsizei imageSize, const void *data)
{
  glad_glCompressedTextureSubImage2D(texture, level, xoffset, yoffset, width,
                                     height, format, imageSize, data);
}
/**
 * glCompressedTexSubImage3D, glCompressedTextureSubImage3D — specify a
 * three-dimensional texture subimage in a compressed format
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glCompressedTexSubImage3D function. Must be GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP_ARRAY.
 *
 * @param [texture] Specifies the texture object name for
 * glCompressedTextureSubImage3D function.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 * texture array.
 *
 * @param [yoffset] Specifies a texel offset in the y direction within the
 * texture array.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [height] Specifies the height of the texture subimage.
 *
 * @param [depth] Specifies the depth of the texture subimage.
 *
 * @param [format] Specifies the format of the compressed image data stored at
 * address data.
 *
 * @param [imageSize] Specifies the number of unsigned bytes of image data
 * starting at the address specified by data.
 *
 * @param [data] Specifies a pointer to the compressed image data in memory.
 */
static inline void glCompressedTexSubImage3D(GLenum target, GLint level,
                                             GLint xoffset, GLint yoffset,
                                             GLint zoffset, GLsizei width,
                                             GLsizei height, GLsizei depth,
                                             GLenum format, GLsizei imageSize,
                                             const GLvoid *data)
{
  glad_glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset,
                                 width, height, depth, format, imageSize, data);
}
/**
 * glCompressedTexSubImage3D, glCompressedTextureSubImage3D — specify a
 * three-dimensional texture subimage in a compressed format
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glCompressedTexSubImage3D function. Must be GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP_ARRAY.
 *
 * @param [texture] Specifies the texture object name for
 * glCompressedTextureSubImage3D function.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 * texture array.
 *
 * @param [yoffset] Specifies a texel offset in the y direction within the
 * texture array.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [height] Specifies the height of the texture subimage.
 *
 * @param [depth] Specifies the depth of the texture subimage.
 *
 * @param [format] Specifies the format of the compressed image data stored at
 * address data.
 *
 * @param [imageSize] Specifies the number of unsigned bytes of image data
 * starting at the address specified by data.
 *
 * @param [data] Specifies a pointer to the compressed image data in memory.
 */
static inline void
glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset,
                              GLint yoffset, GLint zoffset, GLsizei width,
                              GLsizei height, GLsizei depth, GLenum format,
                              GLsizei imageSize, const void *data)
{
  glad_glCompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset,
                                     width, height, depth, format, imageSize,
                                     data);
}
/**
 * glCopyBufferSubData, glCopyNamedBufferSubData — copy all or part of the
 * data store of a buffer object to the data store of another buffer object
 *
 * @param [readTarget] Specifies the target to which the source buffer object
 * is bound for glCopyBufferSubData
 *
 * @param [writeTarget] Specifies the target to which the destination buffer
 * object is bound for glCopyBufferSubData.
 *
 * @param [readBuffer] Specifies the name of the source buffer object for
 * glCopyNamedBufferSubData.
 *
 * @param [writeBuffer] Specifies the name of the destination buffer object
 * for glCopyNamedBufferSubData.
 *
 * @param [readOffset] Specifies the offset, in basic machine units, within
 * the data store of the source buffer object at which data will be read.
 *
 * @param [writeOffset] Specifies the offset, in basic machine units, within
 * the data store of the destination buffer object at which data will be
 * written.
 *
 * @param [size] Specifies the size, in basic machine units, of the data to be
 * copied from the source buffer object to the destination buffer object.
 */
static inline void glCopyBufferSubData(GLenum readTarget, GLenum writeTarget,
                                       GLintptr readOffset,
                                       GLintptr writeOffset, GLsizeiptr size)
{
  glad_glCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset,
                           size);
}
/**
 * glCopyBufferSubData, glCopyNamedBufferSubData — copy all or part of the
 * data store of a buffer object to the data store of another buffer object
 *
 * @param [readTarget] Specifies the target to which the source buffer object
 * is bound for glCopyBufferSubData
 *
 * @param [writeTarget] Specifies the target to which the destination buffer
 * object is bound for glCopyBufferSubData.
 *
 * @param [readBuffer] Specifies the name of the source buffer object for
 * glCopyNamedBufferSubData.
 *
 * @param [writeBuffer] Specifies the name of the destination buffer object
 * for glCopyNamedBufferSubData.
 *
 * @param [readOffset] Specifies the offset, in basic machine units, within
 * the data store of the source buffer object at which data will be read.
 *
 * @param [writeOffset] Specifies the offset, in basic machine units, within
 * the data store of the destination buffer object at which data will be
 * written.
 *
 * @param [size] Specifies the size, in basic machine units, of the data to be
 * copied from the source buffer object to the destination buffer object.
 */
static inline void glCopyNamedBufferSubData(GLuint readBuffer,
                                            GLuint writeBuffer,
                                            GLintptr readOffset,
                                            GLintptr writeOffset, GLsizei size)
{
  glad_glCopyNamedBufferSubData(readBuffer, writeBuffer, readOffset,
                                writeOffset, size);
}
/**
 * glCopyImageSubData — perform a raw data copy between two images
 *
 * @param [srcName] The name of a texture or renderbuffer object from which to
 * copy.
 *
 * @param [srcTarget] The target representing the namespace of the source name
 * srcName.
 *
 * @param [srcLevel] The mipmap level to read from the source.
 *
 * @param [srcX] The X coordinate of the left edge of the souce region to
 * copy.
 *
 * @param [srcY] The Y coordinate of the top edge of the souce region to copy.
 *
 * @param [srcZ] The Z coordinate of the near edge of the souce region to
 * copy.
 *
 * @param [dstName] The name of a texture or renderbuffer object to which to
 * copy.
 *
 * @param [dstTarget] The target representing the namespace of the destination
 * name dstName.
 *
 * @param [dstX] The X coordinate of the left edge of the destination region.
 *
 * @param [dstY] The Y coordinate of the top edge of the destination region.
 *
 * @param [dstZ] The Z coordinate of the near edge of the destination region.
 *
 * @param [srcWidth] The width of the region to be copied.
 *
 * @param [srcHeight] The height of the region to be copied.
 *
 * @param [srcDepth] The depth of the region to be copied.
 */
static inline void
glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX,
                   GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget,
                   GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ,
                   GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)
{
  glad_glCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ,
                          dstName, dstTarget, dstLevel, dstX, dstY, dstZ,
                          srcWidth, srcHeight, srcDepth);
}
/**
 * glCopyTexImage1D — copy pixels into a 1D texture image
 *
 * @param [target] Specifies the target texture. Must be GL_TEXTURE_1D.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [internalformat] Specifies the internal format of the texture. Must
 * be one of the following symbolic constants: GL_COMPRESSED_RED,
 * GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA.
 * GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT,
 * GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32,
 * GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5,
 * GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4,
 * GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8,
 * GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
 *
 * @param [x, y] Specify the window coordinates of the left corner of the row
 * of pixels to be copied.
 *
 * @param [width] Specifies the width of the texture image. The height of the
 * texture image is 1.
 *
 * @param [border] Must be 0.
 */
static inline void glCopyTexImage1D(GLenum target, GLint level,
                                    GLenum internalformat, GLint x, GLint y,
                                    GLsizei width, GLint border)
{
  glad_glCopyTexImage1D(target, level, internalformat, x, y, width, border);
}
/**
 * glCopyTexImage2D — copy pixels into a 2D texture image
 *
 * @param [target] Specifies the target texture. Must be GL_TEXTURE_2D,
 * GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
 * GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
 * GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [internalformat] Specifies the internal format of the texture. Must
 * be one of the following symbolic constants: GL_COMPRESSED_RED,
 * GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA.
 * GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT,
 * GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32,
 * GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5,
 * GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4,
 * GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8,
 * GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
 *
 * @param [x, y] Specify the window coordinates of the lower left corner of
 * the rectangular region of pixels to be copied.
 *
 * @param [width] Specifies the width of the texture image.
 *
 * @param [height] Specifies the height of the texture image.
 *
 * @param [border] Must be 0.
 */
static inline void glCopyTexImage2D(GLenum target, GLint level,
                                    GLenum internalformat, GLint x, GLint y,
                                    GLsizei width, GLsizei height, GLint border)
{
  glad_glCopyTexImage2D(target, level, internalformat, x, y, width, height,
                        border);
}
/**
 * glCopyTexSubImage1D, glCopyTextureSubImage1D — copy a one-dimensional
 * texture subimage
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glCopyTexSubImage1D function. Must be GL_TEXTURE_1D.
 *
 * @param [texture] Specifies the texture object name for
 * glCopyTextureSubImage1D function.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies the texel offset within the texture array.
 *
 * @param [x, y] Specify the window coordinates of the left corner of the row
 * of pixels to be copied.
 *
 * @param [width] Specifies the width of the texture subimage.
 */
static inline void glCopyTexSubImage1D(GLenum target, GLint level,
                                       GLint xoffset, GLint x, GLint y,
                                       GLsizei width)
{
  glad_glCopyTexSubImage1D(target, level, xoffset, x, y, width);
}
/**
 * glCopyTexSubImage1D, glCopyTextureSubImage1D — copy a one-dimensional
 * texture subimage
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glCopyTexSubImage1D function. Must be GL_TEXTURE_1D.
 *
 * @param [texture] Specifies the texture object name for
 * glCopyTextureSubImage1D function.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies the texel offset within the texture array.
 *
 * @param [x, y] Specify the window coordinates of the left corner of the row
 * of pixels to be copied.
 *
 * @param [width] Specifies the width of the texture subimage.
 */
static inline void glCopyTextureSubImage1D(GLuint texture, GLint level,
                                           GLint xoffset, GLint x, GLint y,
                                           GLsizei width)
{
  glad_glCopyTextureSubImage1D(texture, level, xoffset, x, y, width);
}
/**
 * glCopyTexSubImage2D, glCopyTextureSubImage2D — copy a two-dimensional
 * texture subimage
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glCopyTexSubImage2D function. Must be GL_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_RECTANGLE.
 *
 * @param [texture] Specifies the texture object name for
 * glCopyTextureSubImage2D function.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 * texture array.
 *
 * @param [yoffset] Specifies a texel offset in the y direction within the
 * texture array.
 *
 * @param [x, y] Specify the window coordinates of the lower left corner of
 * the rectangular region of pixels to be copied.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [height] Specifies the height of the texture subimage.
 */
static inline void glCopyTexSubImage2D(GLenum target, GLint level,
                                       GLint xoffset, GLint yoffset, GLint x,
                                       GLint y, GLsizei width, GLsizei height)
{
  glad_glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width,
                           height);
}
/**
 * glCopyTexSubImage2D, glCopyTextureSubImage2D — copy a two-dimensional
 * texture subimage
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glCopyTexSubImage2D function. Must be GL_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_RECTANGLE.
 *
 * @param [texture] Specifies the texture object name for
 * glCopyTextureSubImage2D function.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 * texture array.
 *
 * @param [yoffset] Specifies a texel offset in the y direction within the
 * texture array.
 *
 * @param [x, y] Specify the window coordinates of the lower left corner of
 * the rectangular region of pixels to be copied.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [height] Specifies the height of the texture subimage.
 */
static inline void glCopyTextureSubImage2D(GLuint texture, GLint level,
                                           GLint xoffset, GLint yoffset,
                                           GLint x, GLint y, GLsizei width,
                                           GLsizei height)
{
  glad_glCopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width,
                               height);
}
/**
 * glCopyTexSubImage3D, glCopyTextureSubImage3D — copy a three-dimensional
 * texture subimage
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glCopyTexSubImage3D function. Must be GL_TEXTURE_3D or
 * GL_TEXTURE_2D_ARRAY.
 *
 * @param [texture] Specifies the texture object name for
 * glCopyTextureSubImage3D function.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 * texture array.
 *
 * @param [yoffset] Specifies a texel offset in the y direction within the
 * texture array.
 *
 * @param [zoffset] Specifies a texel offset in the z direction within the
 * texture array.
 *
 * @param [x, y] Specify the window coordinates of the lower left corner of
 * the rectangular region of pixels to be copied.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [height] Specifies the height of the texture subimage.
 */
static inline void glCopyTexSubImage3D(GLenum target, GLint level,
                                       GLint xoffset, GLint yoffset,
                                       GLint zoffset, GLint x, GLint y,
                                       GLsizei width, GLsizei height)
{
  glad_glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y,
                           width, height);
}
/**
 * glCopyTexSubImage3D, glCopyTextureSubImage3D — copy a three-dimensional
 * texture subimage
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glCopyTexSubImage3D function. Must be GL_TEXTURE_3D or
 * GL_TEXTURE_2D_ARRAY.
 *
 * @param [texture] Specifies the texture object name for
 * glCopyTextureSubImage3D function.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 * texture array.
 *
 * @param [yoffset] Specifies a texel offset in the y direction within the
 * texture array.
 *
 * @param [zoffset] Specifies a texel offset in the z direction within the
 * texture array.
 *
 * @param [x, y] Specify the window coordinates of the lower left corner of
 * the rectangular region of pixels to be copied.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [height] Specifies the height of the texture subimage.
 */
static inline void glCopyTextureSubImage3D(GLuint texture, GLint level,
                                           GLint xoffset, GLint yoffset,
                                           GLint zoffset, GLint x, GLint y,
                                           GLsizei width, GLsizei height)
{
  glad_glCopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y,
                               width, height);
}
/**
 * glCreateBuffers — create buffer objects
 *
 * @param [n] Specifies the number of buffer objects to create.
 *
 * @param [buffers] Specifies an array in which names of the new buffer
 * objects are stored.
 */
static inline void glCreateBuffers(GLsizei n, GLuint *buffers)
{
  glad_glCreateBuffers(n, buffers);
}
/**
 * glCreateFramebuffers — create framebuffer objects
 *
 * @param [n] Number of framebuffer objects to create.
 *
 * @param [framebuffers] Specifies an array in which names of the new
 * framebuffer objects are stored.
 */
static inline void glCreateFramebuffers(GLsizei n, GLuint *ids)
{
  glad_glCreateFramebuffers(n, ids);
}
/**
 * glCreateProgram — Creates a program object
 */
static inline GLuint glCreateProgram(void) { return glad_glCreateProgram(); }
/**
 * glCreateProgramPipelines — create program pipeline objects
 *
 * @param [n] Number of program pipeline objects to create.
 *
 * @param [pipelines] Specifies an array in which names of the new program
 * pipeline objects are stored.
 */
static inline void glCreateProgramPipelines(GLsizei n, GLuint *pipelines)
{
  glad_glCreateProgramPipelines(n, pipelines);
}
/**
 * glCreateQueries — create query objects
 *
 * @param [target] Specifies the target of each created query object.
 *
 * @param [n] Number of query objects to create.
 *
 * @param [ids] Specifies an array in which names of the new query objects are
 * stored.
 */
static inline void glCreateQueries(GLenum target, GLsizei n, GLuint *ids)
{
  glad_glCreateQueries(target, n, ids);
}
/**
 * glCreateRenderbuffers — create renderbuffer objects
 *
 * @param [n] Number of renderbuffer objects to create.
 *
 * @param [renderbuffers] Specifies an array in which names of the new
 * renderbuffer objects are stored.
 */
static inline void glCreateRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
  glad_glCreateRenderbuffers(n, renderbuffers);
}
/**
 * glCreateSamplers — create sampler objects
 *
 * @param [n] Number of sampler objects to create.
 *
 * @param [samplers] Specifies an array in which names of the new sampler
 * objects are stored.
 */
static inline void glCreateSamplers(GLsizei n, GLuint *samplers)
{
  glad_glCreateSamplers(n, samplers);
}
/**
 * glCreateShader — Creates a shader object
 *
 * @param [shaderType] Specifies the type of shader to be created. Must be one
 * of GL_COMPUTE_SHADER, GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER,
 * GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER, or GL_FRAGMENT_SHADER.
 */
static inline GLuint glCreateShader(GLenum shaderType)
{
  return glad_glCreateShader(shaderType);
}
/**
 * glCreateShaderProgramv — create a stand-alone program from an array of
 * null-terminated source code strings
 *
 * @param [type] Specifies the type of shader to create.
 *
 * @param [count] Specifies the number of source code strings in the array
 * strings.
 *
 * @param [strings] Specifies the address of an array of pointers to source
 * code strings from which to create the program object.
 */
static inline GLuint glCreateShaderProgramv(GLenum type, GLsizei count,
                                            const char **strings)
{
  return glad_glCreateShaderProgramv(type, count, strings);
}
/**
 * glCreateTextures — create texture objects
 *
 * @param [target] Specifies the effective texture target of each created
 * texture.
 *
 * @param [n] Number of texture objects to create.
 *
 * @param [textures] Specifies an array in which names of the new texture
 * objects are stored.
 */
static inline void glCreateTextures(GLenum target, GLsizei n, GLuint *textures)
{
  glad_glCreateTextures(target, n, textures);
}
/**
 * glCreateTransformFeedbacks — create transform feedback objects
 *
 * @param [n] Number of transform feedback objects to create.
 *
 * @param [ids] Specifies an array in which names of the new transform
 * feedback objects are stored.
 */
static inline void glCreateTransformFeedbacks(GLsizei n, GLuint *ids)
{
  glad_glCreateTransformFeedbacks(n, ids);
}
/**
 * glCreateVertexArrays — create vertex array objects
 *
 * @param [n] Number of vertex array objects to create.
 *
 * @param [arrays] Specifies an array in which names of the new vertex array
 * objects are stored.
 */
static inline void glCreateVertexArrays(GLsizei n, GLuint *arrays)
{
  glad_glCreateVertexArrays(n, arrays);
}
/**
 * glCullFace — specify whether front- or back-facing facets can be culled
 *
 * @param [mode] Specifies whether front- or back-facing facets are candidates
 * for culling. Symbolic constants GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK
 * are accepted. The initial value is GL_BACK.
 */
static inline void glCullFace(GLenum mode) { glad_glCullFace(mode); }
/**
 * glDebugMessageCallback — specify a callback to receive debugging messages
 * from the GL
 *
 * @param [callback] The address of a callback function that will be called
 * when a debug message is generated.
 *
 * @param [userParam] A user supplied pointer that will be passed on each
 * invocation of callback.
 */
static inline void glDebugMessageCallback(GLDEBUGPROC callback, void *userParam)
{
  glad_glDebugMessageCallback(callback, userParam);
}
/**
 * glDebugMessageControl — control the reporting of debug messages in a debug
 * context
 *
 * @param [source] The source of debug messages to enable or disable.
 *
 * @param [type] The type of debug messages to enable or disable.
 *
 * @param [severity] The severity of debug messages to enable or disable.
 *
 * @param [count] The length of the array ids.
 *
 * @param [ids] The address of an array of unsigned integers contianing the
 * ids of the messages to enable or disable.
 *
 * @param [enabled] A Boolean flag determining whether the selected messages
 * should be enabled or disabled.
 */
static inline void glDebugMessageControl(GLenum source, GLenum type,
                                         GLenum severity, GLsizei count,
                                         const GLuint *ids, GLboolean enabled)
{
  glad_glDebugMessageControl(source, type, severity, count, ids, enabled);
}
/**
 * glDebugMessageInsert — inject an application-supplied message into the
 * debug message queue
 *
 * @param [source] The source of the debug message to insert.
 *
 * @param [type] The type of the debug message insert.
 *
 * @param [id] The user-supplied identifier of the message to insert.
 *
 * @param [severity] The severity of the debug messages to insert.
 *
 * @param [length] The length string contained in the character array whose
 * address is given by message.
 *
 * @param [message] The address of a character array containing the message to
 * insert.
 */
static inline void glDebugMessageInsert(GLenum source, GLenum type, GLuint id,
                                        GLenum severity, GLsizei length,
                                        const char *message)
{
  glad_glDebugMessageInsert(source, type, id, severity, length, message);
}
/**
 * glDeleteBuffers — delete named buffer objects
 *
 * @param [n] Specifies the number of buffer objects to be deleted.
 *
 * @param [buffers] Specifies an array of buffer objects to be deleted.
 */
static inline void glDeleteBuffers(GLsizei n, const GLuint *buffers)
{
  glad_glDeleteBuffers(n, buffers);
}
/**
 * glDeleteFramebuffers — delete framebuffer objects
 *
 * @param [n] Specifies the number of framebuffer objects to be deleted.
 *
 * @param [framebuffers] A pointer to an array containing n framebuffer
 * objects to be deleted.
 */
static inline void glDeleteFramebuffers(GLsizei n, GLuint *framebuffers)
{
  glad_glDeleteFramebuffers(n, framebuffers);
}
/**
 * glDeleteProgram — Deletes a program object
 *
 * @param [program] Specifies the program object to be deleted.
 */
static inline void glDeleteProgram(GLuint program)
{
  glad_glDeleteProgram(program);
}
/**
 * glDeleteProgramPipelines — delete program pipeline objects
 *
 * @param [n] Specifies the number of program pipeline objects to delete.
 *
 * @param [pipelines] Specifies an array of names of program pipeline objects
 * to delete.
 */
static inline void glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines)
{
  glad_glDeleteProgramPipelines(n, pipelines);
}
/**
 * glDeleteQueries — delete named query objects
 *
 * @param [n] Specifies the number of query objects to be deleted.
 *
 * @param [ids] Specifies an array of query objects to be deleted.
 */
static inline void glDeleteQueries(GLsizei n, const GLuint *ids)
{
  glad_glDeleteQueries(n, ids);
}
/**
 * glDeleteRenderbuffers — delete renderbuffer objects
 *
 * @param [n] Specifies the number of renderbuffer objects to be deleted.
 *
 * @param [renderbuffers] A pointer to an array containing n renderbuffer
 * objects to be deleted.
 */
static inline void glDeleteRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
  glad_glDeleteRenderbuffers(n, renderbuffers);
}
/**
 * glDeleteSamplers — delete named sampler objects
 *
 * @param [n] Specifies the number of sampler objects to be deleted.
 *
 * @param [samplers] Specifies an array of sampler objects to be deleted.
 */
static inline void glDeleteSamplers(GLsizei n, const GLuint *samplers)
{
  glad_glDeleteSamplers(n, samplers);
}
/**
 * glDeleteShader — Deletes a shader object
 *
 * @param [shader] Specifies the shader object to be deleted.
 */
static inline void glDeleteShader(GLuint shader)
{
  glad_glDeleteShader(shader);
}
/**
 * glDeleteSync — delete a sync object
 *
 * @param [sync] The sync object to be deleted.
 */
static inline void glDeleteSync(GLsync sync) { glad_glDeleteSync(sync); }
/**
 * glDeleteTextures — delete named textures
 *
 * @param [n] Specifies the number of textures to be deleted.
 *
 * @param [textures] Specifies an array of textures to be deleted.
 */
static inline void glDeleteTextures(GLsizei n, const GLuint *textures)
{
  glad_glDeleteTextures(n, textures);
}
/**
 * glDeleteTransformFeedbacks — delete transform feedback objects
 *
 * @param [n] Specifies the number of transform feedback objects to delete.
 *
 * @param [ids] Specifies an array of names of transform feedback objects to
 * delete.
 */
static inline void glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)
{
  glad_glDeleteTransformFeedbacks(n, ids);
}
/**
 * glDeleteVertexArrays — delete vertex array objects
 *
 * @param [n] Specifies the number of vertex array objects to be deleted.
 *
 * @param [arrays] Specifies the address of an array containing the n names of
 * the objects to be deleted.
 */
static inline void glDeleteVertexArrays(GLsizei n, const GLuint *arrays)
{
  glad_glDeleteVertexArrays(n, arrays);
}
/**
 * glDepthFunc — specify the value used for depth buffer comparisons
 *
 * @param [func] Specifies the depth comparison function. Symbolic constants
 * GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL,
 * and GL_ALWAYS are accepted. The initial value is GL_LESS.
 */
static inline void glDepthFunc(GLenum func) { glad_glDepthFunc(func); }
/**
 * glDepthMask — enable or disable writing into the depth buffer
 *
 * @param [flag] Specifies whether the depth buffer is enabled for writing. If
 * flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is
 * enabled. Initially, depth buffer writing is enabled.
 */
static inline void glDepthMask(GLboolean flag) { glad_glDepthMask(flag); }
/**
 * glDepthRange — specify mapping of depth values from normalized device
 * coordinates to window coordinates
 *
 * @param [nearVal] Specifies the mapping of the near clipping plane to window
 * coordinates. The initial value is 0.
 *
 * @param [farVal] Specifies the mapping of the far clipping plane to window
 * coordinates. The initial value is 1.
 */
static inline void glDepthRange(GLdouble nearVal, GLdouble farVal)
{
  glad_glDepthRange(nearVal, farVal);
}
/**
 * glDepthRange — specify mapping of depth values from normalized device
 * coordinates to window coordinates
 *
 * @param [nearVal] Specifies the mapping of the near clipping plane to window
 * coordinates. The initial value is 0.
 *
 * @param [farVal] Specifies the mapping of the far clipping plane to window
 * coordinates. The initial value is 1.
 */
static inline void glDepthRangef(GLfloat nearVal, GLfloat farVal)
{
  glad_glDepthRangef(nearVal, farVal);
}
/**
 * glDepthRangeArray — specify mapping of depth values from normalized device
 * coordinates to window coordinates for a specified set of viewports
 *
 * @param [first] Specifies the index of the first viewport whose depth range
 * to update.
 *
 * @param [count] Specifies the number of viewports whose depth range to
 * update.
 *
 * @param [v] Specifies the address of an array containing the near and far
 * values for the depth range of each modified viewport.
 */
static inline void glDepthRangeArrayv(GLuint first, GLsizei count,
                                      const GLdouble *v)
{
  glad_glDepthRangeArrayv(first, count, v);
}
/**
 * glDepthRangeIndexed — specify mapping of depth values from normalized
 * device coordinates to window coordinates for a specified viewport
 *
 * @param [index] Specifies the index of the viewport whose depth range to
 * update.
 *
 * @param [nearVal] Specifies the mapping of the near clipping plane to window
 * coordinates. The initial value is 0.
 *
 * @param [farVal] Specifies the mapping of the far clipping plane to window
 * coordinates. The initial value is 1.
 */
static inline void glDepthRangeIndexed(GLuint index, GLdouble nearVal,
                                       GLdouble farVal)
{
  glad_glDepthRangeIndexed(index, nearVal, farVal);
}
/**
 * glDetachShader — Detaches a shader object from a program object to which it
 * is attached
 *
 * @param [program] Specifies the program object from which to detach the
 * shader object.
 *
 * @param [shader] Specifies the shader object to be detached.
 */
static inline void glDetachShader(GLuint program, GLuint shader)
{
  glad_glDetachShader(program, shader);
}
/**
 * glDispatchCompute — launch one or more compute work groups
 *
 * @param [num_groups_x] The number of work groups to be launched in the X
 * dimension.
 *
 * @param [num_groups_y] The number of work groups to be launched in the Y
 * dimension.
 *
 * @param [num_groups_z] The number of work groups to be launched in the Z
 * dimension.
 */
static inline void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y,
                                     GLuint num_groups_z)
{
  glad_glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
}
/**
 * glDispatchComputeIndirect — launch one or more compute work groups using
 * parameters stored in a buffer
 *
 * @param [indirect] The offset into the buffer object currently bound to the
 * GL_DISPATCH_INDIRECT_BUFFER buffer target at which the dispatch parameters
 * are stored.
 */
static inline void glDispatchComputeIndirect(GLintptr indirect)
{
  glad_glDispatchComputeIndirect(indirect);
}
/**
 * glDrawArrays — render primitives from array data
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
 *
 * @param [first] Specifies the starting index in the enabled arrays.
 *
 * @param [count] Specifies the number of indices to be rendered.
 */
static inline void glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
  glad_glDrawArrays(mode, first, count);
}
/**
 * glDrawArraysIndirect — render primitives from array data, taking parameters
 * from memory
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.
 *
 * @param [indirect] Specifies the address of a structure containing the draw
 * parameters.
 */
static inline void glDrawArraysIndirect(GLenum mode, const void *indirect)
{
  glad_glDrawArraysIndirect(mode, indirect);
}
/**
 * glDrawArraysInstanced — draw multiple instances of a range of elements
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY,
 * GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY,
 * GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.
 *
 * @param [first] Specifies the starting index in the enabled arrays.
 *
 * @param [count] Specifies the number of indices to be rendered.
 *
 * @param [primcount] Specifies the number of instances of the specified range
 * of indices to be rendered.
 */
static inline void glDrawArraysInstanced(GLenum mode, GLint first,
                                         GLsizei count, GLsizei primcount)
{
  glad_glDrawArraysInstanced(mode, first, count, primcount);
}
/**
 * glDrawArraysInstancedBaseInstance — draw multiple instances of a range of
 * elements with offset applied to instanced attributes
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY,
 * GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY,
 * GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.
 *
 * @param [first] Specifies the starting index in the enabled arrays.
 *
 * @param [count] Specifies the number of indices to be rendered.
 *
 * @param [primcount] Specifies the number of instances of the specified range
 * of indices to be rendered.
 *
 * @param [baseinstance] Specifies the base instance for use in fetching
 * instanced vertex attributes.
 */
static inline void glDrawArraysInstancedBaseInstance(GLenum mode, GLint first,
                                                     GLsizei count,
                                                     GLsizei primcount,
                                                     GLuint baseinstance)
{
  glad_glDrawArraysInstancedBaseInstance(mode, first, count, primcount,
                                         baseinstance);
}
/**
 * glDrawBuffer, glNamedFramebufferDrawBuffer — specify which color buffers
 * are to be drawn into
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glNamedFramebufferDrawBuffer function. Must be zero or the name of a
 * framebuffer object.
 *
 * @param [buf] For default framebuffer, the argument specifies up to four
 * color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT,
 * GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT,
 * GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT
 * for single-buffered contexts, and GL_BACK for double-buffered contexts. For
 * framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted,
 * where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.
 */
static inline void glDrawBuffer(GLenum buf) { glad_glDrawBuffer(buf); }
/**
 * glDrawBuffer, glNamedFramebufferDrawBuffer — specify which color buffers
 * are to be drawn into
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glNamedFramebufferDrawBuffer function. Must be zero or the name of a
 * framebuffer object.
 *
 * @param [buf] For default framebuffer, the argument specifies up to four
 * color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT,
 * GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT,
 * GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT
 * for single-buffered contexts, and GL_BACK for double-buffered contexts. For
 * framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted,
 * where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.
 */
static inline void glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf)
{
  glad_glNamedFramebufferDrawBuffer(framebuffer, buf);
}
/**
 * glDrawBuffers, glNamedFramebufferDrawBuffers — Specifies a list of color
 buffers to be drawn into
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 glNamedFramebufferDrawBuffers.
 *
 * @param [n] Specifies the number of buffers in bufs.
 *
 * @param [bufs] Points to an array of symbolic constants specifying the
 buffers into which fragment colors or data values will be written.
 */
static inline void glDrawBuffers(GLsizei n, const GLenum *bufs)
{
  glad_glDrawBuffers(n, bufs);
}
/**
 * glDrawBuffers, glNamedFramebufferDrawBuffers — Specifies a list of color
 buffers to be drawn into
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 glNamedFramebufferDrawBuffers.
 *
 * @param [n] Specifies the number of buffers in bufs.
 *
 * @param [bufs] Points to an array of symbolic constants specifying the
 buffers into which fragment colors or data values will be written.
 */
static inline void glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n,
                                                 const GLenum *bufs)
{
  glad_glNamedFramebufferDrawBuffers(framebuffer, n, bufs);
}
/**
 * glDrawElements — render primitives from array data
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
 *
 * @param [count] Specifies the number of elements to be rendered.
 *
 * @param [type] Specifies the type of the values in indices. Must be one of
 * GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
 *
 * @param [indices] Specifies an offset of the first index in the array in the
 * data store of the buffer currently bound to the GL_ELEMENT_ARRAY_BUFFER
 * target.
 */
static inline void glDrawElements(GLenum mode, GLsizei count, GLenum type,
                                  const GLvoid *indices)
{
  glad_glDrawElements(mode, count, type, indices);
}
/**
 * glDrawElementsBaseVertex — render primitives from array data with a
 * per-element offset
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY,
 * GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY,
 * GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.
 *
 * @param [count] Specifies the number of elements to be rendered.
 *
 * @param [type] Specifies the type of the values in indices. Must be one of
 * GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
 *
 * @param [indices] Specifies a pointer to the location where the indices are
 * stored.
 *
 * @param [basevertex] Specifies a constant that should be added to each
 * element of indices when chosing elements from the enabled vertex arrays.
 */
static inline void glDrawElementsBaseVertex(GLenum mode, GLsizei count,
                                            GLenum type, GLvoid *indices,
                                            GLint basevertex)
{
  glad_glDrawElementsBaseVertex(mode, count, type, indices, basevertex);
}
/**
 * glDrawElementsIndirect — render indexed primitives from array data, taking
 * parameters from memory
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.
 *
 * @param [type] Specifies the type of data in the buffer bound to the
 * GL_ELEMENT_ARRAY_BUFFER binding.
 *
 * @param [indirect] Specifies the address of a structure containing the draw
 * parameters.
 */
static inline void glDrawElementsIndirect(GLenum mode, GLenum type,
                                          const void *indirect)
{
  glad_glDrawElementsIndirect(mode, type, indirect);
}
/**
 * glDrawElementsInstanced — draw multiple instances of a set of elements
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
 *
 * @param [count] Specifies the number of elements to be rendered.
 *
 * @param [type] Specifies the type of the values in indices. Must be one of
 * GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
 *
 * @param [indices] Specifies a pointer to the location where the indices are
 * stored.
 *
 * @param [primcount] Specifies the number of instances of the specified range
 * of indices to be rendered.
 */
static inline void glDrawElementsInstanced(GLenum mode, GLsizei count,
                                           GLenum type, const void *indices,
                                           GLsizei primcount)
{
  glad_glDrawElementsInstanced(mode, count, type, indices, primcount);
}
/**
 * glDrawElementsInstancedBaseInstance — draw multiple instances of a set of
 * elements with offset applied to instanced attributes
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
 *
 * @param [count] Specifies the number of elements to be rendered.
 *
 * @param [type] Specifies the type of the values in indices. Must be one of
 * GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
 *
 * @param [indices] Specifies a pointer to the location where the indices are
 * stored.
 *
 * @param [primcount] Specifies the number of instances of the specified range
 * of indices to be rendered.
 *
 * @param [baseinstance] Specifies the base instance for use in fetching
 * instanced vertex attributes.
 */
static inline void
glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type,
                                    const void *indices, GLsizei primcount,
                                    GLuint baseinstance)
{
  glad_glDrawElementsInstancedBaseInstance(mode, count, type, indices,
                                           primcount, baseinstance);
}
/**
 * glDrawElementsInstancedBaseVertex — render multiple instances of a set of
 * primitives from array data with a per-element offset
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY,
 * GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY,
 * GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.
 *
 * @param [count] Specifies the number of elements to be rendered.
 *
 * @param [type] Specifies the type of the values in indices. Must be one of
 * GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
 *
 * @param [indices] Specifies a pointer to the location where the indices are
 * stored.
 *
 * @param [primcount] Specifies the number of instances of the indexed
 * geometry that should be drawn.
 *
 * @param [basevertex] Specifies a constant that should be added to each
 * element of indices when chosing elements from the enabled vertex arrays.
 */
static inline void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count,
                                                     GLenum type,
                                                     GLvoid *indices,
                                                     GLsizei primcount,
                                                     GLint basevertex)
{
  glad_glDrawElementsInstancedBaseVertex(mode, count, type, indices, primcount,
                                         basevertex);
}
/**
 * glDrawElementsInstancedBaseVertexBaseInstance — render multiple instances
 * of a set of primitives from array data with a per-element offset
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY,
 * GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY,
 * GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.
 *
 * @param [count] Specifies the number of elements to be rendered.
 *
 * @param [type] Specifies the type of the values in indices. Must be one of
 * GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
 *
 * @param [indices] Specifies a pointer to the location where the indices are
 * stored.
 *
 * @param [primcount] Specifies the number of instances of the indexed
 * geometry that should be drawn.
 *
 * @param [basevertex] Specifies a constant that should be added to each
 * element of indices when chosing elements from the enabled vertex arrays.
 *
 * @param [baseinstance] Specifies the base instance for use in fetching
 * instanced vertex attributes.
 */
static inline void glDrawElementsInstancedBaseVertexBaseInstance(
    GLenum mode, GLsizei count, GLenum type, GLvoid *indices, GLsizei primcount,
    GLint basevertex, GLuint baseinstance)
{
  glad_glDrawElementsInstancedBaseVertexBaseInstance(
      mode, count, type, indices, primcount, basevertex, baseinstance);
}
/**
 * glDrawRangeElements — render primitives from array data
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
 *
 * @param [start] Specifies the minimum array index contained in indices.
 *
 * @param [end] Specifies the maximum array index contained in indices.
 *
 * @param [count] Specifies the number of elements to be rendered.
 *
 * @param [type] Specifies the type of the values in indices. Must be one of
 * GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
 *
 * @param [indices] Specifies a pointer to the location where the indices are
 * stored.
 */
static inline void glDrawRangeElements(GLenum mode, GLuint start, GLuint end,
                                       GLsizei count, GLenum type,
                                       const GLvoid *indices)
{
  glad_glDrawRangeElements(mode, start, end, count, type, indices);
}
/**
 * glDrawRangeElementsBaseVertex — render primitives from array data with a
 * per-element offset
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY,
 * GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY,
 * GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.
 *
 * @param [start] Specifies the minimum array index contained in indices.
 *
 * @param [end] Specifies the maximum array index contained in indices.
 *
 * @param [count] Specifies the number of elements to be rendered.
 *
 * @param [type] Specifies the type of the values in indices. Must be one of
 * GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
 *
 * @param [indices] Specifies a pointer to the location where the indices are
 * stored.
 *
 * @param [basevertex] Specifies a constant that should be added to each
 * element of indices when chosing elements from the enabled vertex arrays.
 */
static inline void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start,
                                                 GLuint end, GLsizei count,
                                                 GLenum type, GLvoid *indices,
                                                 GLint basevertex)
{
  glad_glDrawRangeElementsBaseVertex(mode, start, end, count, type, indices,
                                     basevertex);
}
/**
 * glDrawTransformFeedback — render primitives using a count derived from a
 * transform feedback object
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.
 *
 * @param [id] Specifies the name of a transform feedback object from which to
 * retrieve a primitive count.
 */
static inline void glDrawTransformFeedback(GLenum mode, GLuint id)
{
  glad_glDrawTransformFeedback(mode, id);
}
/**
 * glDrawTransformFeedbackInstanced — render multiple instances of primitives
 * using a count derived from a transform feedback object
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.
 *
 * @param [id] Specifies the name of a transform feedback object from which to
 * retrieve a primitive count.
 *
 * @param [primcount] Specifies the number of instances of the geometry to
 * render.
 */
static inline void glDrawTransformFeedbackInstanced(GLenum mode, GLuint id,
                                                    GLsizei primcount)
{
  glad_glDrawTransformFeedbackInstanced(mode, id, primcount);
}
/**
 * glDrawTransformFeedbackStream — render primitives using a count derived
 * from a specifed stream of a transform feedback object
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.
 *
 * @param [id] Specifies the name of a transform feedback object from which to
 * retrieve a primitive count.
 *
 * @param [stream] Specifies the index of the transform feedback stream from
 * which to retrieve a primitive count.
 */
static inline void glDrawTransformFeedbackStream(GLenum mode, GLuint id,
                                                 GLuint stream)
{
  glad_glDrawTransformFeedbackStream(mode, id, stream);
}
/**
 * glDrawTransformFeedbackStreamInstanced — render multiple instances of
 * primitives using a count derived from a specifed stream of a transform
 * feedback object
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.
 *
 * @param [id] Specifies the name of a transform feedback object from which to
 * retrieve a primitive count.
 *
 * @param [stream] Specifies the index of the transform feedback stream from
 * which to retrieve a primitive count.
 *
 * @param [primcount] Specifies the number of instances of the geometry to
 * render.
 */
static inline void glDrawTransformFeedbackStreamInstanced(GLenum mode,
                                                          GLuint id,
                                                          GLuint stream,
                                                          GLsizei primcount)
{
  glad_glDrawTransformFeedbackStreamInstanced(mode, id, stream, primcount);
}
/**
 * glEnable — enable or disable server-side GL capabilities
 *
 * @param [cap] Specifies a symbolic constant indicating a GL capability.
 *
 * @param [index] Specifies the index of the switch to disable (for glEnablei
 * and glDisablei only).
 */
static inline void glEnable(GLenum cap) { glad_glEnable(cap); }
/**
 * glEnable — enable or disable server-side GL capabilities
 *
 * @param [cap] Specifies a symbolic constant indicating a GL capability.
 *
 * @param [index] Specifies the index of the switch to disable (for glEnablei
 * and glDisablei only).
 */
static inline void glDisable(GLenum cap) { glad_glDisable(cap); }
/**
 * glEnable — enable or disable server-side GL capabilities
 *
 * @param [cap] Specifies a symbolic constant indicating a GL capability.
 *
 * @param [index] Specifies the index of the switch to disable (for glEnablei
 * and glDisablei only).
 */
static inline void glEnablei(GLenum cap, GLuint index)
{
  glad_glEnablei(cap, index);
}
/**
 * glEnable — enable or disable server-side GL capabilities
 *
 * @param [cap] Specifies a symbolic constant indicating a GL capability.
 *
 * @param [index] Specifies the index of the switch to disable (for glEnablei
 * and glDisablei only).
 */
static inline void glDisablei(GLenum cap, GLuint index)
{
  glad_glDisablei(cap, index);
}
/**
 * glEnableVertexAttribArray — Enable or disable a generic vertex attribute
    array
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 enabled or disabled.
 */
static inline void glEnableVertexAttribArray(GLuint index)
{
  glad_glEnableVertexAttribArray(index);
}
/**
 * glEnableVertexAttribArray — Enable or disable a generic vertex attribute
    array
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 enabled or disabled.
 */
static inline void glDisableVertexAttribArray(GLuint index)
{
  glad_glDisableVertexAttribArray(index);
}
/**
 * glEnableVertexAttribArray — Enable or disable a generic vertex attribute
    array
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 enabled or disabled.
 */
static inline void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index)
{
  glad_glEnableVertexArrayAttrib(vaobj, index);
}
/**
 * glEnableVertexAttribArray — Enable or disable a generic vertex attribute
    array
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 enabled or disabled.
 */
static inline void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index)
{
  glad_glDisableVertexArrayAttrib(vaobj, index);
}
/**
 * glFenceSync — create a new sync object and insert it into the GL command
 * stream
 *
 * @param [condition] Specifies the condition that must be met to set the sync
 * object's state to signaled. condition must be
 * GL_SYNC_GPU_COMMANDS_COMPLETE.
 *
 * @param [flags] Specifies a bitwise combination of flags controlling the
 * behavior of the sync object. No flags are presently defined for this
 * operation and flags must be zero.[1]
 */
static inline GLsync glFenceSync(GLenum condition, GLbitfield flags)
{
  return glad_glFenceSync(condition, flags);
}
/**
 * glFinish — block until all GL execution is complete
 */
static inline void glFinish(void) { glad_glFinish(); }
/**
 * glFlush — force execution of GL commands in finite time
 */
static inline void glFlush(void) { glad_glFlush(); }
/**
 * glFlushMappedBufferRange, glFlushMappedNamedBufferRange — indicate
 * modifications to a range of a mapped buffer
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glFlushMappedBufferRange, which must be one of the buffer binding
 * targets in the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glFlushMappedNamedBufferRange.
 *
 * @param [offset] Specifies the start of the buffer subrange, in basic
 * machine units.
 *
 * @param [length] Specifies the length of the buffer subrange, in basic
 * machine units.
 */
static inline void glFlushMappedBufferRange(GLenum target, GLintptr offset,
                                            GLsizeiptr length)
{
  glad_glFlushMappedBufferRange(target, offset, length);
}
/**
 * glFlushMappedBufferRange, glFlushMappedNamedBufferRange — indicate
 * modifications to a range of a mapped buffer
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glFlushMappedBufferRange, which must be one of the buffer binding
 * targets in the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glFlushMappedNamedBufferRange.
 *
 * @param [offset] Specifies the start of the buffer subrange, in basic
 * machine units.
 *
 * @param [length] Specifies the length of the buffer subrange, in basic
 * machine units.
 */
static inline void glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset,
                                                 GLsizei length)
{
  glad_glFlushMappedNamedBufferRange(buffer, offset, length);
}
/**
 * glFramebufferParameteri, glNamedFramebufferParameteri — set a named
 * parameter of a framebuffer object
 *
 * @param [target] Specifies the target to which the framebuffer is bound for
 * glFramebufferParameteri.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glNamedFramebufferParameteri.
 *
 * @param [pname] Specifies the framebuffer parameter to be modified.
 *
 * @param [param] The new value for the parameter named pname.
 */
static inline void glFramebufferParameteri(GLenum target, GLenum pname,
                                           GLint param)
{
  glad_glFramebufferParameteri(target, pname, param);
}
/**
 * glFramebufferParameteri, glNamedFramebufferParameteri — set a named
 * parameter of a framebuffer object
 *
 * @param [target] Specifies the target to which the framebuffer is bound for
 * glFramebufferParameteri.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glNamedFramebufferParameteri.
 *
 * @param [pname] Specifies the framebuffer parameter to be modified.
 *
 * @param [param] The new value for the parameter named pname.
 */
static inline void glNamedFramebufferParameteri(GLuint framebuffer,
                                                GLenum pname, GLint param)
{
  glad_glNamedFramebufferParameteri(framebuffer, pname, param);
}
/**
 * glFramebufferRenderbuffer, glNamedFramebufferRenderbuffer — attach a
 * renderbuffer as a logical buffer of a framebuffer object
 *
 * @param [target] Specifies the target to which the framebuffer is bound for
 * glFramebufferRenderbuffer.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glNamedFramebufferRenderbuffer.
 *
 * @param [attachment] Specifies the attachment point of the framebuffer.
 *
 * @param [renderbuffertarget] Specifies the renderbuffer target. Must be
 * GL_RENDERBUFFER.
 *
 * @param [renderbuffer] Specifies the name of an existing renderbuffer object
 * of type renderbuffertarget to attach.
 */
static inline void glFramebufferRenderbuffer(GLenum target, GLenum attachment,
                                             GLenum renderbuffertarget,
                                             GLuint renderbuffer)
{
  glad_glFramebufferRenderbuffer(target, attachment, renderbuffertarget,
                                 renderbuffer);
}
/**
 * glFramebufferRenderbuffer, glNamedFramebufferRenderbuffer — attach a
 * renderbuffer as a logical buffer of a framebuffer object
 *
 * @param [target] Specifies the target to which the framebuffer is bound for
 * glFramebufferRenderbuffer.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glNamedFramebufferRenderbuffer.
 *
 * @param [attachment] Specifies the attachment point of the framebuffer.
 *
 * @param [renderbuffertarget] Specifies the renderbuffer target. Must be
 * GL_RENDERBUFFER.
 *
 * @param [renderbuffer] Specifies the name of an existing renderbuffer object
 * of type renderbuffertarget to attach.
 */
static inline void glNamedFramebufferRenderbuffer(GLuint framebuffer,
                                                  GLenum attachment,
                                                  GLenum renderbuffertarget,
                                                  GLuint renderbuffer)
{
  glad_glNamedFramebufferRenderbuffer(framebuffer, attachment,
                                      renderbuffertarget, renderbuffer);
}
/**
 * glFramebufferTexture — attach a level of a texture object as a logical
 * buffer of a framebuffer object
 *
 * @param [target] Specifies the target to which the framebuffer is bound for
 * all commands except glNamedFramebufferTexture.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glNamedFramebufferTexture.
 *
 * @param [attachment] Specifies the attachment point of the framebuffer.
 *
 * @param [textarget] For glFramebufferTexture1D, glFramebufferTexture2D and
 * glFramebufferTexture3D, specifies what type of texture is expected in the
 * texture parameter, or for cube map textures, which face is to be attached.
 *
 * @param [texture] Specifies the name of an existing texture object to
 * attach.
 *
 * @param [level] Specifies the mipmap level of the texture object to attach.
 */
static inline void glFramebufferTexture(GLenum target, GLenum attachment,
                                        GLuint texture, GLint level)
{
  glad_glFramebufferTexture(target, attachment, texture, level);
}
/**
 * glFramebufferTexture — attach a level of a texture object as a logical
 * buffer of a framebuffer object
 *
 * @param [target] Specifies the target to which the framebuffer is bound for
 * all commands except glNamedFramebufferTexture.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glNamedFramebufferTexture.
 *
 * @param [attachment] Specifies the attachment point of the framebuffer.
 *
 * @param [textarget] For glFramebufferTexture1D, glFramebufferTexture2D and
 * glFramebufferTexture3D, specifies what type of texture is expected in the
 * texture parameter, or for cube map textures, which face is to be attached.
 *
 * @param [texture] Specifies the name of an existing texture object to
 * attach.
 *
 * @param [level] Specifies the mipmap level of the texture object to attach.
 */
static inline void glFramebufferTexture1D(GLenum target, GLenum attachment,
                                          GLenum textarget, GLuint texture,
                                          GLint level)
{
  glad_glFramebufferTexture1D(target, attachment, textarget, texture, level);
}
/**
 * glFramebufferTexture — attach a level of a texture object as a logical
 * buffer of a framebuffer object
 *
 * @param [target] Specifies the target to which the framebuffer is bound for
 * all commands except glNamedFramebufferTexture.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glNamedFramebufferTexture.
 *
 * @param [attachment] Specifies the attachment point of the framebuffer.
 *
 * @param [textarget] For glFramebufferTexture1D, glFramebufferTexture2D and
 * glFramebufferTexture3D, specifies what type of texture is expected in the
 * texture parameter, or for cube map textures, which face is to be attached.
 *
 * @param [texture] Specifies the name of an existing texture object to
 * attach.
 *
 * @param [level] Specifies the mipmap level of the texture object to attach.
 */
static inline void glFramebufferTexture2D(GLenum target, GLenum attachment,
                                          GLenum textarget, GLuint texture,
                                          GLint level)
{
  glad_glFramebufferTexture2D(target, attachment, textarget, texture, level);
}
/**
 * glFramebufferTexture — attach a level of a texture object as a logical
 * buffer of a framebuffer object
 *
 * @param [target] Specifies the target to which the framebuffer is bound for
 * all commands except glNamedFramebufferTexture.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glNamedFramebufferTexture.
 *
 * @param [attachment] Specifies the attachment point of the framebuffer.
 *
 * @param [textarget] For glFramebufferTexture1D, glFramebufferTexture2D and
 * glFramebufferTexture3D, specifies what type of texture is expected in the
 * texture parameter, or for cube map textures, which face is to be attached.
 *
 * @param [texture] Specifies the name of an existing texture object to
 * attach.
 *
 * @param [level] Specifies the mipmap level of the texture object to attach.
 */
static inline void glFramebufferTexture3D(GLenum target, GLenum attachment,
                                          GLenum textarget, GLuint texture,
                                          GLint level, GLint layer)
{
  glad_glFramebufferTexture3D(target, attachment, textarget, texture, level,
                              layer);
}
/**
 * glFramebufferTexture — attach a level of a texture object as a logical
 * buffer of a framebuffer object
 *
 * @param [target] Specifies the target to which the framebuffer is bound for
 * all commands except glNamedFramebufferTexture.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glNamedFramebufferTexture.
 *
 * @param [attachment] Specifies the attachment point of the framebuffer.
 *
 * @param [textarget] For glFramebufferTexture1D, glFramebufferTexture2D and
 * glFramebufferTexture3D, specifies what type of texture is expected in the
 * texture parameter, or for cube map textures, which face is to be attached.
 *
 * @param [texture] Specifies the name of an existing texture object to
 * attach.
 *
 * @param [level] Specifies the mipmap level of the texture object to attach.
 */
static inline void glNamedFramebufferTexture(GLuint framebuffer,
                                             GLenum attachment, GLuint texture,
                                             GLint level)
{
  glad_glNamedFramebufferTexture(framebuffer, attachment, texture, level);
}
/**
 * glFramebufferTextureLayer, glNamedFramebufferTextureLayer — attach a single
 * layer of a texture object as a logical buffer of a framebuffer object
 *
 * @param [target] Specifies the target to which the framebuffer is bound for
 * glFramebufferTextureLayer.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glNamedFramebufferTextureLayer.
 *
 * @param [attachment] Specifies the attachment point of the framebuffer.
 *
 * @param [texture] Specifies the name of an existing texture object to
 * attach.
 *
 * @param [level] Specifies the mipmap level of the texture object to attach.
 *
 * @param [layer] Specifies the layer of the texture object to attach.
 */
static inline void glFramebufferTextureLayer(GLenum target, GLenum attachment,
                                             GLuint texture, GLint level,
                                             GLint layer)
{
  glad_glFramebufferTextureLayer(target, attachment, texture, level, layer);
}
/**
 * glFramebufferTextureLayer, glNamedFramebufferTextureLayer — attach a single
 * layer of a texture object as a logical buffer of a framebuffer object
 *
 * @param [target] Specifies the target to which the framebuffer is bound for
 * glFramebufferTextureLayer.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glNamedFramebufferTextureLayer.
 *
 * @param [attachment] Specifies the attachment point of the framebuffer.
 *
 * @param [texture] Specifies the name of an existing texture object to
 * attach.
 *
 * @param [level] Specifies the mipmap level of the texture object to attach.
 *
 * @param [layer] Specifies the layer of the texture object to attach.
 */
static inline void glNamedFramebufferTextureLayer(GLuint framebuffer,
                                                  GLenum attachment,
                                                  GLuint texture, GLint level,
                                                  GLint layer)
{
  glad_glNamedFramebufferTextureLayer(framebuffer, attachment, texture, level,
                                      layer);
}
/**
 * glFrontFace — define front- and back-facing polygons
 *
 * @param [mode] Specifies the orientation of front-facing polygons. GL_CW and
 * GL_CCW are accepted. The initial value is GL_CCW.
 */
static inline void glFrontFace(GLenum mode) { glad_glFrontFace(mode); }
/**
 * glGenBuffers — generate buffer object names
 *
 * @param [n] Specifies the number of buffer object names to be generated.
 *
 * @param [buffers] Specifies an array in which the generated buffer object
 * names are stored.
 */
static inline void glGenBuffers(GLsizei n, GLuint *buffers)
{
  glad_glGenBuffers(n, buffers);
}
/**
 * glGenFramebuffers — generate framebuffer object names
 *
 * @param [n] Specifies the number of framebuffer object names to generate.
 *
 * @param [ids] Specifies an array in which the generated framebuffer object
 * names are stored.
 */
static inline void glGenFramebuffers(GLsizei n, GLuint *ids)
{
  glad_glGenFramebuffers(n, ids);
}
/**
 * glGenProgramPipelines — reserve program pipeline object names
 *
 * @param [n] Specifies the number of program pipeline object names to
 * reserve.
 *
 * @param [pipelines] Specifies an array of into which the reserved names will
 * be written.
 */
static inline void glGenProgramPipelines(GLsizei n, GLuint *pipelines)
{
  glad_glGenProgramPipelines(n, pipelines);
}
/**
 * glGenQueries — generate query object names
 *
 * @param [n] Specifies the number of query object names to be generated.
 *
 * @param [ids] Specifies an array in which the generated query object names
 * are stored.
 */
static inline void glGenQueries(GLsizei n, GLuint *ids)
{
  glad_glGenQueries(n, ids);
}
/**
 * glGenRenderbuffers — generate renderbuffer object names
 *
 * @param [n] Specifies the number of renderbuffer object names to generate.
 *
 * @param [renderbuffers] Specifies an array in which the generated
 * renderbuffer object names are stored.
 */
static inline void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
  glad_glGenRenderbuffers(n, renderbuffers);
}
/**
 * glGenSamplers — generate sampler object names
 *
 * @param [n] Specifies the number of sampler object names to generate.
 *
 * @param [samplers] Specifies an array in which the generated sampler object
 * names are stored.
 */
static inline void glGenSamplers(GLsizei n, GLuint *samplers)
{
  glad_glGenSamplers(n, samplers);
}
/**
 * glGenTextures — generate texture names
 *
 * @param [n] Specifies the number of texture names to be generated.
 *
 * @param [textures] Specifies an array in which the generated texture names
 * are stored.
 */
static inline void glGenTextures(GLsizei n, GLuint *textures)
{
  glad_glGenTextures(n, textures);
}
/**
 * glGenTransformFeedbacks — reserve transform feedback object names
 *
 * @param [n] Specifies the number of transform feedback object names to
 * reserve.
 *
 * @param [ids] Specifies an array of into which the reserved names will be
 * written.
 */
static inline void glGenTransformFeedbacks(GLsizei n, GLuint *ids)
{
  glad_glGenTransformFeedbacks(n, ids);
}
/**
 * glGenVertexArrays — generate vertex array object names
 *
 * @param [n] Specifies the number of vertex array object names to generate.
 *
 * @param [arrays] Specifies an array in which the generated vertex array
 * object names are stored.
 */
static inline void glGenVertexArrays(GLsizei n, GLuint *arrays)
{
  glad_glGenVertexArrays(n, arrays);
}
/**
 * glGenerateMipmap, glGenerateTextureMipmap — generate mipmaps for a
 * specified texture object
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glGenerateMipmap. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D,
 * GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_CUBE_MAP, or GL_TEXTURE_CUBE_MAP_ARRAY.
 *
 * @param [texture] Specifies the texture object name for
 * glGenerateTextureMipmap.
 */
static inline void glGenerateMipmap(GLenum target)
{
  glad_glGenerateMipmap(target);
}
/**
 * glGenerateMipmap, glGenerateTextureMipmap — generate mipmaps for a
 * specified texture object
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glGenerateMipmap. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D,
 * GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_CUBE_MAP, or GL_TEXTURE_CUBE_MAP_ARRAY.
 *
 * @param [texture] Specifies the texture object name for
 * glGenerateTextureMipmap.
 */
static inline void glGenerateTextureMipmap(GLuint texture)
{
  glad_glGenerateTextureMipmap(texture);
}
/**
 * glGet — return the value or values of a selected parameter
 *
 * @param [pname] Specifies the parameter value to be returned for non-indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [target] Specifies the parameter value to be returned for indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [index] Specifies the index of the particular element being queried.
 *
 * @param [data] Returns the value or values of the specified parameter.
 */
static inline void glGetBooleanv(GLenum pname, GLboolean *data)
{
  glad_glGetBooleanv(pname, data);
}
/**
 * glGet — return the value or values of a selected parameter
 *
 * @param [pname] Specifies the parameter value to be returned for non-indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [target] Specifies the parameter value to be returned for indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [index] Specifies the index of the particular element being queried.
 *
 * @param [data] Returns the value or values of the specified parameter.
 */
static inline void glGetDoublev(GLenum pname, GLdouble *data)
{
  glad_glGetDoublev(pname, data);
}
/**
 * glGet — return the value or values of a selected parameter
 *
 * @param [pname] Specifies the parameter value to be returned for non-indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [target] Specifies the parameter value to be returned for indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [index] Specifies the index of the particular element being queried.
 *
 * @param [data] Returns the value or values of the specified parameter.
 */
static inline void glGetFloatv(GLenum pname, GLfloat *data)
{
  glad_glGetFloatv(pname, data);
}
/**
 * glGet — return the value or values of a selected parameter
 *
 * @param [pname] Specifies the parameter value to be returned for non-indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [target] Specifies the parameter value to be returned for indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [index] Specifies the index of the particular element being queried.
 *
 * @param [data] Returns the value or values of the specified parameter.
 */
static inline void glGetIntegerv(GLenum pname, GLint *data)
{
  glad_glGetIntegerv(pname, data);
}
/**
 * glGet — return the value or values of a selected parameter
 *
 * @param [pname] Specifies the parameter value to be returned for non-indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [target] Specifies the parameter value to be returned for indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [index] Specifies the index of the particular element being queried.
 *
 * @param [data] Returns the value or values of the specified parameter.
 */
static inline void glGetInteger64v(GLenum pname, GLint64 *data)
{
  glad_glGetInteger64v(pname, data);
}
/**
 * glGet — return the value or values of a selected parameter
 *
 * @param [pname] Specifies the parameter value to be returned for non-indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [target] Specifies the parameter value to be returned for indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [index] Specifies the index of the particular element being queried.
 *
 * @param [data] Returns the value or values of the specified parameter.
 */
static inline void glGetBooleani_v(GLenum target, GLuint index, GLboolean *data)
{
  glad_glGetBooleani_v(target, index, data);
}
/**
 * glGet — return the value or values of a selected parameter
 *
 * @param [pname] Specifies the parameter value to be returned for non-indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [target] Specifies the parameter value to be returned for indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [index] Specifies the index of the particular element being queried.
 *
 * @param [data] Returns the value or values of the specified parameter.
 */
static inline void glGetIntegeri_v(GLenum target, GLuint index, GLint *data)
{
  glad_glGetIntegeri_v(target, index, data);
}
/**
 * glGet — return the value or values of a selected parameter
 *
 * @param [pname] Specifies the parameter value to be returned for non-indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [target] Specifies the parameter value to be returned for indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [index] Specifies the index of the particular element being queried.
 *
 * @param [data] Returns the value or values of the specified parameter.
 */
static inline void glGetFloati_v(GLenum target, GLuint index, GLfloat *data)
{
  glad_glGetFloati_v(target, index, data);
}
/**
 * glGet — return the value or values of a selected parameter
 *
 * @param [pname] Specifies the parameter value to be returned for non-indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [target] Specifies the parameter value to be returned for indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [index] Specifies the index of the particular element being queried.
 *
 * @param [data] Returns the value or values of the specified parameter.
 */
static inline void glGetDoublei_v(GLenum target, GLuint index, GLdouble *data)
{
  glad_glGetDoublei_v(target, index, data);
}
/**
 * glGet — return the value or values of a selected parameter
 *
 * @param [pname] Specifies the parameter value to be returned for non-indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [target] Specifies the parameter value to be returned for indexed
 * versions of glGet. The symbolic constants in the list below are accepted.
 *
 * @param [index] Specifies the index of the particular element being queried.
 *
 * @param [data] Returns the value or values of the specified parameter.
 */
static inline void glGetInteger64i_v(GLenum target, GLuint index, GLint64 *data)
{
  glad_glGetInteger64i_v(target, index, data);
}
/**
 * glGetActiveAtomicCounterBufferiv — retrieve information about the set of
 * active atomic counter buffers for a program
 *
 * @param [program] The name of a program object from which to retrieve
 * information.
 *
 * @param [bufferIndex] Specifies index of an active atomic counter buffer.
 *
 * @param [pname] Specifies which parameter of the atomic counter buffer to
 * retrieve.
 *
 * @param [params] Specifies the address of a variable into which to write the
 * retrieved information.
 */
static inline void glGetActiveAtomicCounterBufferiv(GLuint program,
                                                    GLuint bufferIndex,
                                                    GLenum pname, GLint *params)
{
  glad_glGetActiveAtomicCounterBufferiv(program, bufferIndex, pname, params);
}
/**
 * glGetActiveAttrib — Returns information about an active attribute variable
 * for the specified program object
 *
 * @param [program] Specifies the program object to be queried.
 *
 * @param [index] Specifies the index of the attribute variable to be queried.
 *
 * @param [bufSize] Specifies the maximum number of characters OpenGL is
 * allowed to write in the character buffer indicated by name.
 *
 * @param [length] Returns the number of characters actually written by OpenGL
 * in the string indicated by name (excluding the null terminator) if a value
 * other than NULL is passed.
 *
 * @param [size] Returns the size of the attribute variable.
 *
 * @param [type] Returns the data type of the attribute variable.
 *
 * @param [name] Returns a null terminated string containing the name of the
 * attribute variable.
 */
static inline void glGetActiveAttrib(GLuint program, GLuint index,
                                     GLsizei bufSize, GLsizei *length,
                                     GLint *size, GLenum *type, GLchar *name)
{
  glad_glGetActiveAttrib(program, index, bufSize, length, size, type, name);
}
/**
 * glGetActiveSubroutineName — query the name of an active shader subroutine
 *
 * @param [program] Specifies the name of the program containing the
 * subroutine.
 *
 * @param [shadertype] Specifies the shader stage from which to query the
 * subroutine name.
 *
 * @param [index] Specifies the index of the shader subroutine uniform.
 *
 * @param [bufsize] Specifies the size of the buffer whose address is given in
 * name.
 *
 * @param [length] Specifies the address of a variable which is to receive the
 * length of the shader subroutine uniform name.
 *
 * @param [name] Specifies the address of an array into which the name of the
 * shader subroutine uniform will be written.
 */
static inline void glGetActiveSubroutineName(GLuint program, GLenum shadertype,
                                             GLuint index, GLsizei bufsize,
                                             GLsizei *length, GLchar *name)
{
  glad_glGetActiveSubroutineName(program, shadertype, index, bufsize, length,
                                 name);
}
/**
 * glGetActiveSubroutineUniform — query a property of an active shader
 * subroutine uniform
 *
 * @param [program] Specifies the name of the program containing the
 * subroutine.
 *
 * @param [shadertype] Specifies the shader stage from which to query for the
 * subroutine parameter. shadertype must be one of GL_VERTEX_SHADER,
 * GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
 * GL_FRAGMENT_SHADER.
 *
 * @param [index] Specifies the index of the shader subroutine uniform.
 *
 * @param [pname] Specifies the parameter of the shader subroutine uniform to
 * query. pname must be GL_NUM_COMPATIBLE_SUBROUTINES,
 * GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH.
 *
 * @param [values] Specifies the address of a into which the queried value or
 * values will be placed.
 */
static inline void glGetActiveSubroutineUniformiv(GLuint program,
                                                  GLenum shadertype,
                                                  GLuint index, GLenum pname,
                                                  GLint *values)
{
  glad_glGetActiveSubroutineUniformiv(program, shadertype, index, pname,
                                      values);
}
/**
 * glGetActiveSubroutineUniformName — query the name of an active shader
 * subroutine uniform
 *
 * @param [program] Specifies the name of the program containing the
 * subroutine.
 *
 * @param [shadertype] Specifies the shader stage from which to query for the
 * subroutine parameter. shadertype must be one of GL_VERTEX_SHADER,
 * GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
 * GL_FRAGMENT_SHADER.
 *
 * @param [index] Specifies the index of the shader subroutine uniform.
 *
 * @param [bufsize] Specifies the size of the buffer whose address is given in
 * name.
 *
 * @param [length] Specifies the address of a variable into which is written
 * the number of characters copied into name.
 *
 * @param [name] Specifies the address of a buffer that will receive the name
 * of the specified shader subroutine uniform.
 */
static inline void
glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype,
                                 GLuint index, GLsizei bufsize, GLsizei *length,
                                 GLchar *name)
{
  glad_glGetActiveSubroutineUniformName(program, shadertype, index, bufsize,
                                        length, name);
}
/**
 * glGetActiveUniform — Returns information about an active uniform variable
 * for the specified program object
 *
 * @param [program] Specifies the program object to be queried.
 *
 * @param [index] Specifies the index of the uniform variable to be queried.
 *
 * @param [bufSize] Specifies the maximum number of characters OpenGL is
 * allowed to write in the character buffer indicated by name.
 *
 * @param [length] Returns the number of characters actually written by OpenGL
 * in the string indicated by name (excluding the null terminator) if a value
 * other than NULL is passed.
 *
 * @param [size] Returns the size of the uniform variable.
 *
 * @param [type] Returns the data type of the uniform variable.
 *
 * @param [name] Returns a null terminated string containing the name of the
 * uniform variable.
 */
static inline void glGetActiveUniform(GLuint program, GLuint index,
                                      GLsizei bufSize, GLsizei *length,
                                      GLint *size, GLenum *type, GLchar *name)
{
  glad_glGetActiveUniform(program, index, bufSize, length, size, type, name);
}
/**
 * glGetActiveUniformBlock — query information about an active uniform block
 *
 * @param [program] Specifies the name of a program containing the uniform
 * block.
 *
 * @param [uniformBlockIndex] Specifies the index of the uniform block within
 * program.
 *
 * @param [pname] Specifies the name of the parameter to query.
 *
 * @param [params] Specifies the address of a variable to receive the result
 * of the query.
 */
static inline void glGetActiveUniformBlockiv(GLuint program,
                                             GLuint uniformBlockIndex,
                                             GLenum pname, GLint *params)
{
  glad_glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, params);
}
/**
 * glGetActiveUniformBlockName — retrieve the name of an active uniform block
 *
 * @param [program] Specifies the name of a program containing the uniform
 * block.
 *
 * @param [uniformBlockIndex] Specifies the index of the uniform block within
 * program.
 *
 * @param [bufSize] Specifies the size of the buffer addressed by
 * uniformBlockName.
 *
 * @param [length] Specifies the address of a variable to receive the number
 * of characters that were written to uniformBlockName.
 *
 * @param [uniformBlockName] Specifies the address an array of characters to
 * receive the name of the uniform block at uniformBlockIndex.
 */
static inline void glGetActiveUniformBlockName(GLuint program,
                                               GLuint uniformBlockIndex,
                                               GLsizei bufSize, GLsizei *length,
                                               GLchar *uniformBlockName)
{
  glad_glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length,
                                   uniformBlockName);
}
/**
 * glGetActiveUniformName — query the name of an active uniform
 *
 * @param [program] Specifies the program containing the active uniform index
 * uniformIndex.
 *
 * @param [uniformIndex] Specifies the index of the active uniform whose name
 * to query.
 *
 * @param [bufSize] Specifies the size of the buffer, in units of GLchar, of
 * the buffer whose address is specified in uniformName.
 *
 * @param [length] Specifies the address of a variable that will receive the
 * number of characters that were or would have been written to the buffer
 * addressed by uniformName.
 *
 * @param [uniformName] Specifies the address of a buffer into which the GL
 * will place the name of the active uniform at uniformIndex within program.
 */
static inline void glGetActiveUniformName(GLuint program, GLuint uniformIndex,
                                          GLsizei bufSize, GLsizei *length,
                                          GLchar *uniformName)
{
  glad_glGetActiveUniformName(program, uniformIndex, bufSize, length,
                              uniformName);
}
/**
 * glGetActiveUniformsiv — Returns information about several active uniform
 * variables for the specified program object
 *
 * @param [program] Specifies the program object to be queried.
 *
 * @param [uniformCount] Specifies both the number of elements in the array of
 * indices uniformIndices and the number of parameters written to params upon
 * successful return.
 *
 * @param [uniformIndices] Specifies the address of an array of uniformCount
 * integers containing the indices of uniforms within program whose parameter
 * pname should be queried.
 *
 * @param [pname] Specifies the property of each uniform in uniformIndices
 * that should be written into the corresponding element of params.
 *
 * @param [params] Specifies the address of an array of uniformCount integers
 * which are to receive the value of pname for each uniform in uniformIndices.
 */
static inline void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount,
                                         const GLuint *uniformIndices,
                                         GLenum pname, GLint *params)
{
  glad_glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname,
                             params);
}
/**
 * glGetAttachedShaders — Returns the handles of the shader objects attached
 * to a program object
 *
 * @param [program] Specifies the program object to be queried.
 *
 * @param [maxCount] Specifies the size of the array for storing the returned
 * object names.
 *
 * @param [count] Returns the number of names actually returned in shaders.
 *
 * @param [shaders] Specifies an array that is used to return the names of
 * attached shader objects.
 */
static inline void glGetAttachedShaders(GLuint program, GLsizei maxCount,
                                        GLsizei *count, GLuint *shaders)
{
  glad_glGetAttachedShaders(program, maxCount, count, shaders);
}
/**
 * glGetAttribLocation — Returns the location of an attribute variable
 *
 * @param [program] Specifies the program object to be queried.
 *
 * @param [name] Points to a null terminated string containing the name of the
 * attribute variable whose location is to be queried.
 */
static inline GLint glGetAttribLocation(GLuint program, const GLchar *name)
{
  return glad_glGetAttribLocation(program, name);
}
/**
 * glGetBufferParameter — return parameters of a buffer object
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glGetBufferParameteriv and glGetBufferParameteri64v. Must be one of the
 * buffer binding targets in the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v.
 *
 * @param [value] Specifies the name of the buffer object parameter to query.
 *
 * @param [data] Returns the requested parameter.
 */
static inline void glGetBufferParameteriv(GLenum target, GLenum value,
                                          GLint *data)
{
  glad_glGetBufferParameteriv(target, value, data);
}
/**
 * glGetBufferParameter — return parameters of a buffer object
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glGetBufferParameteriv and glGetBufferParameteri64v. Must be one of the
 * buffer binding targets in the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v.
 *
 * @param [value] Specifies the name of the buffer object parameter to query.
 *
 * @param [data] Returns the requested parameter.
 */
static inline void glGetBufferParameteri64v(GLenum target, GLenum value,
                                            GLint64 *data)
{
  glad_glGetBufferParameteri64v(target, value, data);
}
/**
 * glGetBufferParameter — return parameters of a buffer object
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glGetBufferParameteriv and glGetBufferParameteri64v. Must be one of the
 * buffer binding targets in the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v.
 *
 * @param [value] Specifies the name of the buffer object parameter to query.
 *
 * @param [data] Returns the requested parameter.
 */
static inline void glGetNamedBufferParameteriv(GLuint buffer, GLenum pname,
                                               GLint *params)
{
  glad_glGetNamedBufferParameteriv(buffer, pname, params);
}
/**
 * glGetBufferParameter — return parameters of a buffer object
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glGetBufferParameteriv and glGetBufferParameteri64v. Must be one of the
 * buffer binding targets in the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v.
 *
 * @param [value] Specifies the name of the buffer object parameter to query.
 *
 * @param [data] Returns the requested parameter.
 */
static inline void glGetNamedBufferParameteri64v(GLuint buffer, GLenum pname,
                                                 GLint64 *params)
{
  glad_glGetNamedBufferParameteri64v(buffer, pname, params);
}
/**
 * glGetBufferPointerv, glGetNamedBufferPointerv — return the pointer to a
 * mapped buffer object's data store
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glGetBufferPointerv, which must be one of the buffer binding targets in
 * the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glGetNamedBufferPointerv.
 *
 * @param [pname] Specifies the name of the pointer to be returned. Must be
 * GL_BUFFER_MAP_POINTER.
 *
 * @param [params] Returns the pointer value specified by pname.
 */
static inline void glGetBufferPointerv(GLenum target, GLenum pname,
                                       GLvoid **params)
{
  glad_glGetBufferPointerv(target, pname, params);
}
/**
 * glGetBufferPointerv, glGetNamedBufferPointerv — return the pointer to a
 * mapped buffer object's data store
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glGetBufferPointerv, which must be one of the buffer binding targets in
 * the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glGetNamedBufferPointerv.
 *
 * @param [pname] Specifies the name of the pointer to be returned. Must be
 * GL_BUFFER_MAP_POINTER.
 *
 * @param [params] Returns the pointer value specified by pname.
 */
static inline void glGetNamedBufferPointerv(GLuint buffer, GLenum pname,
                                            void **params)
{
  glad_glGetNamedBufferPointerv(buffer, pname, params);
}
/**
 * glGetBufferSubData, glGetNamedBufferSubData — returns a subset of a buffer
 * object's data store
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glGetBufferSubData, which must be one of the buffer binding targets in
 * the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glGetNamedBufferSubData.
 *
 * @param [offset] Specifies the offset into the buffer object's data store
 * from which data will be returned, measured in bytes.
 *
 * @param [size] Specifies the size in bytes of the data store region being
 * returned.
 *
 * @param [data] Specifies a pointer to the location where buffer object data
 * is returned.
 */
static inline void glGetBufferSubData(GLenum target, GLintptr offset,
                                      GLsizeiptr size, GLvoid *data)
{
  glad_glGetBufferSubData(target, offset, size, data);
}
/**
 * glGetBufferSubData, glGetNamedBufferSubData — returns a subset of a buffer
 * object's data store
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glGetBufferSubData, which must be one of the buffer binding targets in
 * the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glGetNamedBufferSubData.
 *
 * @param [offset] Specifies the offset into the buffer object's data store
 * from which data will be returned, measured in bytes.
 *
 * @param [size] Specifies the size in bytes of the data store region being
 * returned.
 *
 * @param [data] Specifies a pointer to the location where buffer object data
 * is returned.
 */
static inline void glGetNamedBufferSubData(GLuint buffer, GLintptr offset,
                                           GLsizei size, void *data)
{
  glad_glGetNamedBufferSubData(buffer, offset, size, data);
}
/**
 * glGetCompressedTexImage — return a compressed texture image
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glGetCompressedTexImage and glGetnCompressedTexImage functions.
 * GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_RECTANGLE are accepted.
 *
 * @param [texture] Specifies the texture object name for
 * glGetCompressedTextureImage function.
 *
 * @param [level] Specifies the level-of-detail number of the desired image.
 * Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction
 * image.
 *
 * @param [bufSize] Specifies the size of the buffer pixels for
 * glGetCompressedTextureImage and glGetnCompressedTexImage functions.
 *
 * @param [pixels] Returns the compressed texture image.
 */
static inline void glGetCompressedTexImage(GLenum target, GLint level,
                                           GLvoid *pixels)
{
  glad_glGetCompressedTexImage(target, level, pixels);
}
/**
 * glGetCompressedTexImage — return a compressed texture image
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glGetCompressedTexImage and glGetnCompressedTexImage functions.
 * GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_RECTANGLE are accepted.
 *
 * @param [texture] Specifies the texture object name for
 * glGetCompressedTextureImage function.
 *
 * @param [level] Specifies the level-of-detail number of the desired image.
 * Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction
 * image.
 *
 * @param [bufSize] Specifies the size of the buffer pixels for
 * glGetCompressedTextureImage and glGetnCompressedTexImage functions.
 *
 * @param [pixels] Returns the compressed texture image.
 */
static inline void glGetnCompressedTexImage(GLenum target, GLint level,
                                            GLsizei bufSize, void *pixels)
{
  glad_glGetnCompressedTexImage(target, level, bufSize, pixels);
}
/**
 * glGetCompressedTexImage — return a compressed texture image
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glGetCompressedTexImage and glGetnCompressedTexImage functions.
 * GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_RECTANGLE are accepted.
 *
 * @param [texture] Specifies the texture object name for
 * glGetCompressedTextureImage function.
 *
 * @param [level] Specifies the level-of-detail number of the desired image.
 * Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction
 * image.
 *
 * @param [bufSize] Specifies the size of the buffer pixels for
 * glGetCompressedTextureImage and glGetnCompressedTexImage functions.
 *
 * @param [pixels] Returns the compressed texture image.
 */
static inline void glGetCompressedTextureImage(GLuint texture, GLint level,
                                               GLsizei bufSize, void *pixels)
{
  glad_glGetCompressedTextureImage(texture, level, bufSize, pixels);
}
/**
 * glGetCompressedTextureSubImage — retrieve a sub-region of a compressed
 texture image from a compressed texture object
 *
 * @param [texture] Specifies the name of the source texture object. Must be
 GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or
 GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not
 permitted.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 image level. Level $n$ is the $n$th mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 texture array.
 *
 * @param [yoffset] Specifies a texel offset in the y direction within the
 texture array.
 *
 * @param [zoffset] Specifies a texel offset in the z direction within the
 texture array.
 *
 * @param [width] Specifies the width of the texture subimage. Must be a
 multiple of the compressed block's width, unless the offset is zero and the
 size equals the texture image size.
 *
 * @param [height] Specifies the height of the texture subimage. Must be a
 multiple of the compressed block's height, unless the offset is zero and the
 size equals the texture image size.
 *
 * @param [depth] Specifies the depth of the texture subimage. Must be a
 multiple of the compressed block's depth, unless the offset is zero and the
 size equals the texture image size.
 *
 * @param [bufSize] Specifies the size of the buffer to receive the retrieved
 pixel data.
 *
 * @param [pixels] Returns the texture subimage. Should be a pointer to an
 array of the type specified by type.
 */
static inline void glGetCompressedTextureSubImage(GLuint texture, GLint level,
                                                  GLint xoffset, GLint yoffset,
                                                  GLint zoffset, GLsizei width,
                                                  GLsizei height, GLsizei depth,
                                                  GLsizei bufSize, void *pixels)
{
  glad_glGetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset,
                                      width, height, depth, bufSize, pixels);
}
/**
 * glGetDebugMessageLog — retrieve messages from the debug message log
 *
 * @param [count] The number of debug messages to retrieve from the log.
 *
 * @param [bufSize] The size of the buffer whose address is given by
 * messageLog.
 *
 * @param [sources] The address of an array of variables to receive the
 * sources of the retrieved messages.
 *
 * @param [types] The address of an array of variables to receive the types of
 * the retrieved messages.
 *
 * @param [ids] The address of an array of unsigned integers to receive the
 * ids of the retrieved messages.
 *
 * @param [severities] The address of an array of variables to receive the
 * severites of the retrieved messages.
 *
 * @param [lengths] The address of an array of variables to receive the
 * lengths of the received messages.
 *
 * @param [messageLog] The address of an array of characters that will receive
 * the messages.
 */
static inline GLuint glGetDebugMessageLog(GLuint count, GLsizei bufSize,
                                          GLenum *sources, GLenum *types,
                                          GLuint *ids, GLenum *severities,
                                          GLsizei *lengths, GLchar *messageLog)
{
  return glad_glGetDebugMessageLog(count, bufSize, sources, types, ids,
                                   severities, lengths, messageLog);
}
/**
 * glGetError — return error information
 */
static inline GLenum glGetError(void) { return glad_glGetError(); }
/**
 * glGetFragDataIndex — query the bindings of color indices to user-defined
 * varying out variables
 *
 * @param [program] The name of the program containing varying out variable
 * whose binding to query
 *
 * @param [name] The name of the user-defined varying out variable whose index
 * to query
 */
static inline GLint glGetFragDataIndex(GLuint program, const char *name)
{
  return glad_glGetFragDataIndex(program, name);
}
/**
 * glGetFragDataLocation — query the bindings of color numbers to user-defined
 * varying out variables
 *
 * @param [program] The name of the program containing varying out variable
 * whose binding to query
 *
 * @param [name] The name of the user-defined varying out variable whose
 * binding to query
 */
static inline GLint glGetFragDataLocation(GLuint program, const char *name)
{
  return glad_glGetFragDataLocation(program, name);
}
/**
 * glGetFramebufferAttachmentParameteriv,
 * glGetNamedFramebufferAttachmentParameteriv — retrieve information about
 * attachments of a framebuffer object
 *
 * @param [target] Specifies the target to which the framebuffer object is
 * bound for glGetFramebufferAttachmentParameteriv.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glGetNamedFramebufferAttachmentParameteriv.
 *
 * @param [attachment] Specifies the attachment of the framebuffer object to
 * query.
 *
 * @param [pname] Specifies the parameter of attachment to query.
 *
 * @param [params] Returns the value of parameter pname for attachment.
 */
static inline void glGetFramebufferAttachmentParameteriv(GLenum target,
                                                         GLenum attachment,
                                                         GLenum pname,
                                                         GLint *params)
{
  glad_glGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
}
/**
 * glGetFramebufferAttachmentParameteriv,
 * glGetNamedFramebufferAttachmentParameteriv — retrieve information about
 * attachments of a framebuffer object
 *
 * @param [target] Specifies the target to which the framebuffer object is
 * bound for glGetFramebufferAttachmentParameteriv.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glGetNamedFramebufferAttachmentParameteriv.
 *
 * @param [attachment] Specifies the attachment of the framebuffer object to
 * query.
 *
 * @param [pname] Specifies the parameter of attachment to query.
 *
 * @param [params] Returns the value of parameter pname for attachment.
 */
static inline void glGetNamedFramebufferAttachmentParameteriv(
    GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params)
{
  glad_glGetNamedFramebufferAttachmentParameteriv(framebuffer, attachment,
                                                  pname, params);
}
/**
 * glGetFramebufferParameteriv, glGetNamedFramebufferParameteriv — query a
 * named parameter of a framebuffer object
 *
 * @param [target] Specifies the target to which the framebuffer object is
 * bound for glGetFramebufferParameteriv.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glGetNamedFramebufferParameteriv.
 *
 * @param [pname] Specifies the parameter of the framebuffer object to query.
 *
 * @param [params] Returns the value of parameter pname for the framebuffer
 * object.
 */
static inline void glGetFramebufferParameteriv(GLenum target, GLenum pname,
                                               GLint *params)
{
  glad_glGetFramebufferParameteriv(target, pname, params);
}
/**
 * glGetFramebufferParameteriv, glGetNamedFramebufferParameteriv — query a
 * named parameter of a framebuffer object
 *
 * @param [target] Specifies the target to which the framebuffer object is
 * bound for glGetFramebufferParameteriv.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glGetNamedFramebufferParameteriv.
 *
 * @param [pname] Specifies the parameter of the framebuffer object to query.
 *
 * @param [params] Returns the value of parameter pname for the framebuffer
 * object.
 */
static inline void glGetNamedFramebufferParameteriv(GLuint framebuffer,
                                                    GLenum pname, GLint *param)
{
  glad_glGetNamedFramebufferParameteriv(framebuffer, pname, param);
}
/**
 * glGetGraphicsResetStatus — check if the rendering context has not been lost
 * due to software or hardware issues
 */
static inline GLenum glGetGraphicsResetStatus(void)
{
  return glad_glGetGraphicsResetStatus();
}
/**
 * glGetInternalformat — retrieve information about implementation-dependent
 * support for internal formats
 *
 * @param [target] Indicates the usage of the internal format. target must be
 * GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY,
 * GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER,
 * GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
 *
 * @param [internalformat] Specifies the internal format about which to
 * retrieve information.
 *
 * @param [pname] Specifies the type of information to query.
 *
 * @param [bufSize] Specifies the maximum number of basic machine units that
 * may be written to params by the function.
 *
 * @param [params] Specifies the address of a variable into which to write the
 * retrieved information.
 */
static inline void glGetInternalformativ(GLenum target, GLenum internalformat,
                                         GLenum pname, GLsizei bufSize,
                                         GLint *params)
{
  glad_glGetInternalformativ(target, internalformat, pname, bufSize, params);
}
/**
 * glGetInternalformat — retrieve information about implementation-dependent
 * support for internal formats
 *
 * @param [target] Indicates the usage of the internal format. target must be
 * GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY,
 * GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER,
 * GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
 *
 * @param [internalformat] Specifies the internal format about which to
 * retrieve information.
 *
 * @param [pname] Specifies the type of information to query.
 *
 * @param [bufSize] Specifies the maximum number of basic machine units that
 * may be written to params by the function.
 *
 * @param [params] Specifies the address of a variable into which to write the
 * retrieved information.
 */
static inline void glGetInternalformati64v(GLenum target, GLenum internalformat,
                                           GLenum pname, GLsizei bufSize,
                                           GLint64 *params)
{
  glad_glGetInternalformati64v(target, internalformat, pname, bufSize, params);
}
/**
 * glGetMultisamplefv — retrieve the location of a sample
 *
 * @param [pname] Specifies the sample parameter name. pname must be
 * GL_SAMPLE_POSITION.
 *
 * @param [index] Specifies the index of the sample whose position to query.
 *
 * @param [val] Specifies the address of an array to receive the position of
 * the sample.
 */
static inline void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val)
{
  glad_glGetMultisamplefv(pname, index, val);
}
/**
 * glGetObjectLabel — retrieve the label of a named object identified within a
 * namespace
 *
 * @param [identifier] The namespace from which the name of the object is
 * allocated.
 *
 * @param [name] The name of the object whose label to retrieve.
 *
 * @param [bufSize] The length of the buffer whose address is in label.
 *
 * @param [length] The address of a variable to receive the length of the
 * object label.
 *
 * @param [label] The address of a string that will receive the object label.
 */
static inline void glGetObjectLabel(GLenum identifier, GLuint name,
                                    GLsizei bifSize, GLsizei *length,
                                    char *label)
{
  glad_glGetObjectLabel(identifier, name, bifSize, length, label);
}
/**
 * glGetObjectPtrLabel — retrieve the label of a sync object identified by a
 * pointer
 *
 * @param [ptr] The name of the sync object whose label to retrieve.
 *
 * @param [bufSize] The length of the buffer whose address is in label.
 *
 * @param [length] The address of a variable to receive the length of the
 * object label.
 *
 * @param [label] The address of a string that will receive the object label.
 */
static inline void glGetObjectPtrLabel(void *ptr, GLsizei bifSize,
                                       GLsizei *length, char *label)
{
  glad_glGetObjectPtrLabel(ptr, bifSize, length, label);
}
/**
 * glGetPointerv — return the address of the specified pointer
 *
 * @param [pname] Specifies the pointer to be returned. Must be one of
 * GL_DEBUG_CALLBACK_FUNCTION or GL_DEBUG_CALLBACK_USER_PARAM.
 *
 * @param [params] Returns the pointer value specified by pname.
 */
static inline void glGetPointerv(GLenum pname, GLvoid **params)
{
  glad_glGetPointerv(pname, params);
}
/**
 * glGetProgramiv — Returns a parameter from a program object
 *
 * @param [program] Specifies the program object to be queried.
 *
 * @param [pname] Specifies the object parameter. Accepted symbolic names are
 * GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH,
 * GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS,
 * GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS,
 * GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH,
 * GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE,
 * GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE,
 * GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH,
 * GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and
 * GL_GEOMETRY_OUTPUT_TYPE.
 *
 * @param [params] Returns the requested object parameter.
 */
static inline void glGetProgramiv(GLuint program, GLenum pname, GLint *params)
{
  glad_glGetProgramiv(program, pname, params);
}
/**
 * glGetProgramBinary — return a binary representation of a program object's
 * compiled and linked executable source
 *
 * @param [program] Specifies the name of a program object whose binary
 * representation to retrieve.
 *
 * @param [bufSize] Specifies the size of the buffer whose address is given by
 * binary.
 *
 * @param [length] Specifies the address of a variable to receive the number
 * of bytes written into binary.
 *
 * @param [binaryFormat] Specifies the address of a variable to receive a
 * token indicating the format of the binary data returned by the GL.
 *
 * @param [binary] Specifies the address an array into which the GL will
 * return program's binary representation.
 */
static inline void glGetProgramBinary(GLuint program, GLsizei bufsize,
                                      GLsizei *length, GLenum *binaryFormat,
                                      void *binary)
{
  glad_glGetProgramBinary(program, bufsize, length, binaryFormat, binary);
}
/**
 * glGetProgramInfoLog — Returns the information log for a program object
 *
 * @param [program] Specifies the program object whose information log is to
 * be queried.
 *
 * @param [maxLength] Specifies the size of the character buffer for storing
 * the returned information log.
 *
 * @param [length] Returns the length of the string returned in infoLog
 * (excluding the null terminator).
 *
 * @param [infoLog] Specifies an array of characters that is used to return
 * the information log.
 */
static inline void glGetProgramInfoLog(GLuint program, GLsizei maxLength,
                                       GLsizei *length, GLchar *infoLog)
{
  glad_glGetProgramInfoLog(program, maxLength, length, infoLog);
}
/**
 * glGetProgramInterface — query a property of an interface in a program
 *
 * @param [program] The name of a program object whose interface to query.
 *
 * @param [programInterface] A token identifying the interface within program
 * to query.
 *
 * @param [pname] The name of the parameter within programInterface to query.
 *
 * @param [params] The address of a variable to retrieve the value of pname
 * for the program interface.
 */
static inline void glGetProgramInterfaceiv(GLuint program,
                                           GLenum programInterface,
                                           GLenum pname, GLint *params)
{
  glad_glGetProgramInterfaceiv(program, programInterface, pname, params);
}
/**
 * glGetProgramPipeline — retrieve properties of a program pipeline object
 *
 * @param [pipeline] Specifies the name of a program pipeline object whose
 * parameter retrieve.
 *
 * @param [pname] Specifies the name of the parameter to retrieve.
 *
 * @param [params] Specifies the address of a variable into which will be
 * written the value or values of pname for pipeline.
 */
static inline void glGetProgramPipelineiv(GLuint pipeline, GLenum pname,
                                          GLint *params)
{
  glad_glGetProgramPipelineiv(pipeline, pname, params);
}
/**
 * glGetProgramPipelineInfoLog — retrieve the info log string from a program
 * pipeline object
 *
 * @param [pipeline] Specifies the name of a program pipeline object from
 * which to retrieve the info log.
 *
 * @param [bufSize] Specifies the maximum number of characters, including the
 * null terminator, that may be written into infoLog.
 *
 * @param [length] Specifies the address of a variable into which will be
 * written the number of characters written into infoLog.
 *
 * @param [infoLog] Specifies the address of an array of characters into which
 * will be written the info log for pipeline.
 */
static inline void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize,
                                               GLsizei *length, GLchar *infoLog)
{
  glad_glGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog);
}
/**
 * glGetProgramResource — retrieve values for multiple properties of a single
 * active resource within a program object
 *
 * @param [program] The name of a program object whose resources to query.
 *
 * @param [programInterface] A token identifying the interface within program
 * containing the resource named name.
 */
static inline void glGetProgramResourceiv(GLuint program,
                                          GLenum programInterface, GLuint index,
                                          GLsizei propCount,
                                          const GLenum *props, GLsizei bufSize,
                                          GLsizei *length, GLint *params)
{
  glad_glGetProgramResourceiv(program, programInterface, index, propCount,
                              props, bufSize, length, params);
}
/**
 * glGetProgramResourceIndex — query the index of a named resource within a
 * program
 *
 * @param [program] The name of a program object whose resources to query.
 *
 * @param [programInterface] A token identifying the interface within program
 * containing the resource named name.
 *
 * @param [name] The name of the resource to query the index of.
 */
static inline GLuint glGetProgramResourceIndex(GLuint program,
                                               GLenum programInterface,
                                               const char *name)
{
  return glad_glGetProgramResourceIndex(program, programInterface, name);
}
/**
 * glGetProgramResourceLocation — query the location of a named resource
 * within a program
 *
 * @param [program] The name of a program object whose resources to query.
 *
 * @param [programInterface] A token identifying the interface within program
 * containing the resource named name.
 *
 * @param [name] The name of the resource to query the location of.
 */
static inline GLint glGetProgramResourceLocation(GLuint program,
                                                 GLenum programInterface,
                                                 const char *name)
{
  return glad_glGetProgramResourceLocation(program, programInterface, name);
}
/**
 * glGetProgramResourceLocationIndex — query the fragment color index of a
 * named variable within a program
 *
 * @param [program] The name of a program object whose resources to query.
 *
 * @param [programInterface] A token identifying the interface within program
 * containing the resource named name.
 *
 * @param [name] The name of the resource to query the location of.
 */
static inline GLint glGetProgramResourceLocationIndex(GLuint program,
                                                      GLenum programInterface,
                                                      const char *name)
{
  return glad_glGetProgramResourceLocationIndex(program, programInterface,
                                                name);
}
/**
 * glGetProgramResourceName — query the name of an indexed resource within a
 * program
 *
 * @param [program] The name of a program object whose resources to query.
 *
 * @param [programInterface] A token identifying the interface within program
 * containing the indexed resource.
 *
 * @param [index] The index of the resource within programInterface of
 * program.
 *
 * @param [bufSize] The size of the character array whose address is given by
 * name.
 *
 * @param [length] The address of a variable which will receive the length of
 * the resource name.
 *
 * @param [name] The address of a character array into which will be written
 * the name of the resource.
 */
static inline void glGetProgramResourceName(GLuint program,
                                            GLenum programInterface,
                                            GLuint index, GLsizei bufSize,
                                            GLsizei *length, char *name)
{
  glad_glGetProgramResourceName(program, programInterface, index, bufSize,
                                length, name);
}
/**
 * glGetProgramStage — retrieve properties of a program object corresponding
 * to a specified shader stage
 *
 * @param [program] Specifies the name of the program containing shader stage.
 *
 * @param [shadertype] Specifies the shader stage from which to query for the
 * subroutine parameter. shadertype must be one of GL_VERTEX_SHADER,
 * GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
 * GL_FRAGMENT_SHADER.
 *
 * @param [pname] Specifies the parameter of the shader to query. pname must
 * be GL_ACTIVE_SUBROUTINE_UNIFORMS, GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS,
 * GL_ACTIVE_SUBROUTINES, GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or
 * GL_ACTIVE_SUBROUTINE_MAX_LENGTH.
 *
 * @param [values] Specifies the address of a variable into which the queried
 * value or values will be placed.
 */
static inline void glGetProgramStageiv(GLuint program, GLenum shadertype,
                                       GLenum pname, GLint *values)
{
  glad_glGetProgramStageiv(program, shadertype, pname, values);
}
/**
 * glGetQueryIndexediv — return parameters of an indexed query object target
 *
 * @param [target] Specifies a query object target. Must be GL_SAMPLES_PASSED,
 * GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE
 * GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN,
 * GL_TIME_ELAPSED, or GL_TIMESTAMP.
 *
 * @param [index] Specifies the index of the query object target.
 *
 * @param [pname] Specifies the symbolic name of a query object target
 * parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS.
 *
 * @param [params] Returns the requested data.
 */
static inline void glGetQueryIndexediv(GLenum target, GLuint index,
                                       GLenum pname, GLint *params)
{
  glad_glGetQueryIndexediv(target, index, pname, params);
}
/**
 * glGetQueryObject — return parameters of a query object
 *
 * @param [id] Specifies the name of a query object.
 *
 * @param [pname] Specifies the symbolic name of a query object parameter.
 * Accepted values are GL_QUERY_RESULT, GL_QUERY_RESULT_NO_WAIT or
 * GL_QUERY_RESULT_AVAILABLE.
 *
 * @param [params] If a buffer is bound to the GL_QUERY_RESULT_BUFFER target,
 * then params is treated as an offset to a location within that buffer's data
 * store to receive the result of the query. If no buffer is bound to
 * GL_QUERY_RESULT_BUFFER, then params is treated as an address in client
 * memory of a variable to receive the resulting data.
 */
static inline void glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params)
{
  glad_glGetQueryObjectiv(id, pname, params);
}
/**
 * glGetQueryObject — return parameters of a query object
 *
 * @param [id] Specifies the name of a query object.
 *
 * @param [pname] Specifies the symbolic name of a query object parameter.
 * Accepted values are GL_QUERY_RESULT, GL_QUERY_RESULT_NO_WAIT or
 * GL_QUERY_RESULT_AVAILABLE.
 *
 * @param [params] If a buffer is bound to the GL_QUERY_RESULT_BUFFER target,
 * then params is treated as an offset to a location within that buffer's data
 * store to receive the result of the query. If no buffer is bound to
 * GL_QUERY_RESULT_BUFFER, then params is treated as an address in client
 * memory of a variable to receive the resulting data.
 */
static inline void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)
{
  glad_glGetQueryObjectuiv(id, pname, params);
}
/**
 * glGetQueryObject — return parameters of a query object
 *
 * @param [id] Specifies the name of a query object.
 *
 * @param [pname] Specifies the symbolic name of a query object parameter.
 * Accepted values are GL_QUERY_RESULT, GL_QUERY_RESULT_NO_WAIT or
 * GL_QUERY_RESULT_AVAILABLE.
 *
 * @param [params] If a buffer is bound to the GL_QUERY_RESULT_BUFFER target,
 * then params is treated as an offset to a location within that buffer's data
 * store to receive the result of the query. If no buffer is bound to
 * GL_QUERY_RESULT_BUFFER, then params is treated as an address in client
 * memory of a variable to receive the resulting data.
 */
static inline void glGetQueryObjecti64v(GLuint id, GLenum pname,
                                        GLint64 *params)
{
  glad_glGetQueryObjecti64v(id, pname, params);
}
/**
 * glGetQueryObject — return parameters of a query object
 *
 * @param [id] Specifies the name of a query object.
 *
 * @param [pname] Specifies the symbolic name of a query object parameter.
 * Accepted values are GL_QUERY_RESULT, GL_QUERY_RESULT_NO_WAIT or
 * GL_QUERY_RESULT_AVAILABLE.
 *
 * @param [params] If a buffer is bound to the GL_QUERY_RESULT_BUFFER target,
 * then params is treated as an offset to a location within that buffer's data
 * store to receive the result of the query. If no buffer is bound to
 * GL_QUERY_RESULT_BUFFER, then params is treated as an address in client
 * memory of a variable to receive the resulting data.
 */
static inline void glGetQueryObjectui64v(GLuint id, GLenum pname,
                                         GLuint64 *params)
{
  glad_glGetQueryObjectui64v(id, pname, params);
}
/**
 * glGetQueryiv — return parameters of a query object target
 *
 * @param [target] Specifies a query object target. Must be GL_SAMPLES_PASSED,
 * GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE
 * GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN,
 * GL_TIME_ELAPSED, or GL_TIMESTAMP.
 *
 * @param [pname] Specifies the symbolic name of a query object target
 * parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS.
 *
 * @param [params] Returns the requested data.
 */
static inline void glGetQueryiv(GLenum target, GLenum pname, GLint *params)
{
  glad_glGetQueryiv(target, pname, params);
}
/**
 * glGetRenderbufferParameteriv, glGetNamedRenderbufferParameteriv — query a
 * named parameter of a renderbuffer object
 *
 * @param [target] Specifies the target to which the renderbuffer object is
 * bound for glGetRenderbufferParameteriv. target must be GL_RENDERBUFFER.
 *
 * @param [renderbuffer] Specifies the name of the renderbuffer object for
 * glGetNamedRenderbufferParameteriv.
 *
 * @param [pname] Specifies the parameter of the renderbuffer object to query.
 *
 * @param [params] Returns the value of parameter pname for the renderbuffer
 * object.
 */
static inline void glGetRenderbufferParameteriv(GLenum target, GLenum pname,
                                                GLint *params)
{
  glad_glGetRenderbufferParameteriv(target, pname, params);
}
/**
 * glGetRenderbufferParameteriv, glGetNamedRenderbufferParameteriv — query a
 * named parameter of a renderbuffer object
 *
 * @param [target] Specifies the target to which the renderbuffer object is
 * bound for glGetRenderbufferParameteriv. target must be GL_RENDERBUFFER.
 *
 * @param [renderbuffer] Specifies the name of the renderbuffer object for
 * glGetNamedRenderbufferParameteriv.
 *
 * @param [pname] Specifies the parameter of the renderbuffer object to query.
 *
 * @param [params] Returns the value of parameter pname for the renderbuffer
 * object.
 */
static inline void glGetNamedRenderbufferParameteriv(GLuint renderbuffer,
                                                     GLenum pname,
                                                     GLint *params)
{
  glad_glGetNamedRenderbufferParameteriv(renderbuffer, pname, params);
}
/**
 * glGetSamplerParameter — return sampler parameter values
 *
 * @param [sampler] Specifies name of the sampler object from which to
 * retrieve parameters.
 *
 * @param [pname] Specifies the symbolic name of a sampler parameter.
 * GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S,
 * GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR,
 * GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
 *
 * @param [params] Returns the sampler parameters.
 */
static inline void glGetSamplerParameterfv(GLuint sampler, GLenum pname,
                                           GLfloat *params)
{
  glad_glGetSamplerParameterfv(sampler, pname, params);
}
/**
 * glGetSamplerParameter — return sampler parameter values
 *
 * @param [sampler] Specifies name of the sampler object from which to
 * retrieve parameters.
 *
 * @param [pname] Specifies the symbolic name of a sampler parameter.
 * GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S,
 * GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR,
 * GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
 *
 * @param [params] Returns the sampler parameters.
 */
static inline void glGetSamplerParameteriv(GLuint sampler, GLenum pname,
                                           GLint *params)
{
  glad_glGetSamplerParameteriv(sampler, pname, params);
}
/**
 * glGetSamplerParameter — return sampler parameter values
 *
 * @param [sampler] Specifies name of the sampler object from which to
 * retrieve parameters.
 *
 * @param [pname] Specifies the symbolic name of a sampler parameter.
 * GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S,
 * GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR,
 * GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
 *
 * @param [params] Returns the sampler parameters.
 */
static inline void glGetSamplerParameterIiv(GLuint sampler, GLenum pname,
                                            GLint *params)
{
  glad_glGetSamplerParameterIiv(sampler, pname, params);
}
/**
 * glGetSamplerParameter — return sampler parameter values
 *
 * @param [sampler] Specifies name of the sampler object from which to
 * retrieve parameters.
 *
 * @param [pname] Specifies the symbolic name of a sampler parameter.
 * GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S,
 * GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR,
 * GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
 *
 * @param [params] Returns the sampler parameters.
 */
static inline void glGetSamplerParameterIuiv(GLuint sampler, GLenum pname,
                                             GLuint *params)
{
  glad_glGetSamplerParameterIuiv(sampler, pname, params);
}
/**
 * glGetShaderiv — Returns a parameter from a shader object
 *
 * @param [shader] Specifies the shader object to be queried.
 *
 * @param [pname] Specifies the object parameter. Accepted symbolic names are
 * GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH,
 * GL_SHADER_SOURCE_LENGTH.
 *
 * @param [params] Returns the requested object parameter.
 */
static inline void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)
{
  glad_glGetShaderiv(shader, pname, params);
}
/**
 * glGetShaderInfoLog — Returns the information log for a shader object
 *
 * @param [shader] Specifies the shader object whose information log is to be
 * queried.
 *
 * @param [maxLength] Specifies the size of the character buffer for storing
 * the returned information log.
 *
 * @param [length] Returns the length of the string returned in infoLog
 * (excluding the null terminator).
 *
 * @param [infoLog] Specifies an array of characters that is used to return
 * the information log.
 */
static inline void glGetShaderInfoLog(GLuint shader, GLsizei maxLength,
                                      GLsizei *length, GLchar *infoLog)
{
  glad_glGetShaderInfoLog(shader, maxLength, length, infoLog);
}
/**
 * glGetShaderPrecisionFormat — retrieve the range and precision for numeric
 * formats supported by the shader compiler
 *
 * @param [shaderType] Specifies the type of shader whose precision to query.
 * shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER.
 *
 * @param [precisionType] Specifies the numeric format whose precision and
 * range to query.
 *
 * @param [range] Specifies the address of array of two integers into which
 * encodings of the implementation's numeric range are returned.
 *
 * @param [precision] Specifies the address of an integer into which the
 * numeric precision of the implementation is written.
 */
static inline void glGetShaderPrecisionFormat(GLenum shaderType,
                                              GLenum precisionType,
                                              GLint *range, GLint *precision)
{
  glad_glGetShaderPrecisionFormat(shaderType, precisionType, range, precision);
}
/**
 * glGetShaderSource — Returns the source code string from a shader object
 *
 * @param [shader] Specifies the shader object to be queried.
 *
 * @param [bufSize] Specifies the size of the character buffer for storing the
 * returned source code string.
 *
 * @param [length] Returns the length of the string returned in source
 * (excluding the null terminator).
 *
 * @param [source] Specifies an array of characters that is used to return the
 * source code string.
 */
static inline void glGetShaderSource(GLuint shader, GLsizei bufSize,
                                     GLsizei *length, GLchar *source)
{
  glad_glGetShaderSource(shader, bufSize, length, source);
}
/**
 * glGetString — return a string describing the current GL connection
 *
 * @param [name] Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER,
 * GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi
 * accepts the GL_EXTENSIONS token.
 *
 * @param [index] For glGetStringi, specifies the index of the string to
 * return.
 */
static inline const GLubyte *glGetString(GLenum name)
{
  return glad_glGetString(name);
}
/**
 * glGetString — return a string describing the current GL connection
 *
 * @param [name] Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER,
 * GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi
 * accepts the GL_EXTENSIONS token.
 *
 * @param [index] For glGetStringi, specifies the index of the string to
 * return.
 */
static inline const GLubyte *glGetStringi(GLenum name, GLuint index)
{
  return glad_glGetStringi(name, index);
}
/**
 * glGetSubroutineIndex — retrieve the index of a subroutine uniform of a
 * given shader stage within a program
 *
 * @param [program] Specifies the name of the program containing shader stage.
 *
 * @param [shadertype] Specifies the shader stage from which to query for
 * subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER,
 * GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
 * GL_FRAGMENT_SHADER.
 *
 * @param [name] Specifies the name of the subroutine uniform whose index to
 * query.
 */
static inline GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype,
                                          const GLchar *name)
{
  return glad_glGetSubroutineIndex(program, shadertype, name);
}
/**
 * glGetSubroutineUniformLocation — retrieve the location of a subroutine
 * uniform of a given shader stage within a program
 *
 * @param [program] Specifies the name of the program containing shader stage.
 *
 * @param [shadertype] Specifies the shader stage from which to query for
 * subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER,
 * GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
 * GL_FRAGMENT_SHADER.
 *
 * @param [name] Specifies the name of the subroutine uniform whose index to
 * query.
 */
static inline GLint glGetSubroutineUniformLocation(GLuint program,
                                                   GLenum shadertype,
                                                   const GLchar *name)
{
  return glad_glGetSubroutineUniformLocation(program, shadertype, name);
}
/**
 * glGetSynciv — query the properties of a sync object
 *
 * @param [sync] Specifies the sync object whose properties to query.
 *
 * @param [pname] Specifies the parameter whose value to retrieve from the
 * sync object specified in sync.
 *
 * @param [bufSize] Specifies the size of the buffer whose address is given in
 * values.
 *
 * @param [length] Specifies the address of an variable to receive the number
 * of integers placed in values.
 *
 * @param [values] Specifies the address of an array to receive the values of
 * the queried parameter.
 */
static inline void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize,
                               GLsizei *length, GLint *values)
{
  glad_glGetSynciv(sync, pname, bufSize, length, values);
}
/**
 * glGetTexImage — return a texture image
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glGetTexImage and glGetnTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_2D,
 * GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, and GL_TEXTURE_CUBE_MAP_ARRAY are
 * acceptable.
 *
 * @param [texture] Specifies the texture object name.
 *
 * @param [level] Specifies the level-of-detail number of the desired image.
 * Level 0 is the base image level. Level n is the nth mipmap reduction image.
 *
 * @param [format] Specifies a pixel format for the returned data. The
 * supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT,
 * GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA,
 * GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER,
 * GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER,
 * GL_BGRA_INTEGER.
 *
 * @param [type] Specifies a pixel type for the returned data. The supported
 * types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT,
 * GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
 * GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
 * GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,
 * GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
 * GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
 * GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
 * GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8,
 * GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and
 * GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
 *
 * @param [bufSize] Specifies the size of the buffer pixels for glGetnTexImage
 * and glGetTextureImage functions.
 *
 * @param [pixels] Returns the texture image. Should be a pointer to an array
 * of the type specified by type.
 */
static inline void glGetTexImage(GLenum target, GLint level, GLenum format,
                                 GLenum type, GLvoid *pixels)
{
  glad_glGetTexImage(target, level, format, type, pixels);
}
/**
 * glGetTexImage — return a texture image
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glGetTexImage and glGetnTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_2D,
 * GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, and GL_TEXTURE_CUBE_MAP_ARRAY are
 * acceptable.
 *
 * @param [texture] Specifies the texture object name.
 *
 * @param [level] Specifies the level-of-detail number of the desired image.
 * Level 0 is the base image level. Level n is the nth mipmap reduction image.
 *
 * @param [format] Specifies a pixel format for the returned data. The
 * supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT,
 * GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA,
 * GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER,
 * GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER,
 * GL_BGRA_INTEGER.
 *
 * @param [type] Specifies a pixel type for the returned data. The supported
 * types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT,
 * GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
 * GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
 * GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,
 * GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
 * GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
 * GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
 * GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8,
 * GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and
 * GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
 *
 * @param [bufSize] Specifies the size of the buffer pixels for glGetnTexImage
 * and glGetTextureImage functions.
 *
 * @param [pixels] Returns the texture image. Should be a pointer to an array
 * of the type specified by type.
 */
static inline void glGetnTexImage(GLenum target, GLint level, GLenum format,
                                  GLenum type, GLsizei bufSize, void *pixels)
{
  glad_glGetnTexImage(target, level, format, type, bufSize, pixels);
}
/**
 * glGetTexImage — return a texture image
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glGetTexImage and glGetnTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_2D,
 * GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, and GL_TEXTURE_CUBE_MAP_ARRAY are
 * acceptable.
 *
 * @param [texture] Specifies the texture object name.
 *
 * @param [level] Specifies the level-of-detail number of the desired image.
 * Level 0 is the base image level. Level n is the nth mipmap reduction image.
 *
 * @param [format] Specifies a pixel format for the returned data. The
 * supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT,
 * GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA,
 * GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER,
 * GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER,
 * GL_BGRA_INTEGER.
 *
 * @param [type] Specifies a pixel type for the returned data. The supported
 * types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT,
 * GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
 * GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
 * GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,
 * GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
 * GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
 * GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
 * GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8,
 * GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and
 * GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
 *
 * @param [bufSize] Specifies the size of the buffer pixels for glGetnTexImage
 * and glGetTextureImage functions.
 *
 * @param [pixels] Returns the texture image. Should be a pointer to an array
 * of the type specified by type.
 */
static inline void glGetTextureImage(GLuint texture, GLint level, GLenum format,
                                     GLenum type, GLsizei bufSize, void *pixels)
{
  glad_glGetTextureImage(texture, level, format, type, bufSize, pixels);
}
/**
 * glGetTexLevelParameter — return texture parameter values for a specific
 level of detail
 *
 * @param [target] Specifies the target to which the texture is bound for
 glGetTexLevelParameterfv and glGetTexLevelParameteriv functions. Must be one
 of the following values: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D,
 GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE,
 GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY,
 GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
 GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
 GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
 GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D,
 GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY,
 GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE,
 GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or
 GL_TEXTURE_BUFFER.
 *
 * @param [texture] Specifies the texture object name for
 glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.
 *
 * @param [level] Specifies the level-of-detail number of the desired image.
 Level 0 is the base image level. Level n is the nth mipmap reduction image.
 *
 * @param [pname] Specifies the symbolic name of a texture parameter.
 GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH,
 GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE,
 GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE,
 GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and
 GL_TEXTURE_BUFFER_OFFSET are accepted.
 *
 * @param [params] Returns the requested data.
 */
static inline void glGetTexLevelParameterfv(GLenum target, GLint level,
                                            GLenum pname, GLfloat *params)
{
  glad_glGetTexLevelParameterfv(target, level, pname, params);
}
/**
 * glGetTexLevelParameter — return texture parameter values for a specific
 level of detail
 *
 * @param [target] Specifies the target to which the texture is bound for
 glGetTexLevelParameterfv and glGetTexLevelParameteriv functions. Must be one
 of the following values: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D,
 GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE,
 GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY,
 GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
 GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
 GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
 GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D,
 GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY,
 GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE,
 GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or
 GL_TEXTURE_BUFFER.
 *
 * @param [texture] Specifies the texture object name for
 glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.
 *
 * @param [level] Specifies the level-of-detail number of the desired image.
 Level 0 is the base image level. Level n is the nth mipmap reduction image.
 *
 * @param [pname] Specifies the symbolic name of a texture parameter.
 GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH,
 GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE,
 GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE,
 GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and
 GL_TEXTURE_BUFFER_OFFSET are accepted.
 *
 * @param [params] Returns the requested data.
 */
static inline void glGetTexLevelParameteriv(GLenum target, GLint level,
                                            GLenum pname, GLint *params)
{
  glad_glGetTexLevelParameteriv(target, level, pname, params);
}
/**
 * glGetTexLevelParameter — return texture parameter values for a specific
 level of detail
 *
 * @param [target] Specifies the target to which the texture is bound for
 glGetTexLevelParameterfv and glGetTexLevelParameteriv functions. Must be one
 of the following values: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D,
 GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE,
 GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY,
 GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
 GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
 GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
 GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D,
 GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY,
 GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE,
 GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or
 GL_TEXTURE_BUFFER.
 *
 * @param [texture] Specifies the texture object name for
 glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.
 *
 * @param [level] Specifies the level-of-detail number of the desired image.
 Level 0 is the base image level. Level n is the nth mipmap reduction image.
 *
 * @param [pname] Specifies the symbolic name of a texture parameter.
 GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH,
 GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE,
 GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE,
 GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and
 GL_TEXTURE_BUFFER_OFFSET are accepted.
 *
 * @param [params] Returns the requested data.
 */
static inline void glGetTextureLevelParameterfv(GLuint texture, GLint level,
                                                GLenum pname, GLfloat *params)
{
  glad_glGetTextureLevelParameterfv(texture, level, pname, params);
}
/**
 * glGetTexLevelParameter — return texture parameter values for a specific
 level of detail
 *
 * @param [target] Specifies the target to which the texture is bound for
 glGetTexLevelParameterfv and glGetTexLevelParameteriv functions. Must be one
 of the following values: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D,
 GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE,
 GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY,
 GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
 GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
 GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
 GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D,
 GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY,
 GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE,
 GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or
 GL_TEXTURE_BUFFER.
 *
 * @param [texture] Specifies the texture object name for
 glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.
 *
 * @param [level] Specifies the level-of-detail number of the desired image.
 Level 0 is the base image level. Level n is the nth mipmap reduction image.
 *
 * @param [pname] Specifies the symbolic name of a texture parameter.
 GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH,
 GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE,
 GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE,
 GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and
 GL_TEXTURE_BUFFER_OFFSET are accepted.
 *
 * @param [params] Returns the requested data.
 */
static inline void glGetTextureLevelParameteriv(GLuint texture, GLint level,
                                                GLenum pname, GLint *params)
{
  glad_glGetTextureLevelParameteriv(texture, level, pname, params);
}
/**
 * glGetTexParameter — return texture parameter values
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and
 * glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE,
 * GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP,
 * GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
 *
 * @param [texture] Specifies the texture object name for
 * glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv,
 * and glGetTextureParameterIuiv functions.
 *
 * @param [pname] Specifies the symbolic name of a texture parameter.
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE,
 * GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT,
 * GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER,
 * GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER,
 * GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G,
 * GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA,
 * GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL,
 * GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S,
 * GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
 *
 * @param [params] Returns the texture parameters.
 */
static inline void glGetTexParameterfv(GLenum target, GLenum pname,
                                       GLfloat *params)
{
  glad_glGetTexParameterfv(target, pname, params);
}
/**
 * glGetTexParameter — return texture parameter values
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and
 * glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE,
 * GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP,
 * GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
 *
 * @param [texture] Specifies the texture object name for
 * glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv,
 * and glGetTextureParameterIuiv functions.
 *
 * @param [pname] Specifies the symbolic name of a texture parameter.
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE,
 * GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT,
 * GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER,
 * GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER,
 * GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G,
 * GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA,
 * GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL,
 * GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S,
 * GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
 *
 * @param [params] Returns the texture parameters.
 */
static inline void glGetTexParameteriv(GLenum target, GLenum pname,
                                       GLint *params)
{
  glad_glGetTexParameteriv(target, pname, params);
}
/**
 * glGetTexParameter — return texture parameter values
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and
 * glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE,
 * GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP,
 * GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
 *
 * @param [texture] Specifies the texture object name for
 * glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv,
 * and glGetTextureParameterIuiv functions.
 *
 * @param [pname] Specifies the symbolic name of a texture parameter.
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE,
 * GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT,
 * GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER,
 * GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER,
 * GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G,
 * GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA,
 * GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL,
 * GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S,
 * GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
 *
 * @param [params] Returns the texture parameters.
 */
static inline void glGetTexParameterIiv(GLenum target, GLenum pname,
                                        GLint *params)
{
  glad_glGetTexParameterIiv(target, pname, params);
}
/**
 * glGetTexParameter — return texture parameter values
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and
 * glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE,
 * GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP,
 * GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
 *
 * @param [texture] Specifies the texture object name for
 * glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv,
 * and glGetTextureParameterIuiv functions.
 *
 * @param [pname] Specifies the symbolic name of a texture parameter.
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE,
 * GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT,
 * GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER,
 * GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER,
 * GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G,
 * GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA,
 * GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL,
 * GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S,
 * GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
 *
 * @param [params] Returns the texture parameters.
 */
static inline void glGetTexParameterIuiv(GLenum target, GLenum pname,
                                         GLuint *params)
{
  glad_glGetTexParameterIuiv(target, pname, params);
}
/**
 * glGetTexParameter — return texture parameter values
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and
 * glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE,
 * GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP,
 * GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
 *
 * @param [texture] Specifies the texture object name for
 * glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv,
 * and glGetTextureParameterIuiv functions.
 *
 * @param [pname] Specifies the symbolic name of a texture parameter.
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE,
 * GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT,
 * GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER,
 * GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER,
 * GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G,
 * GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA,
 * GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL,
 * GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S,
 * GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
 *
 * @param [params] Returns the texture parameters.
 */
static inline void glGetTextureParameterfv(GLuint texture, GLenum pname,
                                           GLfloat *params)
{
  glad_glGetTextureParameterfv(texture, pname, params);
}
/**
 * glGetTexParameter — return texture parameter values
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and
 * glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE,
 * GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP,
 * GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
 *
 * @param [texture] Specifies the texture object name for
 * glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv,
 * and glGetTextureParameterIuiv functions.
 *
 * @param [pname] Specifies the symbolic name of a texture parameter.
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE,
 * GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT,
 * GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER,
 * GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER,
 * GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G,
 * GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA,
 * GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL,
 * GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S,
 * GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
 *
 * @param [params] Returns the texture parameters.
 */
static inline void glGetTextureParameteriv(GLuint texture, GLenum pname,
                                           GLint *params)
{
  glad_glGetTextureParameteriv(texture, pname, params);
}
/**
 * glGetTexParameter — return texture parameter values
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and
 * glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE,
 * GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP,
 * GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
 *
 * @param [texture] Specifies the texture object name for
 * glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv,
 * and glGetTextureParameterIuiv functions.
 *
 * @param [pname] Specifies the symbolic name of a texture parameter.
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE,
 * GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT,
 * GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER,
 * GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER,
 * GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G,
 * GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA,
 * GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL,
 * GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S,
 * GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
 *
 * @param [params] Returns the texture parameters.
 */
static inline void glGetTextureParameterIiv(GLuint texture, GLenum pname,
                                            GLint *params)
{
  glad_glGetTextureParameterIiv(texture, pname, params);
}
/**
 * glGetTexParameter — return texture parameter values
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and
 * glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE,
 * GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP,
 * GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
 *
 * @param [texture] Specifies the texture object name for
 * glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv,
 * and glGetTextureParameterIuiv functions.
 *
 * @param [pname] Specifies the symbolic name of a texture parameter.
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE,
 * GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT,
 * GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER,
 * GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER,
 * GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G,
 * GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA,
 * GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL,
 * GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S,
 * GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
 *
 * @param [params] Returns the texture parameters.
 */
static inline void glGetTextureParameterIuiv(GLuint texture, GLenum pname,
                                             GLuint *params)
{
  glad_glGetTextureParameterIuiv(texture, pname, params);
}
/**
 * glGetTextureSubImage — retrieve a sub-region of a texture image from a
 texture object
 *
 * @param [texture] Specifies the name of the source texture object. Must be
 GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or
 GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not
 permitted.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 image level. Level $n$ is the $n$th mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 texture array.
 *
 * @param [yoffset] Specifies a texel offset in the y direction within the
 texture array.
 *
 * @param [zoffset] Specifies a texel offset in the z direction within the
 texture array.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [height] Specifies the height of the texture subimage.
 *
 * @param [depth] Specifies the depth of the texture subimage.
 *
 * @param [format] Specifies the format of the pixel data. The following
 symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA,
 GL_BGRA, GL_DEPTH_COMPONENT and GL_STENCIL_INDEX.
 *
 * @param [type] Specifies the data type of the pixel data. The following
 symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT,
 GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
 GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
 GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,
 GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
 GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
 GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and
 GL_UNSIGNED_INT_2_10_10_10_REV.
 *
 * @param [bufSize] Specifies the size of the buffer to receive the retrieved
 pixel data.
 *
 * @param [pixels] Returns the texture subimage. Should be a pointer to an
 array of the type specified by type.
 */
static inline void glGetTextureSubImage(GLuint texture, GLint level,
                                        GLint xoffset, GLint yoffset,
                                        GLint zoffset, GLsizei width,
                                        GLsizei height, GLsizei depth,
                                        GLenum format, GLenum type,
                                        GLsizei bufSize, void *pixels)
{
  glad_glGetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width,
                            height, depth, format, type, bufSize, pixels);
}
/**
 * glGetTransformFeedbackiv — query the state of a transform feedback object.
 *
 * @param [xfb] The name of an existing transform feedback object, or zero for
 * the default transform feedback object.
 *
 * @param [pname] Property to use for the query. Must be one of the values:
 * GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START,
 * GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED,
 * GL_TRANSFORM_FEEDBACK_ACTIVE.
 *
 * @param [index] Index of the transform feedback stream (for indexed state).
 *
 * @param [param] The address of a buffer into which will be written the
 * requested state information.
 */
static inline void glGetTransformFeedbackiv(GLuint xfb, GLenum pname,
                                            GLint *param)
{
  glad_glGetTransformFeedbackiv(xfb, pname, param);
}
/**
 * glGetTransformFeedbackiv — query the state of a transform feedback object.
 *
 * @param [xfb] The name of an existing transform feedback object, or zero for
 * the default transform feedback object.
 *
 * @param [pname] Property to use for the query. Must be one of the values:
 * GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START,
 * GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED,
 * GL_TRANSFORM_FEEDBACK_ACTIVE.
 *
 * @param [index] Index of the transform feedback stream (for indexed state).
 *
 * @param [param] The address of a buffer into which will be written the
 * requested state information.
 */
static inline void glGetTransformFeedbacki_v(GLuint xfb, GLenum pname,
                                             GLuint index, GLint *param)
{
  glad_glGetTransformFeedbacki_v(xfb, pname, index, param);
}
/**
 * glGetTransformFeedbackiv — query the state of a transform feedback object.
 *
 * @param [xfb] The name of an existing transform feedback object, or zero for
 * the default transform feedback object.
 *
 * @param [pname] Property to use for the query. Must be one of the values:
 * GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START,
 * GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED,
 * GL_TRANSFORM_FEEDBACK_ACTIVE.
 *
 * @param [index] Index of the transform feedback stream (for indexed state).
 *
 * @param [param] The address of a buffer into which will be written the
 * requested state information.
 */
static inline void glGetTransformFeedbacki64_v(GLuint xfb, GLenum pname,
                                               GLuint index, GLint64 *param)
{
  glad_glGetTransformFeedbacki64_v(xfb, pname, index, param);
}
/**
 * glGetTransformFeedbackVarying — retrieve information about varying
 * variables selected for transform feedback
 *
 * @param [program] The name of the target program object.
 *
 * @param [index] The index of the varying variable whose information to
 * retrieve.
 *
 * @param [bufSize] The maximum number of characters, including the null
 * terminator, that may be written into name.
 *
 * @param [length] The address of a variable which will receive the number of
 * characters written into name, excluding the null-terminator. If length is
 * NULL no length is returned.
 *
 * @param [size] The address of a variable that will receive the size of the
 * varying.
 *
 * @param [type] The address of a variable that will recieve the type of the
 * varying.
 *
 * @param [name] The address of a buffer into which will be written the name
 * of the varying.
 */
static inline void glGetTransformFeedbackVarying(GLuint program, GLuint index,
                                                 GLsizei bufSize,
                                                 GLsizei *length, GLsizei *size,
                                                 GLenum *type, char *name)
{
  glad_glGetTransformFeedbackVarying(program, index, bufSize, length, size,
                                     type, name);
}
/**
 * glGetUniform — Returns the value of a uniform variable
 *
 * @param [program] Specifies the program object to be queried.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * queried.
 *
 * @param [bufSize] Specifies the size of the buffer params.
 *
 * @param [params] Returns the value of the specified uniform variable.
 */
static inline void glGetUniformfv(GLuint program, GLint location,
                                  GLfloat *params)
{
  glad_glGetUniformfv(program, location, params);
}
/**
 * glGetUniform — Returns the value of a uniform variable
 *
 * @param [program] Specifies the program object to be queried.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * queried.
 *
 * @param [bufSize] Specifies the size of the buffer params.
 *
 * @param [params] Returns the value of the specified uniform variable.
 */
static inline void glGetUniformiv(GLuint program, GLint location, GLint *params)
{
  glad_glGetUniformiv(program, location, params);
}
/**
 * glGetUniform — Returns the value of a uniform variable
 *
 * @param [program] Specifies the program object to be queried.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * queried.
 *
 * @param [bufSize] Specifies the size of the buffer params.
 *
 * @param [params] Returns the value of the specified uniform variable.
 */
static inline void glGetUniformuiv(GLuint program, GLint location,
                                   GLuint *params)
{
  glad_glGetUniformuiv(program, location, params);
}
/**
 * glGetUniform — Returns the value of a uniform variable
 *
 * @param [program] Specifies the program object to be queried.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * queried.
 *
 * @param [bufSize] Specifies the size of the buffer params.
 *
 * @param [params] Returns the value of the specified uniform variable.
 */
static inline void glGetUniformdv(GLuint program, GLint location,
                                  GLdouble *params)
{
  glad_glGetUniformdv(program, location, params);
}
/**
 * glGetUniform — Returns the value of a uniform variable
 *
 * @param [program] Specifies the program object to be queried.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * queried.
 *
 * @param [bufSize] Specifies the size of the buffer params.
 *
 * @param [params] Returns the value of the specified uniform variable.
 */
static inline void glGetnUniformfv(GLuint program, GLint location,
                                   GLsizei bufSize, GLfloat *params)
{
  glad_glGetnUniformfv(program, location, bufSize, params);
}
/**
 * glGetUniform — Returns the value of a uniform variable
 *
 * @param [program] Specifies the program object to be queried.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * queried.
 *
 * @param [bufSize] Specifies the size of the buffer params.
 *
 * @param [params] Returns the value of the specified uniform variable.
 */
static inline void glGetnUniformiv(GLuint program, GLint location,
                                   GLsizei bufSize, GLint *params)
{
  glad_glGetnUniformiv(program, location, bufSize, params);
}
/**
 * glGetUniform — Returns the value of a uniform variable
 *
 * @param [program] Specifies the program object to be queried.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * queried.
 *
 * @param [bufSize] Specifies the size of the buffer params.
 *
 * @param [params] Returns the value of the specified uniform variable.
 */
static inline void glGetnUniformuiv(GLuint program, GLint location,
                                    GLsizei bufSize, GLuint *params)
{
  glad_glGetnUniformuiv(program, location, bufSize, params);
}
/**
 * glGetUniform — Returns the value of a uniform variable
 *
 * @param [program] Specifies the program object to be queried.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * queried.
 *
 * @param [bufSize] Specifies the size of the buffer params.
 *
 * @param [params] Returns the value of the specified uniform variable.
 */
static inline void glGetnUniformdv(GLuint program, GLint location,
                                   GLsizei bufSize, GLdouble *params)
{
  glad_glGetnUniformdv(program, location, bufSize, params);
}
/**
 * glGetUniformBlockIndex — retrieve the index of a named uniform block
 *
 * @param [program] Specifies the name of a program containing the uniform
 * block.
 *
 * @param [uniformBlockName] Specifies the address an array of characters to
 * containing the name of the uniform block whose index to retrieve.
 */
static inline GLuint glGetUniformBlockIndex(GLuint program,
                                            const GLchar *uniformBlockName)
{
  return glad_glGetUniformBlockIndex(program, uniformBlockName);
}
/**
 * glGetUniformIndices — retrieve the index of a named uniform block
 *
 * @param [program] Specifies the name of a program containing uniforms whose
 * indices to query.
 *
 * @param [uniformCount] Specifies the number of uniforms whose indices to
 * query.
 *
 * @param [uniformNames] Specifies the address of an array of pointers to
 * buffers containing the names of the queried uniforms.
 *
 * @param [uniformIndices] Specifies the address of an array that will receive
 * the indices of the uniforms.
 */
static inline void glGetUniformIndices(GLuint program, GLsizei uniformCount,
                                       const GLchar **uniformNames,
                                       GLuint *uniformIndices)
{
  glad_glGetUniformIndices(program, uniformCount, uniformNames, uniformIndices);
}
/**
 * glGetUniformLocation — Returns the location of a uniform variable
 *
 * @param [program] Specifies the program object to be queried.
 *
 * @param [name] Points to a null terminated string containing the name of the
 * uniform variable whose location is to be queried.
 */
static inline GLint glGetUniformLocation(GLuint program, const GLchar *name)
{
  return glad_glGetUniformLocation(program, name);
}
/**
 * glGetUniformSubroutine — retrieve the value of a subroutine uniform of a
 * given shader stage of the current program
 *
 * @param [shadertype] Specifies the shader stage from which to query for
 * subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER,
 * GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
 * GL_FRAGMENT_SHADER.
 *
 * @param [location] Specifies the location of the subroutine uniform.
 *
 * @param [values] Specifies the address of a variable to receive the value or
 * values of the subroutine uniform.
 */
static inline void glGetUniformSubroutineuiv(GLenum shadertype, GLint location,
                                             GLuint *values)
{
  glad_glGetUniformSubroutineuiv(shadertype, location, values);
}
/**
 * glGetVertexArrayIndexed — retrieve parameters of an attribute of a vertex
 array object
 *
 * @param [vaobj] Specifies the name of a vertex array object.
 *
 * @param [index] Specifies the index of the vertex array object attribute.
 Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).
 *
 * @param [pname] Specifies the property to be used for the query. For
 glGetVertexArrayIndexediv, it must be one of the following values:
 GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE,
 GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE,
 GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER,
 GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or
 GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be
 equal to GL_VERTEX_BINDING_OFFSET.
 *
 * @param [param] Returns the requested value.
 */
static inline void glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index,
                                               GLenum pname, GLint64 *param)
{
  glad_glGetVertexArrayIndexed64iv(vaobj, index, pname, param);
}
/**
 * glGetVertexArrayIndexed — retrieve parameters of an attribute of a vertex
 array object
 *
 * @param [vaobj] Specifies the name of a vertex array object.
 *
 * @param [index] Specifies the index of the vertex array object attribute.
 Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).
 *
 * @param [pname] Specifies the property to be used for the query. For
 glGetVertexArrayIndexediv, it must be one of the following values:
 GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE,
 GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE,
 GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER,
 GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or
 GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be
 equal to GL_VERTEX_BINDING_OFFSET.
 *
 * @param [param] Returns the requested value.
 */
static inline void glGetVertexArrayIndexediv(GLuint vaobj, GLuint index,
                                             GLenum pname, GLint *param)
{
  glad_glGetVertexArrayIndexediv(vaobj, index, pname, param);
}
/**
 * glGetVertexArrayiv — retrieve parameters of a vertex array object
 *
 * @param [vaobj] specifies the name of the vertex array object to use for the
 * query.
 *
 * @param [pname] Name of the property to use for the query. Must be
 * GL_ELEMENT_ARRAY_BUFFER_BINDING.
 *
 * @param [param] Returns the requested value.
 */
static inline void glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint *param)
{
  glad_glGetVertexArrayiv(vaobj, pname, param);
}
/**
 * glGetVertexAttrib — Return a generic vertex attribute parameter
 *
 * @param [index] Specifies the generic vertex attribute parameter to be
 * queried.
 *
 * @param [pname] Specifies the symbolic name of the vertex attribute
 * parameter to be queried. Accepted values are
 * GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED,
 * GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE,
 * GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
 * GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or
 * GL_CURRENT_VERTEX_ATTRIB.
 *
 * @param [params] Returns the requested data.
 */
static inline void glGetVertexAttribdv(GLuint index, GLenum pname,
                                       GLdouble *params)
{
  glad_glGetVertexAttribdv(index, pname, params);
}
/**
 * glGetVertexAttrib — Return a generic vertex attribute parameter
 *
 * @param [index] Specifies the generic vertex attribute parameter to be
 * queried.
 *
 * @param [pname] Specifies the symbolic name of the vertex attribute
 * parameter to be queried. Accepted values are
 * GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED,
 * GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE,
 * GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
 * GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or
 * GL_CURRENT_VERTEX_ATTRIB.
 *
 * @param [params] Returns the requested data.
 */
static inline void glGetVertexAttribfv(GLuint index, GLenum pname,
                                       GLfloat *params)
{
  glad_glGetVertexAttribfv(index, pname, params);
}
/**
 * glGetVertexAttrib — Return a generic vertex attribute parameter
 *
 * @param [index] Specifies the generic vertex attribute parameter to be
 * queried.
 *
 * @param [pname] Specifies the symbolic name of the vertex attribute
 * parameter to be queried. Accepted values are
 * GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED,
 * GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE,
 * GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
 * GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or
 * GL_CURRENT_VERTEX_ATTRIB.
 *
 * @param [params] Returns the requested data.
 */
static inline void glGetVertexAttribiv(GLuint index, GLenum pname,
                                       GLint *params)
{
  glad_glGetVertexAttribiv(index, pname, params);
}
/**
 * glGetVertexAttrib — Return a generic vertex attribute parameter
 *
 * @param [index] Specifies the generic vertex attribute parameter to be
 * queried.
 *
 * @param [pname] Specifies the symbolic name of the vertex attribute
 * parameter to be queried. Accepted values are
 * GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED,
 * GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE,
 * GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
 * GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or
 * GL_CURRENT_VERTEX_ATTRIB.
 *
 * @param [params] Returns the requested data.
 */
static inline void glGetVertexAttribIiv(GLuint index, GLenum pname,
                                        GLint *params)
{
  glad_glGetVertexAttribIiv(index, pname, params);
}
/**
 * glGetVertexAttrib — Return a generic vertex attribute parameter
 *
 * @param [index] Specifies the generic vertex attribute parameter to be
 * queried.
 *
 * @param [pname] Specifies the symbolic name of the vertex attribute
 * parameter to be queried. Accepted values are
 * GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED,
 * GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE,
 * GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
 * GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or
 * GL_CURRENT_VERTEX_ATTRIB.
 *
 * @param [params] Returns the requested data.
 */
static inline void glGetVertexAttribIuiv(GLuint index, GLenum pname,
                                         GLuint *params)
{
  glad_glGetVertexAttribIuiv(index, pname, params);
}
/**
 * glGetVertexAttrib — Return a generic vertex attribute parameter
 *
 * @param [index] Specifies the generic vertex attribute parameter to be
 * queried.
 *
 * @param [pname] Specifies the symbolic name of the vertex attribute
 * parameter to be queried. Accepted values are
 * GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED,
 * GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE,
 * GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
 * GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or
 * GL_CURRENT_VERTEX_ATTRIB.
 *
 * @param [params] Returns the requested data.
 */
static inline void glGetVertexAttribLdv(GLuint index, GLenum pname,
                                        GLdouble *params)
{
  glad_glGetVertexAttribLdv(index, pname, params);
}
/**
 * glGetVertexAttribPointerv — return the address of the specified generic
 * vertex attribute pointer
 *
 * @param [index] Specifies the generic vertex attribute parameter to be
 * returned.
 *
 * @param [pname] Specifies the symbolic name of the generic vertex attribute
 * parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
 *
 * @param [pointer] Returns the pointer value.
 */
static inline void glGetVertexAttribPointerv(GLuint index, GLenum pname,
                                             GLvoid **pointer)
{
  glad_glGetVertexAttribPointerv(index, pname, pointer);
}
/**
 * glHint — specify implementation-specific hints
 *
 * @param [target] Specifies a symbolic constant indicating the behavior to be
 * controlled. GL_LINE_SMOOTH_HINT, GL_POLYGON_SMOOTH_HINT,
 * GL_TEXTURE_COMPRESSION_HINT, and GL_FRAGMENT_SHADER_DERIVATIVE_HINT are
 * accepted.
 *
 * @param [mode] Specifies a symbolic constant indicating the desired
 * behavior. GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted.
 */
static inline void glHint(GLenum target, GLenum mode)
{
  glad_glHint(target, mode);
}
/**
 * glInvalidateBufferData — invalidate the content of a buffer object's data
 * store
 *
 * @param [buffer] The name of a buffer object whose data store to invalidate.
 */
static inline void glInvalidateBufferData(GLuint buffer)
{
  glad_glInvalidateBufferData(buffer);
}
/**
 * glInvalidateBufferSubData — invalidate a region of a buffer object's data
 * store
 *
 * @param [buffer] The name of a buffer object, a subrange of whose data store
 * to invalidate.
 *
 * @param [offset] The offset within the buffer's data store of the start of
 * the range to be invalidated.
 *
 * @param [length] The length of the range within the buffer's data store to
 * be invalidated.
 */
static inline void glInvalidateBufferSubData(GLuint buffer, GLintptr offset,
                                             GLsizeiptr length)
{
  glad_glInvalidateBufferSubData(buffer, offset, length);
}
/**
 * glInvalidateFramebuffer, glInvalidateNamedFramebufferData — invalidate the
 * content of some or all of a framebuffer's attachments
 *
 * @param [target] Specifies the target to which the framebuffer object is
 * attached for glInvalidateFramebuffer.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glInvalidateNamedFramebufferData.
 *
 * @param [numAttachments] Specifies the number of entries in the attachments
 * array.
 *
 * @param [attachments] Specifies a pointer to an array identifying the
 * attachments to be invalidated.
 */
static inline void glInvalidateFramebuffer(GLenum target,
                                           GLsizei numAttachments,
                                           const GLenum *attachments)
{
  glad_glInvalidateFramebuffer(target, numAttachments, attachments);
}
/**
 * glInvalidateFramebuffer, glInvalidateNamedFramebufferData — invalidate the
 * content of some or all of a framebuffer's attachments
 *
 * @param [target] Specifies the target to which the framebuffer object is
 * attached for glInvalidateFramebuffer.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glInvalidateNamedFramebufferData.
 *
 * @param [numAttachments] Specifies the number of entries in the attachments
 * array.
 *
 * @param [attachments] Specifies a pointer to an array identifying the
 * attachments to be invalidated.
 */
static inline void glInvalidateNamedFramebufferData(GLuint framebuffer,
                                                    GLsizei numAttachments,
                                                    const GLenum *attachments)
{
  glad_glInvalidateNamedFramebufferData(framebuffer, numAttachments,
                                        attachments);
}
/**
 * glInvalidateSubFramebuffer, glInvalidateNamedFramebufferSubData —
 * invalidate the content of a region of some or all of a framebuffer's
 * attachments
 *
 * @param [target] Specifies the target to which the framebuffer object is
 * attached for glInvalidateSubFramebuffer.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glInvalidateNamedFramebufferSubData.
 *
 * @param [numAttachments] Specifies the number of entries in the attachments
 * array.
 *
 * @param [attachments] Specifies a pointer to an array identifying the
 * attachments to be invalidated.
 *
 * @param [x] Specifies the X offset of the region to be invalidated.
 *
 * @param [y] Specifies the Y offset of the region to be invalidated.
 *
 * @param [width] Specifies the width of the region to be invalidated.
 *
 * @param [height] Specifies the height of the region to be invalidated.
 */
static inline void glInvalidateSubFramebuffer(GLenum target,
                                              GLsizei numAttachments,
                                              const GLenum *attachments,
                                              GLint x, GLint y, GLint width,
                                              GLint height)
{
  glad_glInvalidateSubFramebuffer(target, numAttachments, attachments, x, y,
                                  width, height);
}
/**
 * glInvalidateSubFramebuffer, glInvalidateNamedFramebufferSubData —
 * invalidate the content of a region of some or all of a framebuffer's
 * attachments
 *
 * @param [target] Specifies the target to which the framebuffer object is
 * attached for glInvalidateSubFramebuffer.
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glInvalidateNamedFramebufferSubData.
 *
 * @param [numAttachments] Specifies the number of entries in the attachments
 * array.
 *
 * @param [attachments] Specifies a pointer to an array identifying the
 * attachments to be invalidated.
 *
 * @param [x] Specifies the X offset of the region to be invalidated.
 *
 * @param [y] Specifies the Y offset of the region to be invalidated.
 *
 * @param [width] Specifies the width of the region to be invalidated.
 *
 * @param [height] Specifies the height of the region to be invalidated.
 */
static inline void
glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments,
                                    const GLenum *attachments, GLint x, GLint y,
                                    GLsizei width, GLsizei height)
{
  glad_glInvalidateNamedFramebufferSubData(framebuffer, numAttachments,
                                           attachments, x, y, width, height);
}
/**
 * glInvalidateTexImage — invalidate the entirety a texture image
 *
 * @param [texture] The name of a texture object to invalidate.
 *
 * @param [level] The level of detail of the texture object to invalidate.
 */
static inline void glInvalidateTexImage(GLuint texture, GLint level)
{
  glad_glInvalidateTexImage(texture, level);
}
/**
 * glInvalidateTexSubImage — invalidate a region of a texture image
 *
 * @param [texture] The name of a texture object a subregion of which to
 * invalidate.
 *
 * @param [level] The level of detail of the texture object within which the
 * region resides.
 *
 * @param [xoffset] The X offset of the region to be invalidated.
 *
 * @param [yoffset] The Y offset of the region to be invalidated.
 *
 * @param [zoffset] The Z offset of the region to be invalidated.
 *
 * @param [width] The width of the region to be invalidated.
 *
 * @param [height] The height of the region to be invalidated.
 *
 * @param [depth] The depth of the region to be invalidated.
 */
static inline void glInvalidateTexSubImage(GLuint texture, GLint level,
                                           GLint xoffset, GLint yoffset,
                                           GLint zoffset, GLsizei width,
                                           GLsizei height, GLsizei depth)
{
  glad_glInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width,
                               height, depth);
}
/**
 * glIsBuffer — determine if a name corresponds to a buffer object
 *
 * @param [buffer] Specifies a value that may be the name of a buffer object.
 */
static inline GLboolean glIsBuffer(GLuint buffer)
{
  return glad_glIsBuffer(buffer);
}
/**
 * glIsEnabled, glIsEnabledi — test whether a capability is enabled
 *
 * @param [cap] Specifies a symbolic constant indicating a GL capability.
 *
 * @param [index] Specifies the index of the capability.
 */
static inline GLboolean glIsEnabled(GLenum cap)
{
  return glad_glIsEnabled(cap);
}
/**
 * glIsEnabled, glIsEnabledi — test whether a capability is enabled
 *
 * @param [cap] Specifies a symbolic constant indicating a GL capability.
 *
 * @param [index] Specifies the index of the capability.
 */
static inline GLboolean glIsEnabledi(GLenum cap, GLuint index)
{
  return glad_glIsEnabledi(cap, index);
}
/**
 * glIsFramebuffer — determine if a name corresponds to a framebuffer object
 *
 * @param [framebuffer] Specifies a value that may be the name of a
 * framebuffer object.
 */
static inline GLboolean glIsFramebuffer(GLuint framebuffer)
{
  return glad_glIsFramebuffer(framebuffer);
}
/**
 * glIsProgram — Determines if a name corresponds to a program object
 *
 * @param [program] Specifies a potential program object.
 */
static inline GLboolean glIsProgram(GLuint program)
{
  return glad_glIsProgram(program);
}
/**
 * glIsProgramPipeline — determine if a name corresponds to a program pipeline
 * object
 *
 * @param [pipeline] Specifies a value that may be the name of a program
 * pipeline object.
 */
static inline GLboolean glIsProgramPipeline(GLuint pipeline)
{
  return glad_glIsProgramPipeline(pipeline);
}
/**
 * glIsQuery — determine if a name corresponds to a query object
 *
 * @param [id] Specifies a value that may be the name of a query object.
 */
static inline GLboolean glIsQuery(GLuint id) { return glad_glIsQuery(id); }
/**
 * glIsRenderbuffer — determine if a name corresponds to a renderbuffer object
 *
 * @param [renderbuffer] Specifies a value that may be the name of a
 * renderbuffer object.
 */
static inline GLboolean glIsRenderbuffer(GLuint renderbuffer)
{
  return glad_glIsRenderbuffer(renderbuffer);
}
/**
 * glIsSampler — determine if a name corresponds to a sampler object
 *
 * @param [id] Specifies a value that may be the name of a sampler object.
 */
static inline GLboolean glIsSampler(GLuint id) { return glad_glIsSampler(id); }
/**
 * glIsShader — Determines if a name corresponds to a shader object
 *
 * @param [shader] Specifies a potential shader object.
 */
static inline GLboolean glIsShader(GLuint shader)
{
  return glad_glIsShader(shader);
}
/**
 * glIsSync — determine if a name corresponds to a sync object
 *
 * @param [sync] Specifies a value that may be the name of a sync object.
 */
static inline GLboolean glIsSync(GLsync sync) { return glad_glIsSync(sync); }
/**
 * glIsTexture — determine if a name corresponds to a texture
 *
 * @param [texture] Specifies a value that may be the name of a texture.
 */
static inline GLboolean glIsTexture(GLuint texture)
{
  return glad_glIsTexture(texture);
}
/**
 * glIsTransformFeedback — determine if a name corresponds to a transform
 * feedback object
 *
 * @param [id] Specifies a value that may be the name of a transform feedback
 * object.
 */
static inline GLboolean glIsTransformFeedback(GLuint id)
{
  return glad_glIsTransformFeedback(id);
}
/**
 * glIsVertexArray — determine if a name corresponds to a vertex array object
 *
 * @param [array] Specifies a value that may be the name of a vertex array
 * object.
 */
static inline GLboolean glIsVertexArray(GLuint array)
{
  return glad_glIsVertexArray(array);
}
/**
 * glLineWidth — specify the width of rasterized lines
 *
 * @param [width] Specifies the width of rasterized lines. The initial value
 * is 1.
 */
static inline void glLineWidth(GLfloat width) { glad_glLineWidth(width); }
/**
 * glLinkProgram — Links a program object
 *
 * @param [program] Specifies the handle of the program object to be linked.
 */
static inline void glLinkProgram(GLuint program)
{
  glad_glLinkProgram(program);
}
/**
 * glLogicOp — specify a logical pixel operation for rendering
 *
 * @param [opcode] Specifies a symbolic constant that selects a logical
 * operation. The following symbols are accepted: GL_CLEAR, GL_SET, GL_COPY,
 * GL_COPY_INVERTED, GL_NOOP, GL_INVERT, GL_AND, GL_NAND, GL_OR, GL_NOR,
 * GL_XOR, GL_EQUIV, GL_AND_REVERSE, GL_AND_INVERTED, GL_OR_REVERSE, and
 * GL_OR_INVERTED. The initial value is GL_COPY.
 */
static inline void glLogicOp(GLenum opcode) { glad_glLogicOp(opcode); }
/**
 * glMapBuffer, glMapNamedBuffer — map all of a buffer object's data store
 * into the client's address space
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glMapBuffer, which must be one of the buffer binding targets in the
 * following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glMapNamedBuffer.
 *
 * @param [access] Specifies the access policy for glMapBuffer and
 * glMapNamedBuffer, indicating whether it will be possible to read from,
 * write to, or both read from and write to the buffer object's mapped data
 * store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or
 * GL_READ_WRITE.
 */
static inline void *glMapBuffer(GLenum target, GLenum access)
{
  return glad_glMapBuffer(target, access);
}
/**
 * glMapBuffer, glMapNamedBuffer — map all of a buffer object's data store
 * into the client's address space
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glMapBuffer, which must be one of the buffer binding targets in the
 * following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glMapNamedBuffer.
 *
 * @param [access] Specifies the access policy for glMapBuffer and
 * glMapNamedBuffer, indicating whether it will be possible to read from,
 * write to, or both read from and write to the buffer object's mapped data
 * store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or
 * GL_READ_WRITE.
 */
static inline void *glMapNamedBuffer(GLuint buffer, GLenum access)
{
  return glad_glMapNamedBuffer(buffer, access);
}
/**
 * glMapBufferRange, glMapNamedBufferRange — map all or part of a buffer
 * object's data store into the client's address space
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glMapBufferRange, which must be one of the buffer binding targets in
 * the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glMapNamedBufferRange.
 *
 * @param [offset] Specifies the starting offset within the buffer of the
 * range to be mapped.
 *
 * @param [length] Specifies the length of the range to be mapped.
 *
 * @param [access] Specifies a combination of access flags indicating the
 * desired access to the mapped range.
 */
static inline void *glMapBufferRange(GLenum target, GLintptr offset,
                                     GLsizeiptr length, GLbitfield access)
{
  return glad_glMapBufferRange(target, offset, length, access);
}
/**
 * glMapBufferRange, glMapNamedBufferRange — map all or part of a buffer
 * object's data store into the client's address space
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glMapBufferRange, which must be one of the buffer binding targets in
 * the following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glMapNamedBufferRange.
 *
 * @param [offset] Specifies the starting offset within the buffer of the
 * range to be mapped.
 *
 * @param [length] Specifies the length of the range to be mapped.
 *
 * @param [access] Specifies a combination of access flags indicating the
 * desired access to the mapped range.
 */
static inline void *glMapNamedBufferRange(GLuint buffer, GLintptr offset,
                                          GLsizei length, GLbitfield access)
{
  return glad_glMapNamedBufferRange(buffer, offset, length, access);
}
/**
 * glMemoryBarrier — defines a barrier ordering memory transactions
 *
 * @param [barriers] Specifies the barriers to insert.
 */
static inline void glMemoryBarrier(GLbitfield barriers)
{
  glad_glMemoryBarrier(barriers);
}
/**
 * glMemoryBarrier — defines a barrier ordering memory transactions
 *
 * @param [barriers] Specifies the barriers to insert.
 */
static inline void glMemoryBarrierByRegion(GLbitfield barriers)
{
  glad_glMemoryBarrierByRegion(barriers);
}
/**
 * glMinSampleShading — specifies minimum rate at which sample shading takes
 * place
 *
 * @param [value] Specifies the rate at which samples are shaded within each
 * covered pixel.
 */
static inline void glMinSampleShading(GLfloat value)
{
  glad_glMinSampleShading(value);
}
/**
 * glMultiDrawArrays — render multiple sets of primitives from array data
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
 *
 * @param [first] Points to an array of starting indices in the enabled
 * arrays.
 *
 * @param [count] Points to an array of the number of indices to be rendered.
 *
 * @param [drawcount] Specifies the size of the first and count
 */
static inline void glMultiDrawArrays(GLenum mode, const GLint *first,
                                     const GLsizei *count, GLsizei drawcount)
{
  glad_glMultiDrawArrays(mode, first, count, drawcount);
}
/**
 * glMultiDrawArraysIndirect — render multiple sets of primitives from array
 * data, taking parameters from memory
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.
 *
 * @param [indirect] Specifies the address of an array of structures
 * containing the draw parameters.
 *
 * @param [drawcount] Specifies the the number of elements in the array of
 * draw parameter structures.
 *
 * @param [stride] Specifies the distance in basic machine units between
 * elements of the draw parameter array.
 */
static inline void glMultiDrawArraysIndirect(GLenum mode, const void *indirect,
                                             GLsizei drawcount, GLsizei stride)
{
  glad_glMultiDrawArraysIndirect(mode, indirect, drawcount, stride);
}
/**
 * glMultiDrawElements — render multiple sets of primitives by specifying
 * indices of array data elements
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
 *
 * @param [count] Points to an array of the elements counts.
 *
 * @param [type] Specifies the type of the values in indices. Must be one of
 * GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
 *
 * @param [indices] Specifies a pointer to the location where the indices are
 * stored.
 *
 * @param [drawcount] Specifies the size of the count and indices arrays.
 */
static inline void glMultiDrawElements(GLenum mode, const GLsizei *count,
                                       GLenum type,
                                       const GLvoid *const *indices,
                                       GLsizei drawcount)
{
  glad_glMultiDrawElements(mode, count, type, indices, drawcount);
}
/**
 * glMultiDrawElementsBaseVertex — render multiple sets of primitives by
 * specifying indices of array data elements and an index to apply to each
 * index
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
 *
 * @param [count] Points to an array of the elements counts.
 *
 * @param [type] Specifies the type of the values in indices. Must be one of
 * GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
 *
 * @param [indices] Specifies a pointer to the location where the indices are
 * stored.
 *
 * @param [drawcount] Specifies the size of the count, indices and basevertex
 * arrays.
 *
 * @param [basevertex] Specifies a pointer to the location where the base
 * vertices are stored.
 */
static inline void
glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type,
                              const GLvoid *const *indices, GLsizei drawcount,
                              const GLint *basevertex)
{
  glad_glMultiDrawElementsBaseVertex(mode, count, type, indices, drawcount,
                                     basevertex);
}
/**
 * glMultiDrawElementsIndirect — render indexed primitives from array data,
 * taking parameters from memory
 *
 * @param [mode] Specifies what kind of primitives to render. Symbolic
 * constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,
 * GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
 * GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY,
 * GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.
 *
 * @param [type] Specifies the type of data in the buffer bound to the
 * GL_ELEMENT_ARRAY_BUFFER binding.
 *
 * @param [indirect] Specifies the address of a structure containing an array
 * of draw parameters.
 *
 * @param [drawcount] Specifies the number of elements in the array addressed
 * by indirect.
 *
 * @param [stride] Specifies the distance in basic machine units between
 * elements of the draw parameter array.
 */
static inline void glMultiDrawElementsIndirect(GLenum mode, GLenum type,
                                               const void *indirect,
                                               GLsizei drawcount,
                                               GLsizei stride)
{
  glad_glMultiDrawElementsIndirect(mode, type, indirect, drawcount, stride);
}
/**
 * glObjectLabel — label a named object identified within a namespace
 *
 * @param [identifier] The namespace from which the name of the object is
 * allocated.
 *
 * @param [name] The name of the object to label.
 *
 * @param [length] The length of the label to be used for the object.
 *
 * @param [label] The address of a string containing the label to assign to
 * the object.
 */
static inline void glObjectLabel(GLenum identifier, GLuint name, GLsizei length,
                                 const char *label)
{
  glad_glObjectLabel(identifier, name, length, label);
}
/**
 * glObjectPtrLabel — label a a sync object identified by a pointer
 *
 * @param [ptr] A pointer identifying a sync object.
 *
 * @param [length] The length of the label to be used for the object.
 *
 * @param [label] The address of a string containing the label to assign to
 * the object.
 */
static inline void glObjectPtrLabel(void *ptr, GLsizei length,
                                    const char *label)
{
  glad_glObjectPtrLabel(ptr, length, label);
}
/**
 * glPatchParameter — specifies the parameters for patch primitives
 *
 * @param [pname] Specifies the name of the parameter to set. The symbolc
 * constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and
 * GL_PATCH_DEFAULT_INNER_LEVEL are accepted.
 *
 * @param [value] Specifies the new value for the parameter given by pname.
 *
 * @param [values] Specifies the address of an array containing the new values
 * for the parameter given by pname.
 */
static inline void glPatchParameteri(GLenum pname, GLint value)
{
  glad_glPatchParameteri(pname, value);
}
/**
 * glPatchParameter — specifies the parameters for patch primitives
 *
 * @param [pname] Specifies the name of the parameter to set. The symbolc
 * constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and
 * GL_PATCH_DEFAULT_INNER_LEVEL are accepted.
 *
 * @param [value] Specifies the new value for the parameter given by pname.
 *
 * @param [values] Specifies the address of an array containing the new values
 * for the parameter given by pname.
 */
static inline void glPatchParameterfv(GLenum pname, const GLfloat *values)
{
  glad_glPatchParameterfv(pname, values);
}
/**
 * glPauseTransformFeedback — pause transform feedback operations
 */
static inline void glPauseTransformFeedback(void)
{
  glad_glPauseTransformFeedback();
}
/**
 * glPixelStore — set pixel storage modes
 *
 * @param [pname] Specifies the symbolic name of the parameter to be set. Six
 * values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES,
 * GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT,
 * GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and
 * GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory:
 * GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH,
 * GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS,
 * GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT.
 *
 * @param [param] Specifies the value that pname is set to.
 */
static inline void glPixelStoref(GLenum pname, GLfloat param)
{
  glad_glPixelStoref(pname, param);
}
/**
 * glPixelStore — set pixel storage modes
 *
 * @param [pname] Specifies the symbolic name of the parameter to be set. Six
 * values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES,
 * GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT,
 * GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and
 * GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory:
 * GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH,
 * GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS,
 * GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT.
 *
 * @param [param] Specifies the value that pname is set to.
 */
static inline void glPixelStorei(GLenum pname, GLint param)
{
  glad_glPixelStorei(pname, param);
}
/**
 * glPointParameter — specify point parameters
 *
 * @param [pname] Specifies a single-valued point parameter.
 * GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are
 * accepted.
 *
 * @param [param] For glPointParameterf and glPointParameteri, specifies the
 * value that pname will be set to.
 *
 * @param [params] For glPointParameterfv and glPointParameteriv, specifies a
 * pointer to an array where the value or values to be assigned to pname are
 * stored.
 */
static inline void glPointParameterf(GLenum pname, GLfloat param)
{
  glad_glPointParameterf(pname, param);
}
/**
 * glPointParameter — specify point parameters
 *
 * @param [pname] Specifies a single-valued point parameter.
 * GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are
 * accepted.
 *
 * @param [param] For glPointParameterf and glPointParameteri, specifies the
 * value that pname will be set to.
 *
 * @param [params] For glPointParameterfv and glPointParameteriv, specifies a
 * pointer to an array where the value or values to be assigned to pname are
 * stored.
 */
static inline void glPointParameteri(GLenum pname, GLint param)
{
  glad_glPointParameteri(pname, param);
}
/**
 * glPointParameter — specify point parameters
 *
 * @param [pname] Specifies a single-valued point parameter.
 * GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are
 * accepted.
 *
 * @param [param] For glPointParameterf and glPointParameteri, specifies the
 * value that pname will be set to.
 *
 * @param [params] For glPointParameterfv and glPointParameteriv, specifies a
 * pointer to an array where the value or values to be assigned to pname are
 * stored.
 */
static inline void glPointParameterfv(GLenum pname, const GLfloat *params)
{
  glad_glPointParameterfv(pname, params);
}
/**
 * glPointParameter — specify point parameters
 *
 * @param [pname] Specifies a single-valued point parameter.
 * GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are
 * accepted.
 *
 * @param [param] For glPointParameterf and glPointParameteri, specifies the
 * value that pname will be set to.
 *
 * @param [params] For glPointParameterfv and glPointParameteriv, specifies a
 * pointer to an array where the value or values to be assigned to pname are
 * stored.
 */
static inline void glPointParameteriv(GLenum pname, const GLint *params)
{
  glad_glPointParameteriv(pname, params);
}
/**
 * glPointSize — specify the diameter of rasterized points
 *
 * @param [size] Specifies the diameter of rasterized points. The initial
 * value is 1.
 */
static inline void glPointSize(GLfloat size) { glad_glPointSize(size); }
/**
 * glPolygonMode — select a polygon rasterization mode
 *
 * @param [face] Specifies the polygons that mode applies to. Must be
 * GL_FRONT_AND_BACK for front- and back-facing polygons.
 *
 * @param [mode] Specifies how polygons will be rasterized. Accepted values
 * are GL_POINT, GL_LINE, and GL_FILL. The initial value is GL_FILL for both
 * front- and back-facing polygons.
 */
static inline void glPolygonMode(GLenum face, GLenum mode)
{
  glad_glPolygonMode(face, mode);
}
/**
 * glPolygonOffset — set the scale and units used to calculate depth values
 *
 * @param [factor] Specifies a scale factor that is used to create a variable
 * depth offset for each polygon. The initial value is 0.
 *
 * @param [units] Is multiplied by an implementation-specific value to create
 * a constant depth offset. The initial value is 0.
 */
static inline void glPolygonOffset(GLfloat factor, GLfloat units)
{
  glad_glPolygonOffset(factor, units);
}
/**
 * glPopDebugGroup — pop the active debug group
 */
static inline void glPopDebugGroup(void) { glad_glPopDebugGroup(); }
/**
 * glPrimitiveRestartIndex — specify the primitive restart index
 *
 * @param [index] Specifies the value to be interpreted as the primitive
 * restart index.
 */
static inline void glPrimitiveRestartIndex(GLuint index)
{
  glad_glPrimitiveRestartIndex(index);
}
/**
 * glProgramBinary — load a program object with a program binary
 *
 * @param [program] Specifies the name of a program object into which to load
 * a program binary.
 *
 * @param [binaryFormat] Specifies the format of the binary data in binary.
 *
 * @param [binary] Specifies the address an array containing the binary to be
 * loaded into program.
 *
 * @param [length] Specifies the number of bytes contained in binary.
 */
static inline void glProgramBinary(GLuint program, GLenum binaryFormat,
                                   const void *binary, GLsizei length)
{
  glad_glProgramBinary(program, binaryFormat, binary, length);
}
/**
 * glProgramParameter — specify a parameter for a program object
 *
 * @param [program] Specifies the name of a program object whose parameter to
 * modify.
 *
 * @param [pname] Specifies the name of the parameter to modify.
 *
 * @param [value] Specifies the new value of the parameter specified by pname
 * for program.
 */
static inline void glProgramParameteri(GLuint program, GLenum pname,
                                       GLint value)
{
  glad_glProgramParameteri(program, pname, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform1f(GLuint program, GLint location,
                                      GLfloat v0)
{
  glad_glProgramUniform1f(program, location, v0);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform2f(GLuint program, GLint location,
                                      GLfloat v0, GLfloat v1)
{
  glad_glProgramUniform2f(program, location, v0, v1);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform3f(GLuint program, GLint location,
                                      GLfloat v0, GLfloat v1, GLfloat v2)
{
  glad_glProgramUniform3f(program, location, v0, v1, v2);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform4f(GLuint program, GLint location,
                                      GLfloat v0, GLfloat v1, GLfloat v2,
                                      GLfloat v3)
{
  glad_glProgramUniform4f(program, location, v0, v1, v2, v3);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform1i(GLuint program, GLint location, GLint v0)
{
  glad_glProgramUniform1i(program, location, v0);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform2i(GLuint program, GLint location, GLint v0,
                                      GLint v1)
{
  glad_glProgramUniform2i(program, location, v0, v1);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform3i(GLuint program, GLint location, GLint v0,
                                      GLint v1, GLint v2)
{
  glad_glProgramUniform3i(program, location, v0, v1, v2);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform4i(GLuint program, GLint location, GLint v0,
                                      GLint v1, GLint v2, GLint v3)
{
  glad_glProgramUniform4i(program, location, v0, v1, v2, v3);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform1ui(GLuint program, GLint location,
                                       GLuint v0)
{
  glad_glProgramUniform1ui(program, location, v0);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform2ui(GLuint program, GLint location,
                                       GLuint v0, GLuint v1)
{
  glad_glProgramUniform2ui(program, location, v0, v1);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform3ui(GLuint program, GLint location,
                                       GLuint v0, GLuint v1, GLuint v2)
{
  glad_glProgramUniform3ui(program, location, v0, v1, v2);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform4ui(GLuint program, GLint location,
                                       GLuint v0, GLuint v1, GLuint v2,
                                       GLuint v3)
{
  glad_glProgramUniform4ui(program, location, v0, v1, v2, v3);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform1fv(GLuint program, GLint location,
                                       GLsizei count, const GLfloat *value)
{
  glad_glProgramUniform1fv(program, location, count, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform2fv(GLuint program, GLint location,
                                       GLsizei count, const GLfloat *value)
{
  glad_glProgramUniform2fv(program, location, count, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform3fv(GLuint program, GLint location,
                                       GLsizei count, const GLfloat *value)
{
  glad_glProgramUniform3fv(program, location, count, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform4fv(GLuint program, GLint location,
                                       GLsizei count, const GLfloat *value)
{
  glad_glProgramUniform4fv(program, location, count, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform1iv(GLuint program, GLint location,
                                       GLsizei count, const GLint *value)
{
  glad_glProgramUniform1iv(program, location, count, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform2iv(GLuint program, GLint location,
                                       GLsizei count, const GLint *value)
{
  glad_glProgramUniform2iv(program, location, count, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform3iv(GLuint program, GLint location,
                                       GLsizei count, const GLint *value)
{
  glad_glProgramUniform3iv(program, location, count, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform4iv(GLuint program, GLint location,
                                       GLsizei count, const GLint *value)
{
  glad_glProgramUniform4iv(program, location, count, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform1uiv(GLuint program, GLint location,
                                        GLsizei count, const GLuint *value)
{
  glad_glProgramUniform1uiv(program, location, count, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform2uiv(GLuint program, GLint location,
                                        GLsizei count, const GLuint *value)
{
  glad_glProgramUniform2uiv(program, location, count, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform3uiv(GLuint program, GLint location,
                                        GLsizei count, const GLuint *value)
{
  glad_glProgramUniform3uiv(program, location, count, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniform4uiv(GLuint program, GLint location,
                                        GLsizei count, const GLuint *value)
{
  glad_glProgramUniform4uiv(program, location, count, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniformMatrix2fv(GLuint program, GLint location,
                                             GLsizei count, GLboolean transpose,
                                             const GLfloat *value)
{
  glad_glProgramUniformMatrix2fv(program, location, count, transpose, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniformMatrix3fv(GLuint program, GLint location,
                                             GLsizei count, GLboolean transpose,
                                             const GLfloat *value)
{
  glad_glProgramUniformMatrix3fv(program, location, count, transpose, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniformMatrix4fv(GLuint program, GLint location,
                                             GLsizei count, GLboolean transpose,
                                             const GLfloat *value)
{
  glad_glProgramUniformMatrix4fv(program, location, count, transpose, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniformMatrix2x3fv(GLuint program, GLint location,
                                               GLsizei count,
                                               GLboolean transpose,
                                               const GLfloat *value)
{
  glad_glProgramUniformMatrix2x3fv(program, location, count, transpose, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniformMatrix3x2fv(GLuint program, GLint location,
                                               GLsizei count,
                                               GLboolean transpose,
                                               const GLfloat *value)
{
  glad_glProgramUniformMatrix3x2fv(program, location, count, transpose, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniformMatrix2x4fv(GLuint program, GLint location,
                                               GLsizei count,
                                               GLboolean transpose,
                                               const GLfloat *value)
{
  glad_glProgramUniformMatrix2x4fv(program, location, count, transpose, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniformMatrix4x2fv(GLuint program, GLint location,
                                               GLsizei count,
                                               GLboolean transpose,
                                               const GLfloat *value)
{
  glad_glProgramUniformMatrix4x2fv(program, location, count, transpose, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniformMatrix3x4fv(GLuint program, GLint location,
                                               GLsizei count,
                                               GLboolean transpose,
                                               const GLfloat *value)
{
  glad_glProgramUniformMatrix3x4fv(program, location, count, transpose, value);
}
/**
 * glProgramUniform — Specify the value of a uniform variable for a specified
 * program object
 *
 * @param [program] Specifies the handle of the program containing the uniform
 * variable to be modified.
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector commands (glProgramUniform*v), specifies the
 * number of elements that are to be modified. This should be 1 if the
 * targeted uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glProgramUniformMatrix4x3fv(GLuint program, GLint location,
                                               GLsizei count,
                                               GLboolean transpose,
                                               const GLfloat *value)
{
  glad_glProgramUniformMatrix4x3fv(program, location, count, transpose, value);
}
/**
 * glProvokingVertex — specifiy the vertex to be used as the source of data
 * for flat shaded varyings
 *
 * @param [provokeMode] Specifies the vertex to be used as the source of data
 * for flat shaded varyings.
 */
static inline void glProvokingVertex(GLenum provokeMode)
{
  glad_glProvokingVertex(provokeMode);
}
/**
 * glPushDebugGroup — push a named debug group into the command stream
 *
 * @param [source] The source of the debug message.
 *
 * @param [id] The identifier of the message.
 *
 * @param [length] The length of the message to be sent to the debug output
 * stream.
 *
 * @param [message] The a string containing the message to be sent to the
 * debug output stream.
 */
static inline void glPushDebugGroup(GLenum source, GLuint id, GLsizei length,
                                    const char *message)
{
  glad_glPushDebugGroup(source, id, length, message);
}
/**
 * glQueryCounter — record the GL time into a query object after all previous
 * commands have reached the GL server but have not yet necessarily executed.
 *
 * @param [id] Specify the name of a query object into which to record the GL
 * time.
 *
 * @param [target] Specify the counter to query. target must be GL_TIMESTAMP.
 */
static inline void glQueryCounter(GLuint id, GLenum target)
{
  glad_glQueryCounter(id, target);
}
/**
 * glReadBuffer, glNamedFramebufferReadBuffer — select a color buffer source
 * for pixels
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glNamedFramebufferReadBuffer function.
 *
 * @param [mode] Specifies a color buffer. Accepted values are GL_FRONT_LEFT,
 * GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT,
 * GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.
 */
static inline void glReadBuffer(GLenum mode) { glad_glReadBuffer(mode); }
/**
 * glReadBuffer, glNamedFramebufferReadBuffer — select a color buffer source
 * for pixels
 *
 * @param [framebuffer] Specifies the name of the framebuffer object for
 * glNamedFramebufferReadBuffer function.
 *
 * @param [mode] Specifies a color buffer. Accepted values are GL_FRONT_LEFT,
 * GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT,
 * GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.
 */
static inline void glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum mode)
{
  glad_glNamedFramebufferReadBuffer(framebuffer, mode);
}
/**
 * glReadPixels, glReadnPixels — read a block of pixels from the frame buffer
 *
 * @param [x, y] Specify the window coordinates of the first pixel that is
 * read from the frame buffer. This location is the lower left corner of a
 * rectangular block of pixels.
 *
 * @param [width, height] Specify the dimensions of the pixel rectangle. width
 * and height of one correspond to a single pixel.
 *
 * @param [format] Specifies the format of the pixel data. The following
 * symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT,
 * GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and
 * GL_BGRA.
 *
 * @param [type] Specifies the data type of the pixel data. Must be one of
 * GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT,
 * GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
 * GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
 * GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,
 * GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
 * GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
 * GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
 * GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8,
 * GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or
 * GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
 *
 * @param [bufSize] Specifies the size of the buffer data for glReadnPixels
 * function.
 *
 * @param [data] Returns the pixel data.
 */
static inline void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                                GLenum format, GLenum type, GLvoid *data)
{
  glad_glReadPixels(x, y, width, height, format, type, data);
}
/**
 * glReadPixels, glReadnPixels — read a block of pixels from the frame buffer
 *
 * @param [x, y] Specify the window coordinates of the first pixel that is
 * read from the frame buffer. This location is the lower left corner of a
 * rectangular block of pixels.
 *
 * @param [width, height] Specify the dimensions of the pixel rectangle. width
 * and height of one correspond to a single pixel.
 *
 * @param [format] Specifies the format of the pixel data. The following
 * symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT,
 * GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and
 * GL_BGRA.
 *
 * @param [type] Specifies the data type of the pixel data. Must be one of
 * GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT,
 * GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
 * GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
 * GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,
 * GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
 * GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
 * GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2,
 * GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8,
 * GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or
 * GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
 *
 * @param [bufSize] Specifies the size of the buffer data for glReadnPixels
 * function.
 *
 * @param [data] Returns the pixel data.
 */
static inline void glReadnPixels(GLint x, GLint y, GLsizei width,
                                 GLsizei height, GLenum format, GLenum type,
                                 GLsizei bufSize, void *data)
{
  glad_glReadnPixels(x, y, width, height, format, type, bufSize, data);
}
/**
 * glReleaseShaderCompiler — release resources consumed by the
 * implementation's shader compiler
 */
static inline void glReleaseShaderCompiler(void)
{
  glad_glReleaseShaderCompiler();
}
/**
 * glRenderbufferStorage, glNamedRenderbufferStorage — establish data storage,
 format and dimensions of a renderbuffer object's image
 *
 * @param [target] Specifies a binding target of the allocation for
 glRenderbufferStorage function. Must be GL_RENDERBUFFER.
 *
 * @param [renderbuffer] Specifies the name of the renderbuffer object for
 glNamedRenderbufferStorage function.
 *
 * @param [internalformat] Specifies the internal format to use for the
 renderbuffer object's image.
 *
 * @param [width] Specifies the width of the renderbuffer, in pixels.
 *
 * @param [height] Specifies the height of the renderbuffer, in pixels.
 */
static inline void glRenderbufferStorage(GLenum target, GLenum internalformat,
                                         GLsizei width, GLsizei height)
{
  glad_glRenderbufferStorage(target, internalformat, width, height);
}
/**
 * glRenderbufferStorage, glNamedRenderbufferStorage — establish data storage,
 format and dimensions of a renderbuffer object's image
 *
 * @param [target] Specifies a binding target of the allocation for
 glRenderbufferStorage function. Must be GL_RENDERBUFFER.
 *
 * @param [renderbuffer] Specifies the name of the renderbuffer object for
 glNamedRenderbufferStorage function.
 *
 * @param [internalformat] Specifies the internal format to use for the
 renderbuffer object's image.
 *
 * @param [width] Specifies the width of the renderbuffer, in pixels.
 *
 * @param [height] Specifies the height of the renderbuffer, in pixels.
 */
static inline void glNamedRenderbufferStorage(GLuint renderbuffer,
                                              GLenum internalformat,
                                              GLsizei width, GLsizei height)
{
  glad_glNamedRenderbufferStorage(renderbuffer, internalformat, width, height);
}
/**
 * glRenderbufferStorageMultisample, glNamedRenderbufferStorageMultisample —
 establish data storage, format, dimensions and sample count of a renderbuffer
 object's image
 *
 * @param [target] Specifies a binding target of the allocation for
 glRenderbufferStorageMultisample function. Must be GL_RENDERBUFFER.
 *
 * @param [renderbuffer] Specifies the name of the renderbuffer object for
 glNamedRenderbufferStorageMultisample function.
 *
 * @param [samples] Specifies the number of samples to be used for the
 renderbuffer object's storage.
 *
 * @param [internalformat] Specifies the internal format to use for the
 renderbuffer object's image.
 *
 * @param [width] Specifies the width of the renderbuffer, in pixels.
 *
 * @param [height] Specifies the height of the renderbuffer, in pixels.
 */
static inline void glRenderbufferStorageMultisample(GLenum target,
                                                    GLsizei samples,
                                                    GLenum internalformat,
                                                    GLsizei width,
                                                    GLsizei height)
{
  glad_glRenderbufferStorageMultisample(target, samples, internalformat, width,
                                        height);
}
/**
 * glRenderbufferStorageMultisample, glNamedRenderbufferStorageMultisample —
 establish data storage, format, dimensions and sample count of a renderbuffer
 object's image
 *
 * @param [target] Specifies a binding target of the allocation for
 glRenderbufferStorageMultisample function. Must be GL_RENDERBUFFER.
 *
 * @param [renderbuffer] Specifies the name of the renderbuffer object for
 glNamedRenderbufferStorageMultisample function.
 *
 * @param [samples] Specifies the number of samples to be used for the
 renderbuffer object's storage.
 *
 * @param [internalformat] Specifies the internal format to use for the
 renderbuffer object's image.
 *
 * @param [width] Specifies the width of the renderbuffer, in pixels.
 *
 * @param [height] Specifies the height of the renderbuffer, in pixels.
 */
static inline void glNamedRenderbufferStorageMultisample(GLuint renderbuffer,
                                                         GLsizei samples,
                                                         GLenum internalformat,
                                                         GLsizei width,
                                                         GLsizei height)
{
  glad_glNamedRenderbufferStorageMultisample(renderbuffer, samples,
                                             internalformat, width, height);
}
/**
 * glResumeTransformFeedback — resume transform feedback operations
 */
static inline void glResumeTransformFeedback(void)
{
  glad_glResumeTransformFeedback();
}
/**
 * glSampleCoverage — specify multisample coverage parameters
 *
 * @param [value] Specify a single floating-point sample coverage value. The
 * value is clamped to the range [0, 1]. The initial value is 1.0.
 *
 * @param [invert] Specify a single boolean value representing if the coverage
 * masks should be inverted. GL_TRUE and GL_FALSE are accepted. The initial
 * value is GL_FALSE.
 */
static inline void glSampleCoverage(GLfloat value, GLboolean invert)
{
  glad_glSampleCoverage(value, invert);
}
/**
 * glSampleMaski — set the value of a sub-word of the sample mask
 *
 * @param [maskNumber] Specifies which 32-bit sub-word of the sample mask to
 * update.
 *
 * @param [mask] Specifies the new value of the mask sub-word.
 */
static inline void glSampleMaski(GLuint maskNumber, GLbitfield mask)
{
  glad_glSampleMaski(maskNumber, mask);
}
/**
 * glSamplerParameter — set sampler parameters
 *
 * @param [sampler] Specifies the sampler object whose parameter to modify.
 *
 * @param [pname] Specifies the symbolic name of a sampler parameter. pname
 * can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
 * GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER,
 * GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
 * GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands (glSamplerParameter*v), specifies a
 * pointer to an array where the value or values of pname are stored.
 */
static inline void glSamplerParameterf(GLuint sampler, GLenum pname,
                                       GLfloat param)
{
  glad_glSamplerParameterf(sampler, pname, param);
}
/**
 * glSamplerParameter — set sampler parameters
 *
 * @param [sampler] Specifies the sampler object whose parameter to modify.
 *
 * @param [pname] Specifies the symbolic name of a sampler parameter. pname
 * can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
 * GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER,
 * GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
 * GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands (glSamplerParameter*v), specifies a
 * pointer to an array where the value or values of pname are stored.
 */
static inline void glSamplerParameteri(GLuint sampler, GLenum pname,
                                       GLint param)
{
  glad_glSamplerParameteri(sampler, pname, param);
}
/**
 * glSamplerParameter — set sampler parameters
 *
 * @param [sampler] Specifies the sampler object whose parameter to modify.
 *
 * @param [pname] Specifies the symbolic name of a sampler parameter. pname
 * can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
 * GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER,
 * GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
 * GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands (glSamplerParameter*v), specifies a
 * pointer to an array where the value or values of pname are stored.
 */
static inline void glSamplerParameterfv(GLuint sampler, GLenum pname,
                                        const GLfloat *params)
{
  glad_glSamplerParameterfv(sampler, pname, params);
}
/**
 * glSamplerParameter — set sampler parameters
 *
 * @param [sampler] Specifies the sampler object whose parameter to modify.
 *
 * @param [pname] Specifies the symbolic name of a sampler parameter. pname
 * can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
 * GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER,
 * GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
 * GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands (glSamplerParameter*v), specifies a
 * pointer to an array where the value or values of pname are stored.
 */
static inline void glSamplerParameteriv(GLuint sampler, GLenum pname,
                                        const GLint *params)
{
  glad_glSamplerParameteriv(sampler, pname, params);
}
/**
 * glSamplerParameter — set sampler parameters
 *
 * @param [sampler] Specifies the sampler object whose parameter to modify.
 *
 * @param [pname] Specifies the symbolic name of a sampler parameter. pname
 * can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
 * GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER,
 * GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
 * GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands (glSamplerParameter*v), specifies a
 * pointer to an array where the value or values of pname are stored.
 */
static inline void glSamplerParameterIiv(GLuint sampler, GLenum pname,
                                         const GLint *params)
{
  glad_glSamplerParameterIiv(sampler, pname, params);
}
/**
 * glSamplerParameter — set sampler parameters
 *
 * @param [sampler] Specifies the sampler object whose parameter to modify.
 *
 * @param [pname] Specifies the symbolic name of a sampler parameter. pname
 * can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
 * GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER,
 * GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
 * GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands (glSamplerParameter*v), specifies a
 * pointer to an array where the value or values of pname are stored.
 */
static inline void glSamplerParameterIuiv(GLuint sampler, GLenum pname,
                                          const GLuint *params)
{
  glad_glSamplerParameterIuiv(sampler, pname, params);
}
/**
 * glScissor — define the scissor box
 *
 * @param [x, y] Specify the lower left corner of the scissor box. Initially
 * (0, 0).
 *
 * @param [width, height] Specify the width and height of the scissor box.
 * When a GL context is first attached to a window, width and height are set
 * to the dimensions of that window.
 */
static inline void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
  glad_glScissor(x, y, width, height);
}
/**
 * glScissorArray — define the scissor box for multiple viewports
 *
 * @param [first] Specifies the index of the first viewport whose scissor box
 * to modify.
 *
 * @param [count] Specifies the number of scissor boxes to modify.
 *
 * @param [v] Specifies the address of an array containing the left, bottom,
 * width and height of each scissor box, in that order.
 */
static inline void glScissorArrayv(GLuint first, GLsizei count, const GLint *v)
{
  glad_glScissorArrayv(first, count, v);
}
/**
 * glScissorIndexed — define the scissor box for a specific viewport
 *
 * @param [index] Specifies the index of the viewport whose scissor box to
 * modify.
 *
 * @param [left, bottom] Specify the coordinate of the bottom left corner of
 * the scissor box, in pixels.
 *
 * @param [width, height] Specify ths dimensions of the scissor box, in
 * pixels.
 *
 * @param [v] For glScissorIndexedv, specifies the address of an array
 * containing the left, bottom, width and height of each scissor box, in that
 * order.
 */
static inline void glScissorIndexed(GLuint index, GLint left, GLint bottom,
                                    GLsizei width, GLsizei height)
{
  glad_glScissorIndexed(index, left, bottom, width, height);
}
/**
 * glScissorIndexed — define the scissor box for a specific viewport
 *
 * @param [index] Specifies the index of the viewport whose scissor box to
 * modify.
 *
 * @param [left, bottom] Specify the coordinate of the bottom left corner of
 * the scissor box, in pixels.
 *
 * @param [width, height] Specify ths dimensions of the scissor box, in
 * pixels.
 *
 * @param [v] For glScissorIndexedv, specifies the address of an array
 * containing the left, bottom, width and height of each scissor box, in that
 * order.
 */
static inline void glScissorIndexedv(GLuint index, const GLint *v)
{
  glad_glScissorIndexedv(index, v);
}
/**
 * glShaderBinary — load pre-compiled shader binaries
 *
 * @param [count] Specifies the number of shader object handles contained in
 * shaders.
 *
 * @param [shaders] Specifies the address of an array of shader handles into
 * which to load pre-compiled shader binaries.
 *
 * @param [binaryFormat] Specifies the format of the shader binaries contained
 * in binary.
 *
 * @param [binary] Specifies the address of an array of bytes containing
 * pre-compiled binary shader code.
 *
 * @param [length] Specifies the length of the array whose address is given in
 * binary.
 */
static inline void glShaderBinary(GLsizei count, const GLuint *shaders,
                                  GLenum binaryFormat, const void *binary,
                                  GLsizei length)
{
  glad_glShaderBinary(count, shaders, binaryFormat, binary, length);
}
/**
 * glShaderSource — Replaces the source code in a shader object
 *
 * @param [shader] Specifies the handle of the shader object whose source code
 * is to be replaced.
 *
 * @param [count] Specifies the number of elements in the string and length
 * arrays.
 *
 * @param [string] Specifies an array of pointers to strings containing the
 * source code to be loaded into the shader.
 *
 * @param [length] Specifies an array of string lengths.
 */
static inline void glShaderSource(GLuint shader, GLsizei count,
                                  const GLchar **string, const GLint *length)
{
  glad_glShaderSource(shader, count, string, length);
}
/**
 * glShaderStorageBlockBinding — change an active shader storage block binding
 *
 * @param [program] The name of the program containing the block whose binding
 * to change.
 *
 * @param [storageBlockIndex] The index storage block within the program.
 *
 * @param [storageBlockBinding] The index storage block binding to associate
 * with the specified storage block.
 */
static inline void glShaderStorageBlockBinding(GLuint program,
                                               GLuint storageBlockIndex,
                                               GLuint storageBlockBinding)
{
  glad_glShaderStorageBlockBinding(program, storageBlockIndex,
                                   storageBlockBinding);
}
/**
 * glStencilFunc — set front and back function and reference value for stencil
 * testing
 *
 * @param [func] Specifies the test function. Eight symbolic constants are
 * valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL,
 * GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
 *
 * @param [ref] Specifies the reference value for the stencil test. ref is
 * clamped to the range [0, 2^n - 1], where n is the number of bitplanes in
 * the stencil buffer. The initial value is 0.
 *
 * @param [mask] Specifies a mask that is ANDed with both the reference value
 * and the stored stencil value when the test is done. The initial value is
 * all 1's.
 */
static inline void glStencilFunc(GLenum func, GLint ref, GLuint mask)
{
  glad_glStencilFunc(func, ref, mask);
}
/**
 * glStencilFuncSeparate — set front and/or back function and reference value
 * for stencil testing
 *
 * @param [face] Specifies whether front and/or back stencil state is updated.
 * Three symbolic constants are valid: GL_FRONT, GL_BACK, and
 * GL_FRONT_AND_BACK.
 *
 * @param [func] Specifies the test function. Eight symbolic constants are
 * valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL,
 * GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
 *
 * @param [ref] Specifies the reference value for the stencil test. ref is
 * clamped to the range [0, 2^n - 1], where n is the number of bitplanes in
 * the stencil buffer. The initial value is 0.
 *
 * @param [mask] Specifies a mask that is ANDed with both the reference value
 * and the stored stencil value when the test is done. The initial value is
 * all 1's.
 */
static inline void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref,
                                         GLuint mask)
{
  glad_glStencilFuncSeparate(face, func, ref, mask);
}
/**
 * glStencilMask — control the front and back writing of individual bits in
 * the stencil planes
 *
 * @param [mask] Specifies a bit mask to enable and disable writing of
 * individual bits in the stencil planes. Initially, the mask is all 1's.
 */
static inline void glStencilMask(GLuint mask) { glad_glStencilMask(mask); }
/**
 * glStencilMaskSeparate — control the front and/or back writing of individual
 * bits in the stencil planes
 *
 * @param [face] Specifies whether the front and/or back stencil writemask is
 * updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and
 * GL_FRONT_AND_BACK.
 *
 * @param [mask] Specifies a bit mask to enable and disable writing of
 * individual bits in the stencil planes. Initially, the mask is all 1's.
 */
static inline void glStencilMaskSeparate(GLenum face, GLuint mask)
{
  glad_glStencilMaskSeparate(face, mask);
}
/**
 * glStencilOp — set front and back stencil test actions
 *
 * @param [sfail] Specifies the action to take when the stencil test fails.
 * Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE,
 * GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial
 * value is GL_KEEP.
 *
 * @param [dpfail] Specifies the stencil action when the stencil test passes,
 * but the depth test fails. dpfail accepts the same symbolic constants as
 * sfail. The initial value is GL_KEEP.
 *
 * @param [dppass] Specifies the stencil action when both the stencil test and
 * the depth test pass, or when the stencil test passes and either there is no
 * depth buffer or depth testing is not enabled. dppass accepts the same
 * symbolic constants as sfail. The initial value is GL_KEEP.
 */
static inline void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)
{
  glad_glStencilOp(sfail, dpfail, dppass);
}
/**
 * glStencilOpSeparate — set front and/or back stencil test actions
 *
 * @param [face] Specifies whether front and/or back stencil state is updated.
 * Three symbolic constants are valid: GL_FRONT, GL_BACK, and
 * GL_FRONT_AND_BACK.
 *
 * @param [sfail] Specifies the action to take when the stencil test fails.
 * Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE,
 * GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial
 * value is GL_KEEP.
 *
 * @param [dpfail] Specifies the stencil action when the stencil test passes,
 * but the depth test fails. dpfail accepts the same symbolic constants as
 * sfail. The initial value is GL_KEEP.
 *
 * @param [dppass] Specifies the stencil action when both the stencil test and
 * the depth test pass, or when the stencil test passes and either there is no
 * depth buffer or depth testing is not enabled. dppass accepts the same
 * symbolic constants as sfail. The initial value is GL_KEEP.
 */
static inline void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail,
                                       GLenum dppass)
{
  glad_glStencilOpSeparate(face, sfail, dpfail, dppass);
}
/**
 * glTexBuffer, glTextureBuffer — attach a buffer object's data store to a
 * buffer texture object
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexBuffer. Must be GL_TEXTURE_BUFFER.
 *
 * @param [texture] Specifies the texture object name for glTextureBuffer.
 *
 * @param [internalFormat] Specifies the internal format of the data in the
 * store belonging to buffer.
 *
 * @param [buffer] Specifies the name of the buffer object whose storage to
 * attach to the active buffer texture.
 */
static inline void glTexBuffer(GLenum target, GLenum internalFormat,
                               GLuint buffer)
{
  glad_glTexBuffer(target, internalFormat, buffer);
}
/**
 * glTexBuffer, glTextureBuffer — attach a buffer object's data store to a
 * buffer texture object
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexBuffer. Must be GL_TEXTURE_BUFFER.
 *
 * @param [texture] Specifies the texture object name for glTextureBuffer.
 *
 * @param [internalFormat] Specifies the internal format of the data in the
 * store belonging to buffer.
 *
 * @param [buffer] Specifies the name of the buffer object whose storage to
 * attach to the active buffer texture.
 */
static inline void glTextureBuffer(GLuint texture, GLenum internalformat,
                                   GLuint buffer)
{
  glad_glTextureBuffer(texture, internalformat, buffer);
}
/**
 * glTexBufferRange, glTextureBufferRange — attach a range of a buffer
 * object's data store to a buffer texture object
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glTexBufferRange. Must be GL_TEXTURE_BUFFER.
 *
 * @param [texture] Specifies the texture object name for
 * glTextureBufferRange.
 *
 * @param [internalFormat] Specifies the internal format of the data in the
 * store belonging to buffer.
 *
 * @param [buffer] Specifies the name of the buffer object whose storage to
 * attach to the active buffer texture.
 *
 * @param [offset] Specifies the offset of the start of the range of the
 * buffer's data store to attach.
 *
 * @param [size] Specifies the size of the range of the buffer's data store to
 * attach.
 */
static inline void glTexBufferRange(GLenum target, GLenum internalFormat,
                                    GLuint buffer, GLintptr offset,
                                    GLsizeiptr size)
{
  glad_glTexBufferRange(target, internalFormat, buffer, offset, size);
}
/**
 * glTexBufferRange, glTextureBufferRange — attach a range of a buffer
 * object's data store to a buffer texture object
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glTexBufferRange. Must be GL_TEXTURE_BUFFER.
 *
 * @param [texture] Specifies the texture object name for
 * glTextureBufferRange.
 *
 * @param [internalFormat] Specifies the internal format of the data in the
 * store belonging to buffer.
 *
 * @param [buffer] Specifies the name of the buffer object whose storage to
 * attach to the active buffer texture.
 *
 * @param [offset] Specifies the offset of the start of the range of the
 * buffer's data store to attach.
 *
 * @param [size] Specifies the size of the range of the buffer's data store to
 * attach.
 */
static inline void glTextureBufferRange(GLuint texture, GLenum internalformat,
                                        GLuint buffer, GLintptr offset,
                                        GLsizei size)
{
  glad_glTextureBufferRange(texture, internalformat, buffer, offset, size);
}
/**
 * glTexImage1D — specify a one-dimensional texture image
 *
 * @param [target] Specifies the target texture. Must be GL_TEXTURE_1D or
 * GL_PROXY_TEXTURE_1D.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [internalFormat] Specifies the number of color components in the
 * texture. Must be one of base internal formats given in Table 1, one of the
 * sized internal formats given in Table 2, or one of the compressed internal
 * formats given in Table 3, below.
 *
 * @param [width] Specifies the width of the texture image. All
 * implementations support texture images that are at least 1024 texels wide.
 * The height of the 1D texture image is 1.
 *
 * @param [border] This value must be 0.
 *
 * @param [format] Specifies the format of the pixel data. The following
 * symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA,
 * GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER,
 * GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT,
 * GL_DEPTH_STENCIL.
 *
 * @param [type] Specifies the data type of the pixel data. The following
 * symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT,
 * GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
 * GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
 * GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,
 * GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
 * GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
 * GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and
 * GL_UNSIGNED_INT_2_10_10_10_REV.
 *
 * @param [data] Specifies a pointer to the image data in memory.
 */
static inline void glTexImage1D(GLenum target, GLint level,
                                GLint internalFormat, GLsizei width,
                                GLint border, GLenum format, GLenum type,
                                const GLvoid *data)
{
  glad_glTexImage1D(target, level, internalFormat, width, border, format, type,
                    data);
}
/**
 * glTexImage2D — specify a two-dimensional texture image
 *
 * @param [target] Specifies the target texture. Must be GL_TEXTURE_2D,
 * GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE,
 * GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
 * GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
 * GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or
 * GL_PROXY_TEXTURE_CUBE_MAP.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image. If target is
 * GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
 *
 * @param [internalFormat] Specifies the number of color components in the
 * texture. Must be one of base internal formats given in Table 1, one of the
 * sized internal formats given in Table 2, or one of the compressed internal
 * formats given in Table 3, below.
 *
 * @param [width] Specifies the width of the texture image. All
 * implementations support texture images that are at least 1024 texels wide.
 *
 * @param [height] Specifies the height of the texture image, or the number of
 * layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and
 * GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture
 * images that are at least 1024 texels high, and texture arrays that are at
 * least 256 layers deep.
 *
 * @param [border] This value must be 0.
 *
 * @param [format] Specifies the format of the pixel data. The following
 * symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA,
 * GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER,
 * GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT,
 * GL_DEPTH_STENCIL.
 *
 * @param [type] Specifies the data type of the pixel data. The following
 * symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT,
 * GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
 * GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
 * GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,
 * GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
 * GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
 * GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and
 * GL_UNSIGNED_INT_2_10_10_10_REV.
 *
 * @param [data] Specifies a pointer to the image data in memory.
 */
static inline void glTexImage2D(GLenum target, GLint level,
                                GLint internalFormat, GLsizei width,
                                GLsizei height, GLint border, GLenum format,
                                GLenum type, const GLvoid *data)
{
  glad_glTexImage2D(target, level, internalFormat, width, height, border,
                    format, type, data);
}
/**
 * glTexImage2DMultisample — establish the data storage, format, dimensions,
 * and number of samples of a multisample texture's image
 *
 * @param [target] Specifies the target of the operation. target must be
 * GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE.
 *
 * @param [samples] The number of samples in the multisample texture's image.
 *
 * @param [internalformat] The internal format to be used to store the
 * multisample texture's image. internalformat must specify a
 * color-renderable, depth-renderable, or stencil-renderable format.
 *
 * @param [width] The width of the multisample texture's image, in texels.
 *
 * @param [height] The height of the multisample texture's image, in texels.
 *
 * @param [fixedsamplelocations] Specifies whether the image will use
 * identical sample locations and the same number of samples for all texels in
 * the image, and the sample locations will not depend on the internal format
 * or size of the image.
 */
static inline void glTexImage2DMultisample(GLenum target, GLsizei samples,
                                           GLenum internalformat, GLsizei width,
                                           GLsizei height,
                                           GLboolean fixedsamplelocations)
{
  glad_glTexImage2DMultisample(target, samples, internalformat, width, height,
                               fixedsamplelocations);
}
/**
 * glTexImage3D — specify a three-dimensional texture image
 *
 * @param [target] Specifies the target texture. Must be one of GL_TEXTURE_3D,
 * GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the n th mipmap reduction image.
 *
 * @param [internalFormat] Specifies the number of color components in the
 * texture. Must be one of base internal formats given in Table 1, one of the
 * sized internal formats given in Table 2, or one of the compressed internal
 * formats given in Table 3, below.
 *
 * @param [width] Specifies the width of the texture image. All
 * implementations support 3D texture images that are at least 16 texels wide.
 *
 * @param [height] Specifies the height of the texture image. All
 * implementations support 3D texture images that are at least 256 texels
 * high.
 *
 * @param [depth] Specifies the depth of the texture image, or the number of
 * layers in a texture array. All implementations support 3D texture images
 * that are at least 256 texels deep, and texture arrays that are at least 256
 * layers deep.
 *
 * @param [border] This value must be 0.
 *
 * @param [format] Specifies the format of the pixel data. The following
 * symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA,
 * GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER,
 * GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT,
 * GL_DEPTH_STENCIL.
 *
 * @param [type] Specifies the data type of the pixel data. The following
 * symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT,
 * GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
 * GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
 * GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,
 * GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
 * GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
 * GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and
 * GL_UNSIGNED_INT_2_10_10_10_REV.
 *
 * @param [data] Specifies a pointer to the image data in memory.
 */
static inline void glTexImage3D(GLenum target, GLint level,
                                GLint internalFormat, GLsizei width,
                                GLsizei height, GLsizei depth, GLint border,
                                GLenum format, GLenum type, const GLvoid *data)
{
  glad_glTexImage3D(target, level, internalFormat, width, height, depth, border,
                    format, type, data);
}
/**
 * glTexImage3DMultisample — establish the data storage, format, dimensions,
 * and number of samples of a multisample texture's image
 *
 * @param [target] Specifies the target of the operation. target must be
 * GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.
 *
 * @param [samples] The number of samples in the multisample texture's image.
 *
 * @param [internalformat] The internal format to be used to store the
 * multisample texture's image. internalformat must specify a
 * color-renderable, depth-renderable, or stencil-renderable format.
 *
 * @param [width] The width of the multisample texture's image, in texels.
 *
 * @param [height] The height of the multisample texture's image, in texels.
 *
 * @param [fixedsamplelocations] Specifies whether the image will use
 * identical sample locations and the same number of samples for all texels in
 * the image, and the sample locations will not depend on the internal format
 * or size of the image.
 */
static inline void glTexImage3DMultisample(GLenum target, GLsizei samples,
                                           GLenum internalformat, GLsizei width,
                                           GLsizei height, GLsizei depth,
                                           GLboolean fixedsamplelocations)
{
  glad_glTexImage3DMultisample(target, samples, internalformat, width, height,
                               depth, fixedsamplelocations);
}
/**
 * glTexParameter, glTextureParameter — set texture parameters
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexParameter functions. Must be one of GL_TEXTURE_1D,
 * GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D,
 * GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.
 *
 * @param [texture] Specifies the texture object name for glTextureParameter
 * functions.
 *
 * @param [pname] Specifies the symbolic name of a single-valued texture
 * parameter. pname can be one of the following:
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS,
 * GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
 * GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A,
 * GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands, specifies a pointer to an array
 * where the value or values of pname are stored.
 */
static inline void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
  glad_glTexParameterf(target, pname, param);
}
/**
 * glTexParameter, glTextureParameter — set texture parameters
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexParameter functions. Must be one of GL_TEXTURE_1D,
 * GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D,
 * GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.
 *
 * @param [texture] Specifies the texture object name for glTextureParameter
 * functions.
 *
 * @param [pname] Specifies the symbolic name of a single-valued texture
 * parameter. pname can be one of the following:
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS,
 * GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
 * GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A,
 * GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands, specifies a pointer to an array
 * where the value or values of pname are stored.
 */
static inline void glTexParameteri(GLenum target, GLenum pname, GLint param)
{
  glad_glTexParameteri(target, pname, param);
}
/**
 * glTexParameter, glTextureParameter — set texture parameters
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexParameter functions. Must be one of GL_TEXTURE_1D,
 * GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D,
 * GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.
 *
 * @param [texture] Specifies the texture object name for glTextureParameter
 * functions.
 *
 * @param [pname] Specifies the symbolic name of a single-valued texture
 * parameter. pname can be one of the following:
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS,
 * GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
 * GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A,
 * GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands, specifies a pointer to an array
 * where the value or values of pname are stored.
 */
static inline void glTextureParameterf(GLuint texture, GLenum pname,
                                       GLfloat param)
{
  glad_glTextureParameterf(texture, pname, param);
}
/**
 * glTexParameter, glTextureParameter — set texture parameters
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexParameter functions. Must be one of GL_TEXTURE_1D,
 * GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D,
 * GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.
 *
 * @param [texture] Specifies the texture object name for glTextureParameter
 * functions.
 *
 * @param [pname] Specifies the symbolic name of a single-valued texture
 * parameter. pname can be one of the following:
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS,
 * GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
 * GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A,
 * GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands, specifies a pointer to an array
 * where the value or values of pname are stored.
 */
static inline void glTextureParameteri(GLuint texture, GLenum pname,
                                       GLint param)
{
  glad_glTextureParameteri(texture, pname, param);
}
/**
 * glTexParameter, glTextureParameter — set texture parameters
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexParameter functions. Must be one of GL_TEXTURE_1D,
 * GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D,
 * GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.
 *
 * @param [texture] Specifies the texture object name for glTextureParameter
 * functions.
 *
 * @param [pname] Specifies the symbolic name of a single-valued texture
 * parameter. pname can be one of the following:
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS,
 * GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
 * GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A,
 * GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands, specifies a pointer to an array
 * where the value or values of pname are stored.
 */
static inline void glTexParameterfv(GLenum target, GLenum pname,
                                    const GLfloat *params)
{
  glad_glTexParameterfv(target, pname, params);
}
/**
 * glTexParameter, glTextureParameter — set texture parameters
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexParameter functions. Must be one of GL_TEXTURE_1D,
 * GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D,
 * GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.
 *
 * @param [texture] Specifies the texture object name for glTextureParameter
 * functions.
 *
 * @param [pname] Specifies the symbolic name of a single-valued texture
 * parameter. pname can be one of the following:
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS,
 * GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
 * GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A,
 * GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands, specifies a pointer to an array
 * where the value or values of pname are stored.
 */
static inline void glTexParameteriv(GLenum target, GLenum pname,
                                    const GLint *params)
{
  glad_glTexParameteriv(target, pname, params);
}
/**
 * glTexParameter, glTextureParameter — set texture parameters
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexParameter functions. Must be one of GL_TEXTURE_1D,
 * GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D,
 * GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.
 *
 * @param [texture] Specifies the texture object name for glTextureParameter
 * functions.
 *
 * @param [pname] Specifies the symbolic name of a single-valued texture
 * parameter. pname can be one of the following:
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS,
 * GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
 * GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A,
 * GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands, specifies a pointer to an array
 * where the value or values of pname are stored.
 */
static inline void glTexParameterIiv(GLenum target, GLenum pname,
                                     const GLint *params)
{
  glad_glTexParameterIiv(target, pname, params);
}
/**
 * glTexParameter, glTextureParameter — set texture parameters
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexParameter functions. Must be one of GL_TEXTURE_1D,
 * GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D,
 * GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.
 *
 * @param [texture] Specifies the texture object name for glTextureParameter
 * functions.
 *
 * @param [pname] Specifies the symbolic name of a single-valued texture
 * parameter. pname can be one of the following:
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS,
 * GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
 * GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A,
 * GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands, specifies a pointer to an array
 * where the value or values of pname are stored.
 */
static inline void glTexParameterIuiv(GLenum target, GLenum pname,
                                      const GLuint *params)
{
  glad_glTexParameterIuiv(target, pname, params);
}
/**
 * glTexParameter, glTextureParameter — set texture parameters
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexParameter functions. Must be one of GL_TEXTURE_1D,
 * GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D,
 * GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.
 *
 * @param [texture] Specifies the texture object name for glTextureParameter
 * functions.
 *
 * @param [pname] Specifies the symbolic name of a single-valued texture
 * parameter. pname can be one of the following:
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS,
 * GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
 * GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A,
 * GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands, specifies a pointer to an array
 * where the value or values of pname are stored.
 */
static inline void glTextureParameterfv(GLuint texture, GLenum pname,
                                        const GLfloat *paramtexture)
{
  glad_glTextureParameterfv(texture, pname, paramtexture);
}
/**
 * glTexParameter, glTextureParameter — set texture parameters
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexParameter functions. Must be one of GL_TEXTURE_1D,
 * GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D,
 * GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.
 *
 * @param [texture] Specifies the texture object name for glTextureParameter
 * functions.
 *
 * @param [pname] Specifies the symbolic name of a single-valued texture
 * parameter. pname can be one of the following:
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS,
 * GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
 * GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A,
 * GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands, specifies a pointer to an array
 * where the value or values of pname are stored.
 */
static inline void glTextureParameteriv(GLuint texture, GLenum pname,
                                        const GLint *param)
{
  glad_glTextureParameteriv(texture, pname, param);
}
/**
 * glTexParameter, glTextureParameter — set texture parameters
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexParameter functions. Must be one of GL_TEXTURE_1D,
 * GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D,
 * GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.
 *
 * @param [texture] Specifies the texture object name for glTextureParameter
 * functions.
 *
 * @param [pname] Specifies the symbolic name of a single-valued texture
 * parameter. pname can be one of the following:
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS,
 * GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
 * GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A,
 * GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands, specifies a pointer to an array
 * where the value or values of pname are stored.
 */
static inline void glTextureParameterIiv(GLuint texture, GLenum pname,
                                         const GLint *params)
{
  glad_glTextureParameterIiv(texture, pname, params);
}
/**
 * glTexParameter, glTextureParameter — set texture parameters
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexParameter functions. Must be one of GL_TEXTURE_1D,
 * GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D,
 * GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.
 *
 * @param [texture] Specifies the texture object name for glTextureParameter
 * functions.
 *
 * @param [pname] Specifies the symbolic name of a single-valued texture
 * parameter. pname can be one of the following:
 * GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL,
 * GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS,
 * GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
 * GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A,
 * GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
 *
 * @param [param] For the scalar commands, specifies the value of pname.
 *
 * @param [params] For the vector commands, specifies a pointer to an array
 * where the value or values of pname are stored.
 */
static inline void glTextureParameterIuiv(GLuint texture, GLenum pname,
                                          const GLuint *params)
{
  glad_glTextureParameterIuiv(texture, pname, params);
}
/**
 * glTexStorage1D, glTextureStorage1D — simultaneously specify storage for all
 * levels of a one-dimensional texture
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glTexStorage1D. Must be one of GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
 *
 * @param [texture] Specifies the texture object name for glTextureStorage1D.
 * The effective target of texture must be one of the valid non-proxy target
 * values above.
 *
 * @param [levels] Specify the number of texture levels.
 *
 * @param [internalformat] Specifies the sized internal format to be used to
 * store texture image data.
 *
 * @param [width] Specifies the width of the texture, in texels.
 */
static inline void glTexStorage1D(GLenum target, GLsizei levels,
                                  GLenum internalformat, GLsizei width)
{
  glad_glTexStorage1D(target, levels, internalformat, width);
}
/**
 * glTexStorage1D, glTextureStorage1D — simultaneously specify storage for all
 * levels of a one-dimensional texture
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glTexStorage1D. Must be one of GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
 *
 * @param [texture] Specifies the texture object name for glTextureStorage1D.
 * The effective target of texture must be one of the valid non-proxy target
 * values above.
 *
 * @param [levels] Specify the number of texture levels.
 *
 * @param [internalformat] Specifies the sized internal format to be used to
 * store texture image data.
 *
 * @param [width] Specifies the width of the texture, in texels.
 */
static inline void glTextureStorage1D(GLuint texture, GLsizei levels,
                                      GLenum internalformat, GLsizei width)
{
  glad_glTextureStorage1D(texture, levels, internalformat, width);
}
/**
 * glTexStorage2D, glTextureStorage2D — simultaneously specify storage for all
 * levels of a two-dimensional or one-dimensional array texture
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glTexStorage2D. Must be one of GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY,
 * GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP.
 *
 * @param [texture] Specifies the texture object name for glTextureStorage2D.
 * The effective target of texture must be one of the valid non-proxy target
 * values above.
 *
 * @param [levels] Specify the number of texture levels.
 *
 * @param [internalformat] Specifies the sized internal format to be used to
 * store texture image data.
 *
 * @param [width] Specifies the width of the texture, in texels.
 *
 * @param [height] Specifies the height of the texture, in texels.
 */
static inline void glTexStorage2D(GLenum target, GLsizei levels,
                                  GLenum internalformat, GLsizei width,
                                  GLsizei height)
{
  glad_glTexStorage2D(target, levels, internalformat, width, height);
}
/**
 * glTexStorage2D, glTextureStorage2D — simultaneously specify storage for all
 * levels of a two-dimensional or one-dimensional array texture
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glTexStorage2D. Must be one of GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY,
 * GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY,
 * GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP.
 *
 * @param [texture] Specifies the texture object name for glTextureStorage2D.
 * The effective target of texture must be one of the valid non-proxy target
 * values above.
 *
 * @param [levels] Specify the number of texture levels.
 *
 * @param [internalformat] Specifies the sized internal format to be used to
 * store texture image data.
 *
 * @param [width] Specifies the width of the texture, in texels.
 *
 * @param [height] Specifies the height of the texture, in texels.
 */
static inline void glTextureStorage2D(GLuint texture, GLsizei levels,
                                      GLenum internalformat, GLsizei width,
                                      GLsizei height)
{
  glad_glTextureStorage2D(texture, levels, internalformat, width, height);
}
/**
 * glTexStorage2DMultisample, glTextureStorage2DMultisample — specify storage
 * for a two-dimensional multisample texture
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glTexStorage2DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE or
 * GL_PROXY_TEXTURE_2D_MULTISAMPLE.
 *
 * @param [texture] Specifies the texture object name for
 * glTextureStorage2DMultisample. The effective target of texture must be one
 * of the valid non-proxy target values above.
 *
 * @param [samples] Specify the number of samples in the texture.
 *
 * @param [internalformat] Specifies the sized internal format to be used to
 * store texture image data.
 *
 * @param [width] Specifies the width of the texture, in texels.
 *
 * @param [height] Specifies the height of the texture, in texels.
 *
 * @param [fixedsamplelocations] Specifies whether the image will use
 * identical sample locations and the same number of samples for all texels in
 * the image, and the sample locations will not depend on the internal format
 * or size of the image.
 */
static inline void glTexStorage2DMultisample(GLenum target, GLsizei samples,
                                             GLenum internalformat,
                                             GLsizei width, GLsizei height,
                                             GLboolean fixedsamplelocations)
{
  glad_glTexStorage2DMultisample(target, samples, internalformat, width, height,
                                 fixedsamplelocations);
}
/**
 * glTexStorage2DMultisample, glTextureStorage2DMultisample — specify storage
 * for a two-dimensional multisample texture
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glTexStorage2DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE or
 * GL_PROXY_TEXTURE_2D_MULTISAMPLE.
 *
 * @param [texture] Specifies the texture object name for
 * glTextureStorage2DMultisample. The effective target of texture must be one
 * of the valid non-proxy target values above.
 *
 * @param [samples] Specify the number of samples in the texture.
 *
 * @param [internalformat] Specifies the sized internal format to be used to
 * store texture image data.
 *
 * @param [width] Specifies the width of the texture, in texels.
 *
 * @param [height] Specifies the height of the texture, in texels.
 *
 * @param [fixedsamplelocations] Specifies whether the image will use
 * identical sample locations and the same number of samples for all texels in
 * the image, and the sample locations will not depend on the internal format
 * or size of the image.
 */
static inline void glTextureStorage2DMultisample(GLuint texture,
                                                 GLsizei samples,
                                                 GLenum internalformat,
                                                 GLsizei width, GLsizei height,
                                                 GLboolean fixedsamplelocations)
{
  glad_glTextureStorage2DMultisample(texture, samples, internalformat, width,
                                     height, fixedsamplelocations);
}
/**
 * glTexStorage3D, glTextureStorage3D — simultaneously specify storage for all
 * levels of a three-dimensional, two-dimensional array or cube-map array
 * texture
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glTexStorage3D. Must be one of GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_CUBE_ARRAY, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_2D_ARRAY or
 * GL_PROXY_TEXTURE_CUBE_ARRAY.
 *
 * @param [texture] Specifies the texture object name for glTextureStorage3D.
 * The effective target of texture must be one of the valid non-proxy target
 * values above.
 *
 * @param [levels] Specify the number of texture levels.
 *
 * @param [internalformat] Specifies the sized internal format to be used to
 * store texture image data.
 *
 * @param [width] Specifies the width of the texture, in texels.
 *
 * @param [height] Specifies the height of the texture, in texels.
 *
 * @param [depth] Specifies the depth of the texture, in texels.
 */
static inline void glTexStorage3D(GLenum target, GLsizei levels,
                                  GLenum internalformat, GLsizei width,
                                  GLsizei height, GLsizei depth)
{
  glad_glTexStorage3D(target, levels, internalformat, width, height, depth);
}
/**
 * glTexStorage3D, glTextureStorage3D — simultaneously specify storage for all
 * levels of a three-dimensional, two-dimensional array or cube-map array
 * texture
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glTexStorage3D. Must be one of GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY,
 * GL_TEXTURE_CUBE_ARRAY, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_2D_ARRAY or
 * GL_PROXY_TEXTURE_CUBE_ARRAY.
 *
 * @param [texture] Specifies the texture object name for glTextureStorage3D.
 * The effective target of texture must be one of the valid non-proxy target
 * values above.
 *
 * @param [levels] Specify the number of texture levels.
 *
 * @param [internalformat] Specifies the sized internal format to be used to
 * store texture image data.
 *
 * @param [width] Specifies the width of the texture, in texels.
 *
 * @param [height] Specifies the height of the texture, in texels.
 *
 * @param [depth] Specifies the depth of the texture, in texels.
 */
static inline void glTextureStorage3D(GLuint texture, GLsizei levels,
                                      GLenum internalformat, GLsizei width,
                                      GLsizei height, GLsizei depth)
{
  glad_glTextureStorage3D(texture, levels, internalformat, width, height,
                          depth);
}
/**
 * glTexStorage3DMultisample, glTextureStorage3DMultisample — specify storage
 * for a two-dimensional multisample array texture
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glTexStorage3DMultisample. Must be one of
 * GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.
 *
 * @param [texture] Specifies the texture object name for
 * glTextureStorage3DMultisample. The effective target of texture must be one
 * of the valid non-proxy target values above.
 *
 * @param [samples] Specify the number of samples in the texture.
 *
 * @param [internalformat] Specifies the sized internal format to be used to
 * store texture image data.
 *
 * @param [width] Specifies the width of the texture, in texels.
 *
 * @param [height] Specifies the height of the texture, in texels.
 *
 * @param [depth] Specifies the depth of the texture, in layers.
 *
 * @param [fixedsamplelocations] Specifies whether the image will use
 * identical sample locations and the same number of samples for all texels in
 * the image, and the sample locations will not depend on the internal format
 * or size of the image.
 */
static inline void glTexStorage3DMultisample(GLenum target, GLsizei samples,
                                             GLenum internalformat,
                                             GLsizei width, GLsizei height,
                                             GLsizei depth,
                                             GLboolean fixedsamplelocations)
{
  glad_glTexStorage3DMultisample(target, samples, internalformat, width, height,
                                 depth, fixedsamplelocations);
}
/**
 * glTexStorage3DMultisample, glTextureStorage3DMultisample — specify storage
 * for a two-dimensional multisample array texture
 *
 * @param [target] Specifies the target to which the texture object is bound
 * for glTexStorage3DMultisample. Must be one of
 * GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.
 *
 * @param [texture] Specifies the texture object name for
 * glTextureStorage3DMultisample. The effective target of texture must be one
 * of the valid non-proxy target values above.
 *
 * @param [samples] Specify the number of samples in the texture.
 *
 * @param [internalformat] Specifies the sized internal format to be used to
 * store texture image data.
 *
 * @param [width] Specifies the width of the texture, in texels.
 *
 * @param [height] Specifies the height of the texture, in texels.
 *
 * @param [depth] Specifies the depth of the texture, in layers.
 *
 * @param [fixedsamplelocations] Specifies whether the image will use
 * identical sample locations and the same number of samples for all texels in
 * the image, and the sample locations will not depend on the internal format
 * or size of the image.
 */
static inline void glTextureStorage3DMultisample(
    GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width,
    GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
  glad_glTextureStorage3DMultisample(texture, samples, internalformat, width,
                                     height, depth, fixedsamplelocations);
}
/**
 * glTexSubImage1D, glTextureSubImage1D — specify a one-dimensional texture
 * subimage
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexSubImage1D. Must be GL_TEXTURE_1D.
 *
 * @param [texture] Specifies the texture object name for glTextureSubImage1D.
 * The effective target of texture must be one of the valid target values
 * above.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 * texture array.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [format] Specifies the format of the pixel data. The following
 * symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA,
 * GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
 *
 * @param [type] Specifies the data type of the pixel data. The following
 * symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT,
 * GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
 * GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
 * GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,
 * GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
 * GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
 * GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and
 * GL_UNSIGNED_INT_2_10_10_10_REV.
 *
 * @param [pixels] Specifies a pointer to the image data in memory.
 */
static inline void glTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                   GLsizei width, GLenum format, GLenum type,
                                   const GLvoid *pixels)
{
  glad_glTexSubImage1D(target, level, xoffset, width, format, type, pixels);
}
/**
 * glTexSubImage1D, glTextureSubImage1D — specify a one-dimensional texture
 * subimage
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexSubImage1D. Must be GL_TEXTURE_1D.
 *
 * @param [texture] Specifies the texture object name for glTextureSubImage1D.
 * The effective target of texture must be one of the valid target values
 * above.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 * texture array.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [format] Specifies the format of the pixel data. The following
 * symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA,
 * GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
 *
 * @param [type] Specifies the data type of the pixel data. The following
 * symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT,
 * GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
 * GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
 * GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,
 * GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
 * GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
 * GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and
 * GL_UNSIGNED_INT_2_10_10_10_REV.
 *
 * @param [pixels] Specifies a pointer to the image data in memory.
 */
static inline void glTextureSubImage1D(GLuint texture, GLint level,
                                       GLint xoffset, GLsizei width,
                                       GLenum format, GLenum type,
                                       const void *pixels)
{
  glad_glTextureSubImage1D(texture, level, xoffset, width, format, type,
                           pixels);
}
/**
 * glTexSubImage2D, glTextureSubImage2D — specify a two-dimensional texture
 * subimage
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexSubImage2D. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
 *
 * @param [texture] Specifies the texture object name for glTextureSubImage2D.
 * The effective target of texture must be one of the valid target values
 * above.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 * texture array.
 *
 * @param [yoffset] Specifies a texel offset in the y direction within the
 * texture array.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [height] Specifies the height of the texture subimage.
 *
 * @param [format] Specifies the format of the pixel data. The following
 * symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA,
 * GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
 *
 * @param [type] Specifies the data type of the pixel data. The following
 * symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT,
 * GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
 * GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
 * GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,
 * GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
 * GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
 * GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and
 * GL_UNSIGNED_INT_2_10_10_10_REV.
 *
 * @param [pixels] Specifies a pointer to the image data in memory.
 */
static inline void glTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                   GLint yoffset, GLsizei width, GLsizei height,
                                   GLenum format, GLenum type,
                                   const GLvoid *pixels)
{
  glad_glTexSubImage2D(target, level, xoffset, yoffset, width, height, format,
                       type, pixels);
}
/**
 * glTexSubImage2D, glTextureSubImage2D — specify a two-dimensional texture
 * subimage
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexSubImage2D. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
 * GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
 *
 * @param [texture] Specifies the texture object name for glTextureSubImage2D.
 * The effective target of texture must be one of the valid target values
 * above.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 * texture array.
 *
 * @param [yoffset] Specifies a texel offset in the y direction within the
 * texture array.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [height] Specifies the height of the texture subimage.
 *
 * @param [format] Specifies the format of the pixel data. The following
 * symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA,
 * GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
 *
 * @param [type] Specifies the data type of the pixel data. The following
 * symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT,
 * GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
 * GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
 * GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,
 * GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
 * GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
 * GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and
 * GL_UNSIGNED_INT_2_10_10_10_REV.
 *
 * @param [pixels] Specifies a pointer to the image data in memory.
 */
static inline void glTextureSubImage2D(GLuint texture, GLint level,
                                       GLint xoffset, GLint yoffset,
                                       GLsizei width, GLsizei height,
                                       GLenum format, GLenum type,
                                       const void *pixels)
{
  glad_glTextureSubImage2D(texture, level, xoffset, yoffset, width, height,
                           format, type, pixels);
}
/**
 * glTexSubImage3D, glTextureSubImage3D — specify a three-dimensional texture
 * subimage
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexSubImage3D. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
 *
 * @param [texture] Specifies the texture object name for glTextureSubImage3D.
 * The effective target of texture must be one of the valid target values
 * above.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 * texture array.
 *
 * @param [yoffset] Specifies a texel offset in the y direction within the
 * texture array.
 *
 * @param [zoffset] Specifies a texel offset in the z direction within the
 * texture array.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [height] Specifies the height of the texture subimage.
 *
 * @param [depth] Specifies the depth of the texture subimage.
 *
 * @param [format] Specifies the format of the pixel data. The following
 * symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA,
 * GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
 *
 * @param [type] Specifies the data type of the pixel data. The following
 * symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT,
 * GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
 * GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
 * GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,
 * GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
 * GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
 * GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and
 * GL_UNSIGNED_INT_2_10_10_10_REV.
 *
 * @param [pixels] Specifies a pointer to the image data in memory.
 */
static inline void glTexSubImage3D(GLenum target, GLint level, GLint xoffset,
                                   GLint yoffset, GLint zoffset, GLsizei width,
                                   GLsizei height, GLsizei depth, GLenum format,
                                   GLenum type, const GLvoid *pixels)
{
  glad_glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height,
                       depth, format, type, pixels);
}
/**
 * glTexSubImage3D, glTextureSubImage3D — specify a three-dimensional texture
 * subimage
 *
 * @param [target] Specifies the target to which the texture is bound for
 * glTexSubImage3D. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
 *
 * @param [texture] Specifies the texture object name for glTextureSubImage3D.
 * The effective target of texture must be one of the valid target values
 * above.
 *
 * @param [level] Specifies the level-of-detail number. Level 0 is the base
 * image level. Level n is the nth mipmap reduction image.
 *
 * @param [xoffset] Specifies a texel offset in the x direction within the
 * texture array.
 *
 * @param [yoffset] Specifies a texel offset in the y direction within the
 * texture array.
 *
 * @param [zoffset] Specifies a texel offset in the z direction within the
 * texture array.
 *
 * @param [width] Specifies the width of the texture subimage.
 *
 * @param [height] Specifies the height of the texture subimage.
 *
 * @param [depth] Specifies the depth of the texture subimage.
 *
 * @param [format] Specifies the format of the pixel data. The following
 * symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA,
 * GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
 *
 * @param [type] Specifies the data type of the pixel data. The following
 * symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT,
 * GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
 * GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
 * GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4,
 * GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
 * GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
 * GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and
 * GL_UNSIGNED_INT_2_10_10_10_REV.
 *
 * @param [pixels] Specifies a pointer to the image data in memory.
 */
static inline void
glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset,
                    GLint zoffset, GLsizei width, GLsizei height, GLsizei depth,
                    GLenum format, GLenum type, const void *pixels)
{
  glad_glTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width,
                           height, depth, format, type, pixels);
}
/**
 * glTextureBarrier — controls the ordering of reads and writes to rendered
 * fragments across drawing commands
 */
static inline void glTextureBarrier(void) { glad_glTextureBarrier(); }
/**
 * glTextureView — initialize a texture as a data alias of another texture's
 * data store
 *
 * @param [texture] Specifies the texture object to be initialized as a view.
 *
 * @param [target] Specifies the target to be used for the newly initialized
 * texture.
 *
 * @param [origtexture] Specifies the name of a texture object of which to
 * make a view.
 *
 * @param [internalFormat] Specifies the internal format for the newly created
 * view.
 *
 * @param [minlevel] Specifies lowest level of detail of the view.
 *
 * @param [numlevels] Specifies the number of levels of detail to include in
 * the view.
 *
 * @param [minlayer] Specifies the index of the first layer to include in the
 * view.
 *
 * @param [numlayers] Specifies the number of layers to include in the view.
 */
static inline void glTextureView(GLuint texture, GLenum target,
                                 GLuint origtexture, GLenum internalformat,
                                 GLuint minlevel, GLuint numlevels,
                                 GLuint minlayer, GLuint numlayers)
{
  glad_glTextureView(texture, target, origtexture, internalformat, minlevel,
                     numlevels, minlayer, numlayers);
}
/**
 * glTransformFeedbackBufferBase — bind a buffer object to a transform
 * feedback buffer object
 *
 * @param [xfb] Name of the transform feedback buffer object.
 *
 * @param [index] Index of the binding point within xfb.
 *
 * @param [buffer] Name of the buffer object to bind to the specified binding
 * point.
 */
static inline void glTransformFeedbackBufferBase(GLuint xfb, GLuint index,
                                                 GLuint buffer)
{
  glad_glTransformFeedbackBufferBase(xfb, index, buffer);
}
/**
 * glTransformFeedbackBufferRange — bind a range within a buffer object to a
 * transform feedback buffer object
 *
 * @param [xfb] Name of the transform feedback buffer object.
 *
 * @param [index] Index of the binding point within xfb.
 *
 * @param [buffer] Name of the buffer object to bind to the specified binding
 * point.
 *
 * @param [offset] The starting offset in basic machine units into the buffer
 * object.
 *
 * @param [size] The amount of data in basic machine units that can be read
 * from or written to the buffer object while used as an indexed target.
 */
static inline void glTransformFeedbackBufferRange(GLuint xfb, GLuint index,
                                                  GLuint buffer,
                                                  GLintptr offset, GLsizei size)
{
  glad_glTransformFeedbackBufferRange(xfb, index, buffer, offset, size);
}
/**
 * glTransformFeedbackVaryings — specify values to record in transform
 * feedback buffers
 *
 * @param [program] The name of the target program object.
 *
 * @param [count] The number of varying variables used for transform feedback.
 *
 * @param [varyings] An array of count zero-terminated strings specifying the
 * names of the varying variables to use for transform feedback.
 *
 * @param [bufferMode] Identifies the mode used to capture the varying
 * variables when transform feedback is active. bufferMode must be
 * GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS.
 */
static inline void glTransformFeedbackVaryings(GLuint program, GLsizei count,
                                               const char **varyings,
                                               GLenum bufferMode)
{
  glad_glTransformFeedbackVaryings(program, count, varyings, bufferMode);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform1f(GLint location, GLfloat v0)
{
  glad_glUniform1f(location, v0);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform2f(GLint location, GLfloat v0, GLfloat v1)
{
  glad_glUniform2f(location, v0, v1);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform3f(GLint location, GLfloat v0, GLfloat v1,
                               GLfloat v2)
{
  glad_glUniform3f(location, v0, v1, v2);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform4f(GLint location, GLfloat v0, GLfloat v1,
                               GLfloat v2, GLfloat v3)
{
  glad_glUniform4f(location, v0, v1, v2, v3);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform1i(GLint location, GLint v0)
{
  glad_glUniform1i(location, v0);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform2i(GLint location, GLint v0, GLint v1)
{
  glad_glUniform2i(location, v0, v1);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)
{
  glad_glUniform3i(location, v0, v1, v2);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2,
                               GLint v3)
{
  glad_glUniform4i(location, v0, v1, v2, v3);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform1ui(GLint location, GLuint v0)
{
  glad_glUniform1ui(location, v0);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform2ui(GLint location, GLuint v0, GLuint v1)
{
  glad_glUniform2ui(location, v0, v1);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
  glad_glUniform3ui(location, v0, v1, v2);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2,
                                GLuint v3)
{
  glad_glUniform4ui(location, v0, v1, v2, v3);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform1fv(GLint location, GLsizei count,
                                const GLfloat *value)
{
  glad_glUniform1fv(location, count, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform2fv(GLint location, GLsizei count,
                                const GLfloat *value)
{
  glad_glUniform2fv(location, count, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform3fv(GLint location, GLsizei count,
                                const GLfloat *value)
{
  glad_glUniform3fv(location, count, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform4fv(GLint location, GLsizei count,
                                const GLfloat *value)
{
  glad_glUniform4fv(location, count, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform1iv(GLint location, GLsizei count,
                                const GLint *value)
{
  glad_glUniform1iv(location, count, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform2iv(GLint location, GLsizei count,
                                const GLint *value)
{
  glad_glUniform2iv(location, count, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform3iv(GLint location, GLsizei count,
                                const GLint *value)
{
  glad_glUniform3iv(location, count, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform4iv(GLint location, GLsizei count,
                                const GLint *value)
{
  glad_glUniform4iv(location, count, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform1uiv(GLint location, GLsizei count,
                                 const GLuint *value)
{
  glad_glUniform1uiv(location, count, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform2uiv(GLint location, GLsizei count,
                                 const GLuint *value)
{
  glad_glUniform2uiv(location, count, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform3uiv(GLint location, GLsizei count,
                                 const GLuint *value)
{
  glad_glUniform3uiv(location, count, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniform4uiv(GLint location, GLsizei count,
                                 const GLuint *value)
{
  glad_glUniform4uiv(location, count, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniformMatrix2fv(GLint location, GLsizei count,
                                      GLboolean transpose, const GLfloat *value)
{
  glad_glUniformMatrix2fv(location, count, transpose, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniformMatrix3fv(GLint location, GLsizei count,
                                      GLboolean transpose, const GLfloat *value)
{
  glad_glUniformMatrix3fv(location, count, transpose, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniformMatrix4fv(GLint location, GLsizei count,
                                      GLboolean transpose, const GLfloat *value)
{
  glad_glUniformMatrix4fv(location, count, transpose, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniformMatrix2x3fv(GLint location, GLsizei count,
                                        GLboolean transpose,
                                        const GLfloat *value)
{
  glad_glUniformMatrix2x3fv(location, count, transpose, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniformMatrix3x2fv(GLint location, GLsizei count,
                                        GLboolean transpose,
                                        const GLfloat *value)
{
  glad_glUniformMatrix3x2fv(location, count, transpose, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniformMatrix2x4fv(GLint location, GLsizei count,
                                        GLboolean transpose,
                                        const GLfloat *value)
{
  glad_glUniformMatrix2x4fv(location, count, transpose, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniformMatrix4x2fv(GLint location, GLsizei count,
                                        GLboolean transpose,
                                        const GLfloat *value)
{
  glad_glUniformMatrix4x2fv(location, count, transpose, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniformMatrix3x4fv(GLint location, GLsizei count,
                                        GLboolean transpose,
                                        const GLfloat *value)
{
  glad_glUniformMatrix3x4fv(location, count, transpose, value);
}
/**
 * glUniform — Specify the value of a uniform variable for the current program
 * object
 *
 * @param [location] Specifies the location of the uniform variable to be
 * modified.
 *
 * @param [count] For the vector (glUniform*v) commands, specifies the number
 * of elements that are to be modified. This should be 1 if the targeted
 * uniform variable is not an array, and 1 or more if it is an array.
 *
 * @param [transpose] For the matrix commands, specifies whether to transpose
 * the matrix as the values are loaded into the uniform variable.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified uniform variable.
 *
 * @param [value] For the vector and matrix commands, specifies a pointer to
 * an array of count values that will be used to update the specified uniform
 * variable.
 */
static inline void glUniformMatrix4x3fv(GLint location, GLsizei count,
                                        GLboolean transpose,
                                        const GLfloat *value)
{
  glad_glUniformMatrix4x3fv(location, count, transpose, value);
}
/**
 * glUniformBlockBinding — assign a binding point to an active uniform block
 *
 * @param [program] The name of a program object containing the active uniform
 * block whose binding to assign.
 *
 * @param [uniformBlockIndex] The index of the active uniform block within
 * program whose binding to assign.
 *
 * @param [uniformBlockBinding] Specifies the binding point to which to bind
 * the uniform block with index uniformBlockIndex within program.
 */
static inline void glUniformBlockBinding(GLuint program,
                                         GLuint uniformBlockIndex,
                                         GLuint uniformBlockBinding)
{
  glad_glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
}
/**
 * glUniformSubroutines — load active subroutine uniforms
 *
 * @param [shadertype] Specifies the shader stage from which to query for
 * subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER,
 * GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
 * GL_FRAGMENT_SHADER.
 *
 * @param [count] Specifies the number of uniform indices stored in indices.
 *
 * @param [indices] Specifies the address of an array holding the indices to
 * load into the shader subroutine variables.
 */
static inline void glUniformSubroutinesuiv(GLenum shadertype, GLsizei count,
                                           const GLuint *indices)
{
  glad_glUniformSubroutinesuiv(shadertype, count, indices);
}
/**
 * glUnmapBuffer, glUnmapNamedBuffer — release the mapping of a buffer
 * object's data store into the client's address space
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glUnmapBuffer, which must be one of the buffer binding targets in the
 * following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glUnmapNamedBuffer.
 */
static inline GLboolean glUnmapBuffer(GLenum target)
{
  return glad_glUnmapBuffer(target);
}
/**
 * glUnmapBuffer, glUnmapNamedBuffer — release the mapping of a buffer
 * object's data store into the client's address space
 *
 * @param [target] Specifies the target to which the buffer object is bound
 * for glUnmapBuffer, which must be one of the buffer binding targets in the
 * following table:
 *
 * GL_ARRAY_BUFFER - Vertex attributes,
 * GL_ATOMIC_COUNTER_BUFFER - Atomic counter storage,
 * GL_COPY_READ_BUFFER - Buffer copy source,
 * GL_COPY_WRITE_BUFFER - Buffer copy destination,
 * GL_DISPATCH_INDIRECT_BUFFER - Indirect compute dispatch commands,
 * GL_DRAW_INDIRECT_BUFFER - Indirect command arguments,
 * GL_ELEMENT_ARRAY_BUFFER - Vertex array indices,
 * GL_PIXEL_PACK_BUFFER - Pixel read target,
 * GL_PIXEL_UNPACK_BUFFER - Texture data source,
 * GL_QUERY_BUFFER - Query result buffer,
 * GL_SHADER_STORAGE_BUFFER - Read-write storage for shaders,
 * GL_TEXTURE_BUFFER - Texture data buffer,
 * GL_TRANSFORM_FEEDBACK_BUFFER - Transform feedback buffer,
 * GL_UNIFORM_BUFFER - Uniform block storage,
 *
 * @param [buffer] Specifies the name of the buffer object for
 * glUnmapNamedBuffer.
 */
static inline GLboolean glUnmapNamedBuffer(GLuint buffer)
{
  return glad_glUnmapNamedBuffer(buffer);
}
/**
 * glUseProgram — Installs a program object as part of current rendering state
 *
 * @param [program] Specifies the handle of the program object whose
 * executables are to be used as part of current rendering state.
 */
static inline void glUseProgram(GLuint program) { glad_glUseProgram(program); }
/**
 * glUseProgramStages — bind stages of a program object to a program pipeline
 *
 * @param [pipeline] Specifies the program pipeline object to which to bind
 * stages from program.
 *
 * @param [stages] Specifies a set of program stages to bind to the program
 * pipeline object.
 *
 * @param [program] Specifies the program object containing the shader
 * executables to use in pipeline.
 */
static inline void glUseProgramStages(GLuint pipeline, GLbitfield stages,
                                      GLuint program)
{
  glad_glUseProgramStages(pipeline, stages, program);
}
/**
 * glValidateProgram — Validates a program object
 *
 * @param [program] Specifies the handle of the program object to be
 * validated.
 */
static inline void glValidateProgram(GLuint program)
{
  glad_glValidateProgram(program);
}
/**
 * glValidateProgramPipeline — validate a program pipeline object against
 * current GL state
 *
 * @param [pipeline] Specifies the name of a program pipeline object to
 * validate.
 */
static inline void glValidateProgramPipeline(GLuint pipeline)
{
  glad_glValidateProgramPipeline(pipeline);
}
/**
 * glVertexArrayElementBuffer — configures element array buffer binding of a
 * vertex array object
 *
 * @param [vaobj] Specifies the name of the vertex array object.
 *
 * @param [buffer] Specifies the name of the buffer object to use for the
 * element array buffer binding.
 */
static inline void glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer)
{
  glad_glVertexArrayElementBuffer(vaobj, buffer);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib1f(GLuint index, GLfloat v0)
{
  glad_glVertexAttrib1f(index, v0);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib1s(GLuint index, GLshort v0)
{
  glad_glVertexAttrib1s(index, v0);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib1d(GLuint index, GLdouble v0)
{
  glad_glVertexAttrib1d(index, v0);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI1i(GLuint index, GLint v0)
{
  glad_glVertexAttribI1i(index, v0);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI1ui(GLuint index, GLuint v0)
{
  glad_glVertexAttribI1ui(index, v0);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1)
{
  glad_glVertexAttrib2f(index, v0, v1);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1)
{
  glad_glVertexAttrib2s(index, v0, v1);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1)
{
  glad_glVertexAttrib2d(index, v0, v1);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI2i(GLuint index, GLint v0, GLint v1)
{
  glad_glVertexAttribI2i(index, v0, v1);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1)
{
  glad_glVertexAttribI2ui(index, v0, v1);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1,
                                    GLfloat v2)
{
  glad_glVertexAttrib3f(index, v0, v1, v2);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1,
                                    GLshort v2)
{
  glad_glVertexAttrib3s(index, v0, v1, v2);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1,
                                    GLdouble v2)
{
  glad_glVertexAttrib3d(index, v0, v1, v2);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2)
{
  glad_glVertexAttribI3i(index, v0, v1, v2);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1,
                                      GLuint v2)
{
  glad_glVertexAttribI3ui(index, v0, v1, v2);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1,
                                    GLfloat v2, GLfloat v3)
{
  glad_glVertexAttrib4f(index, v0, v1, v2, v3);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1,
                                    GLshort v2, GLshort v3)
{
  glad_glVertexAttrib4s(index, v0, v1, v2, v3);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1,
                                    GLdouble v2, GLdouble v3)
{
  glad_glVertexAttrib4d(index, v0, v1, v2, v3);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1,
                                      GLubyte v2, GLubyte v3)
{
  glad_glVertexAttrib4Nub(index, v0, v1, v2, v3);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2,
                                     GLint v3)
{
  glad_glVertexAttribI4i(index, v0, v1, v2, v3);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1,
                                      GLuint v2, GLuint v3)
{
  glad_glVertexAttribI4ui(index, v0, v1, v2, v3);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribL1d(GLuint index, GLdouble v0)
{
  glad_glVertexAttribL1d(index, v0);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1)
{
  glad_glVertexAttribL2d(index, v0, v1);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1,
                                     GLdouble v2)
{
  glad_glVertexAttribL3d(index, v0, v1, v2);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1,
                                     GLdouble v2, GLdouble v3)
{
  glad_glVertexAttribL4d(index, v0, v1, v2, v3);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib1fv(GLuint index, const GLfloat *v)
{
  glad_glVertexAttrib1fv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib1sv(GLuint index, const GLshort *v)
{
  glad_glVertexAttrib1sv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib1dv(GLuint index, const GLdouble *v)
{
  glad_glVertexAttrib1dv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI1iv(GLuint index, const GLint *v)
{
  glad_glVertexAttribI1iv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI1uiv(GLuint index, const GLuint *v)
{
  glad_glVertexAttribI1uiv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib2fv(GLuint index, const GLfloat *v)
{
  glad_glVertexAttrib2fv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib2sv(GLuint index, const GLshort *v)
{
  glad_glVertexAttrib2sv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib2dv(GLuint index, const GLdouble *v)
{
  glad_glVertexAttrib2dv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI2iv(GLuint index, const GLint *v)
{
  glad_glVertexAttribI2iv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI2uiv(GLuint index, const GLuint *v)
{
  glad_glVertexAttribI2uiv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib3fv(GLuint index, const GLfloat *v)
{
  glad_glVertexAttrib3fv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib3sv(GLuint index, const GLshort *v)
{
  glad_glVertexAttrib3sv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib3dv(GLuint index, const GLdouble *v)
{
  glad_glVertexAttrib3dv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI3iv(GLuint index, const GLint *v)
{
  glad_glVertexAttribI3iv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI3uiv(GLuint index, const GLuint *v)
{
  glad_glVertexAttribI3uiv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4fv(GLuint index, const GLfloat *v)
{
  glad_glVertexAttrib4fv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4sv(GLuint index, const GLshort *v)
{
  glad_glVertexAttrib4sv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4dv(GLuint index, const GLdouble *v)
{
  glad_glVertexAttrib4dv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4iv(GLuint index, const GLint *v)
{
  glad_glVertexAttrib4iv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4bv(GLuint index, const GLbyte *v)
{
  glad_glVertexAttrib4bv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4ubv(GLuint index, const GLubyte *v)
{
  glad_glVertexAttrib4ubv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4usv(GLuint index, const GLushort *v)
{
  glad_glVertexAttrib4usv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4uiv(GLuint index, const GLuint *v)
{
  glad_glVertexAttrib4uiv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4Nbv(GLuint index, const GLbyte *v)
{
  glad_glVertexAttrib4Nbv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4Nsv(GLuint index, const GLshort *v)
{
  glad_glVertexAttrib4Nsv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4Niv(GLuint index, const GLint *v)
{
  glad_glVertexAttrib4Niv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4Nubv(GLuint index, const GLubyte *v)
{
  glad_glVertexAttrib4Nubv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4Nusv(GLuint index, const GLushort *v)
{
  glad_glVertexAttrib4Nusv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttrib4Nuiv(GLuint index, const GLuint *v)
{
  glad_glVertexAttrib4Nuiv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI4bv(GLuint index, const GLbyte *v)
{
  glad_glVertexAttribI4bv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI4ubv(GLuint index, const GLubyte *v)
{
  glad_glVertexAttribI4ubv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI4sv(GLuint index, const GLshort *v)
{
  glad_glVertexAttribI4sv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI4usv(GLuint index, const GLushort *v)
{
  glad_glVertexAttribI4usv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI4iv(GLuint index, const GLint *v)
{
  glad_glVertexAttribI4iv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribI4uiv(GLuint index, const GLuint *v)
{
  glad_glVertexAttribI4uiv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribL1dv(GLuint index, const GLdouble *v)
{
  glad_glVertexAttribL1dv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribL2dv(GLuint index, const GLdouble *v)
{
  glad_glVertexAttribL2dv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribL3dv(GLuint index, const GLdouble *v)
{
  glad_glVertexAttribL3dv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribL4dv(GLuint index, const GLdouble *v)
{
  glad_glVertexAttribL4dv(index, v);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribP1ui(GLuint index, GLenum type,
                                      GLboolean normalized, GLuint value)
{
  glad_glVertexAttribP1ui(index, type, normalized, value);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribP2ui(GLuint index, GLenum type,
                                      GLboolean normalized, GLuint value)
{
  glad_glVertexAttribP2ui(index, type, normalized, value);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribP3ui(GLuint index, GLenum type,
                                      GLboolean normalized, GLuint value)
{
  glad_glVertexAttribP3ui(index, type, normalized, value);
}
/**
 * glVertexAttrib — Specifies the value of a generic vertex attribute
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [v0, v1, v2, v3] For the scalar commands, specifies the new values
 * to be used for the specified vertex attribute.
 *
 * @param [v] For the vector commands (glVertexAttrib*v), specifies a pointer
 * to an array of values to be used for the generic vertex attribute.
 *
 * @param [type] For the packed commands (glVertexAttribP*), specified the
 * type of packing used on the data. This parameter must be
 * GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed
 * or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to
 * specify floating point data.
 *
 * @param [normalized] For the packed commands, if GL_TRUE, then the values
 * are to be converted to floating point values by normalizing. Otherwise,
 * they are converted directly to floating-point values. If type indicates a
 * floating-pont format, then normalized value must be GL_FALSE.
 *
 * @param [value] For the packed commands, specifies the new packed value to
 * be used for the specified vertex attribute.
 */
static inline void glVertexAttribP4ui(GLuint index, GLenum type,
                                      GLboolean normalized, GLuint value)
{
  glad_glVertexAttribP4ui(index, type, normalized, value);
}
/**
 * glVertexAttribBinding — associate a vertex attribute and a vertex buffer
 * binding for a vertex array object
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 * glVertexArrayAttribBinding.
 *
 * @param [attribindex] The index of the attribute to associate with a vertex
 * buffer binding.
 *
 * @param [bindingindex] The index of the vertex buffer binding with which to
 * associate the generic vertex attribute.
 */
static inline void glVertexAttribBinding(GLuint attribindex,
                                         GLuint bindingindex)
{
  glad_glVertexAttribBinding(attribindex, bindingindex);
}
/**
 * glVertexAttribBinding — associate a vertex attribute and a vertex buffer
 * binding for a vertex array object
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 * glVertexArrayAttribBinding.
 *
 * @param [attribindex] The index of the attribute to associate with a vertex
 * buffer binding.
 *
 * @param [bindingindex] The index of the vertex buffer binding with which to
 * associate the generic vertex attribute.
 */
static inline void glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex,
                                              GLuint bindingindex)
{
  glad_glVertexArrayAttribBinding(vaobj, attribindex, bindingindex);
}
/**
 * glVertexAttribDivisor — modify the rate at which generic vertex attributes
 * advance during instanced rendering
 *
 * @param [index] Specify the index of the generic vertex attribute.
 *
 * @param [divisor] Specify the number of instances that will pass between
 * updates of the generic attribute at slot index.
 */
static inline void glVertexAttribDivisor(GLuint index, GLuint divisor)
{
  glad_glVertexAttribDivisor(index, divisor);
}
/**
 * glVertexAttribFormat, glVertexArrayAttribFormat — specify the organization
 * of vertex arrays
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 * glVertexArrayAttrib{I, L}Format functions.
 *
 * @param [attribindex] The generic vertex attribute array being described.
 *
 * @param [size] The number of values per vertex that are stored in the array.
 *
 * @param [type] The type of the data stored in the array.
 *
 * @param [normalized] GL_TRUE if the parameter represents a normalized
 * integer (type must be an integer type). GL_FALSE otherwise.
 *
 * @param [relativeoffset] The offset, measured in basic machine units of the
 * first element relative to the start of the vertex buffer binding this
 * attribute fetches from.
 */
static inline void glVertexAttribFormat(GLuint attribindex, GLint size,
                                        GLenum type, GLboolean normalized,
                                        GLuint relativeoffset)
{
  glad_glVertexAttribFormat(attribindex, size, type, normalized,
                            relativeoffset);
}
/**
 * glVertexAttribFormat, glVertexArrayAttribFormat — specify the organization
 * of vertex arrays
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 * glVertexArrayAttrib{I, L}Format functions.
 *
 * @param [attribindex] The generic vertex attribute array being described.
 *
 * @param [size] The number of values per vertex that are stored in the array.
 *
 * @param [type] The type of the data stored in the array.
 *
 * @param [normalized] GL_TRUE if the parameter represents a normalized
 * integer (type must be an integer type). GL_FALSE otherwise.
 *
 * @param [relativeoffset] The offset, measured in basic machine units of the
 * first element relative to the start of the vertex buffer binding this
 * attribute fetches from.
 */
static inline void glVertexAttribIFormat(GLuint attribindex, GLint size,
                                         GLenum type, GLuint relativeoffset)
{
  glad_glVertexAttribIFormat(attribindex, size, type, relativeoffset);
}
/**
 * glVertexAttribFormat, glVertexArrayAttribFormat — specify the organization
 * of vertex arrays
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 * glVertexArrayAttrib{I, L}Format functions.
 *
 * @param [attribindex] The generic vertex attribute array being described.
 *
 * @param [size] The number of values per vertex that are stored in the array.
 *
 * @param [type] The type of the data stored in the array.
 *
 * @param [normalized] GL_TRUE if the parameter represents a normalized
 * integer (type must be an integer type). GL_FALSE otherwise.
 *
 * @param [relativeoffset] The offset, measured in basic machine units of the
 * first element relative to the start of the vertex buffer binding this
 * attribute fetches from.
 */
static inline void glVertexAttribLFormat(GLuint attribindex, GLint size,
                                         GLenum type, GLuint relativeoffset)
{
  glad_glVertexAttribLFormat(attribindex, size, type, relativeoffset);
}
/**
 * glVertexAttribFormat, glVertexArrayAttribFormat — specify the organization
 * of vertex arrays
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 * glVertexArrayAttrib{I, L}Format functions.
 *
 * @param [attribindex] The generic vertex attribute array being described.
 *
 * @param [size] The number of values per vertex that are stored in the array.
 *
 * @param [type] The type of the data stored in the array.
 *
 * @param [normalized] GL_TRUE if the parameter represents a normalized
 * integer (type must be an integer type). GL_FALSE otherwise.
 *
 * @param [relativeoffset] The offset, measured in basic machine units of the
 * first element relative to the start of the vertex buffer binding this
 * attribute fetches from.
 */
static inline void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex,
                                             GLint size, GLenum type,
                                             GLboolean normalized,
                                             GLuint relativeoffset)
{
  glad_glVertexArrayAttribFormat(vaobj, attribindex, size, type, normalized,
                                 relativeoffset);
}
/**
 * glVertexAttribFormat, glVertexArrayAttribFormat — specify the organization
 * of vertex arrays
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 * glVertexArrayAttrib{I, L}Format functions.
 *
 * @param [attribindex] The generic vertex attribute array being described.
 *
 * @param [size] The number of values per vertex that are stored in the array.
 *
 * @param [type] The type of the data stored in the array.
 *
 * @param [normalized] GL_TRUE if the parameter represents a normalized
 * integer (type must be an integer type). GL_FALSE otherwise.
 *
 * @param [relativeoffset] The offset, measured in basic machine units of the
 * first element relative to the start of the vertex buffer binding this
 * attribute fetches from.
 */
static inline void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex,
                                              GLint size, GLenum type,
                                              GLuint relativeoffset)
{
  glad_glVertexArrayAttribIFormat(vaobj, attribindex, size, type,
                                  relativeoffset);
}
/**
 * glVertexAttribFormat, glVertexArrayAttribFormat — specify the organization
 * of vertex arrays
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 * glVertexArrayAttrib{I, L}Format functions.
 *
 * @param [attribindex] The generic vertex attribute array being described.
 *
 * @param [size] The number of values per vertex that are stored in the array.
 *
 * @param [type] The type of the data stored in the array.
 *
 * @param [normalized] GL_TRUE if the parameter represents a normalized
 * integer (type must be an integer type). GL_FALSE otherwise.
 *
 * @param [relativeoffset] The offset, measured in basic machine units of the
 * first element relative to the start of the vertex buffer binding this
 * attribute fetches from.
 */
static inline void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex,
                                              GLint size, GLenum type,
                                              GLuint relativeoffset)
{
  glad_glVertexArrayAttribLFormat(vaobj, attribindex, size, type,
                                  relativeoffset);
}
/**
 * glVertexAttribPointer — define an array of generic vertex attribute data
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [size] Specifies the number of components per generic vertex
 * attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA
 * is accepted by glVertexAttribPointer. The initial value is 4.
 *
 * @param [type] Specifies the data type of each component in the array. The
 * symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT,
 * GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and
 * glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE,
 * GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and
 * GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer.
 * GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token
 * accepted by the type parameter for that function. The initial value is
 * GL_FLOAT.
 *
 * @param [normalized] For glVertexAttribPointer, specifies whether
 * fixed-point data values should be normalized (GL_TRUE) or converted
 * directly as fixed-point values (GL_FALSE) when they are accessed.
 *
 * @param [stride] Specifies the byte offset between consecutive generic
 * vertex attributes. If stride is 0, the generic vertex attributes are
 * understood to be tightly packed in the array. The initial value is 0.
 *
 * @param [pointer] Specifies a offset of the first component of the first
 * generic vertex attribute in the array in the data store of the buffer
 * currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
 */
static inline void glVertexAttribPointer(GLuint index, GLint size, GLenum type,
                                         GLboolean normalized, GLsizei stride,
                                         const GLvoid *pointer)
{
  glad_glVertexAttribPointer(index, size, type, normalized, stride, pointer);
}
/**
 * glVertexAttribPointer — define an array of generic vertex attribute data
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [size] Specifies the number of components per generic vertex
 * attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA
 * is accepted by glVertexAttribPointer. The initial value is 4.
 *
 * @param [type] Specifies the data type of each component in the array. The
 * symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT,
 * GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and
 * glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE,
 * GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and
 * GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer.
 * GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token
 * accepted by the type parameter for that function. The initial value is
 * GL_FLOAT.
 *
 * @param [normalized] For glVertexAttribPointer, specifies whether
 * fixed-point data values should be normalized (GL_TRUE) or converted
 * directly as fixed-point values (GL_FALSE) when they are accessed.
 *
 * @param [stride] Specifies the byte offset between consecutive generic
 * vertex attributes. If stride is 0, the generic vertex attributes are
 * understood to be tightly packed in the array. The initial value is 0.
 *
 * @param [pointer] Specifies a offset of the first component of the first
 * generic vertex attribute in the array in the data store of the buffer
 * currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
 */
static inline void glVertexAttribIPointer(GLuint index, GLint size, GLenum type,
                                          GLsizei stride, const GLvoid *pointer)
{
  glad_glVertexAttribIPointer(index, size, type, stride, pointer);
}
/**
 * glVertexAttribPointer — define an array of generic vertex attribute data
 *
 * @param [index] Specifies the index of the generic vertex attribute to be
 * modified.
 *
 * @param [size] Specifies the number of components per generic vertex
 * attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA
 * is accepted by glVertexAttribPointer. The initial value is 4.
 *
 * @param [type] Specifies the data type of each component in the array. The
 * symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT,
 * GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and
 * glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE,
 * GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and
 * GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer.
 * GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token
 * accepted by the type parameter for that function. The initial value is
 * GL_FLOAT.
 *
 * @param [normalized] For glVertexAttribPointer, specifies whether
 * fixed-point data values should be normalized (GL_TRUE) or converted
 * directly as fixed-point values (GL_FALSE) when they are accessed.
 *
 * @param [stride] Specifies the byte offset between consecutive generic
 * vertex attributes. If stride is 0, the generic vertex attributes are
 * understood to be tightly packed in the array. The initial value is 0.
 *
 * @param [pointer] Specifies a offset of the first component of the first
 * generic vertex attribute in the array in the data store of the buffer
 * currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
 */
static inline void glVertexAttribLPointer(GLuint index, GLint size, GLenum type,
                                          GLsizei stride, const GLvoid *pointer)
{
  glad_glVertexAttribLPointer(index, size, type, stride, pointer);
}
/**
 * glVertexBindingDivisor, glVertexArrayBindingDivisor — modify the rate at
 which generic vertex attributes advance
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 glVertexArrayBindingDivisor function.
 *
 * @param [bindingindex] The index of the binding whose divisor to modify.
 *
 * @param [divisor] The new value for the instance step rate to apply.
 */
static inline void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor)
{
  glad_glVertexBindingDivisor(bindingindex, divisor);
}
/**
 * glVertexBindingDivisor, glVertexArrayBindingDivisor — modify the rate at
 which generic vertex attributes advance
 *
 * @param [vaobj] Specifies the name of the vertex array object for
 glVertexArrayBindingDivisor function.
 *
 * @param [bindingindex] The index of the binding whose divisor to modify.
 *
 * @param [divisor] The new value for the instance step rate to apply.
 */
static inline void
glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor)
{
  glad_glVertexArrayBindingDivisor(vaobj, bindingindex, divisor);
}
/**
 * glViewport — set the viewport
 *
 * @param [x, y] Specify the lower left corner of the viewport rectangle, in
 * pixels. The initial value is (0,0).
 *
 * @param [width, height] Specify the width and height of the viewport. When a
 * GL context is first attached to a window, width and height are set to the
 * dimensions of that window.
 */
static inline void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
  glad_glViewport(x, y, width, height);
}
/**
 * glViewportArray — set multiple viewports
 *
 * @param [first] Specify the first viewport to set.
 *
 * @param [count] Specify the number of viewports to set.
 *
 * @param [v] Specify the address of an array containing the viewport
 * parameters.
 */
static inline void glViewportArrayv(GLuint first, GLsizei count,
                                    const GLfloat *v)
{
  glad_glViewportArrayv(first, count, v);
}
/**
 * glViewportIndexed — set a specified viewport
 *
 * @param [index] Specify the first viewport to set.
 *
 * @param [x, y] For glViewportIndexedf, specifies the lower left corner of
 * the viewport rectangle, in pixels. The initial value is (0,0).
 *
 * @param [width, height] For glViewportIndexedf, specifies the width and
 * height of the viewport. When a GL context is first attached to a window,
 * width and height are set to the dimensions of that window.
 *
 * @param [v] For glViewportIndexedfv, specifies the address of an array
 * containing the viewport parameters.
 */
static inline void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y,
                                      GLfloat w, GLfloat h)
{
  glad_glViewportIndexedf(index, x, y, w, h);
}
/**
 * glViewportIndexed — set a specified viewport
 *
 * @param [index] Specify the first viewport to set.
 *
 * @param [x, y] For glViewportIndexedf, specifies the lower left corner of
 * the viewport rectangle, in pixels. The initial value is (0,0).
 *
 * @param [width, height] For glViewportIndexedf, specifies the width and
 * height of the viewport. When a GL context is first attached to a window,
 * width and height are set to the dimensions of that window.
 *
 * @param [v] For glViewportIndexedfv, specifies the address of an array
 * containing the viewport parameters.
 */
static inline void glViewportIndexedfv(GLuint index, const GLfloat *v)
{
  glad_glViewportIndexedfv(index, v);
}
/**
 * glWaitSync — instruct the GL server to block until the specified sync
 * object becomes signaled
 *
 * @param [sync] Specifies the sync object whose status to wait on.
 *
 * @param [flags] A bitfield controlling the command flushing behavior. flags
 * may be zero.
 *
 * @param [timeout] Specifies the timeout that the server should wait before
 * continuing. timeout must be GL_TIMEOUT_IGNORED.
 */
static inline void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
  glad_glWaitSync(sync, flags, timeout);
}

#endif // GL_DOC_HPP
